(
echo ${E_BOLD}${E_WHITE_FG}${(C)${0/tip_/}:t:r} Tips${E_RESET}
cat << tip_pup_EOF

${E_WHITE_FG}Pup Documentation${E_RESET}
------------------------------------

${E_WHITE_FG}pup${E_RESET} is a command line tool for processing HTML. It reads from stdin, prints to stdout, and allows the user to filter 
parts of the page using CSS selectors.


${E_GREEN_FG}Implemented Selectors${E_RESET}
---------------------------------
${E_WHITE_FG}pup '.class'${E_RESET}
${E_WHITE_FG}pup '#id'${E_RESET}
${E_WHITE_FG}pup 'element'${E_RESET}
${E_WHITE_FG}pup 'selector + selector' (adjacent sibling)${E_RESET}
${E_WHITE_FG}pup 'selector > selector' (direct descendent)${E_RESET}
${E_WHITE_FG}pup '[attribute]'${E_RESET}
${E_WHITE_FG}pup '[attribute="value"]'${E_RESET}
${E_WHITE_FG}pup '[attribute*="value"]'${E_RESET}
${E_WHITE_FG}pup '[attribute~="value"]'${E_RESET}
${E_WHITE_FG}pup '[attribute^="value"]'${E_RESET}
${E_WHITE_FG}pup '[attribute\$="value"]'${E_RESET}
${E_WHITE_FG}pup ':empty'${E_RESET}
${E_WHITE_FG}pup ':first-child'${E_RESET}
${E_WHITE_FG}pup ':first-of-type'${E_RESET}
${E_WHITE_FG}pup ':last-child'${E_RESET}
${E_WHITE_FG}pup ':last-of-type'${E_RESET}
${E_WHITE_FG}pup ':only-child'${E_RESET}
${E_WHITE_FG}pup ':only-of-type'${E_RESET}
${E_WHITE_FG}pup ':contains("text")'${E_RESET}
${E_WHITE_FG}pup ':nth-child(n)' ${E_BOLD}${E_RED_FG}*${E_RESET}
${E_WHITE_FG}pup ':nth-of-type(n)' ${E_BOLD}${E_RED_FG}*${E_RESET}
${E_WHITE_FG}pup ':nth-last-child(n)' ${E_BOLD}${E_RED_FG}*${E_RESET}
${E_WHITE_FG}pup ':nth-last-of-type(n)' ${E_BOLD}${E_RED_FG}*${E_RESET}
${E_WHITE_FG}pup ':not(selector)'${E_RESET}
${E_WHITE_FG}pup ':parent-of(selector)'${E_RESET}

${E_GREEN_FG}Basic Usage${E_RESET}
-----------
$ cat index.html | ${E_WHITE_FG}pup [flags] '[selectors] [display function]'${E_RESET}

${E_GREEN_FG}Examples${E_RESET}
--------
$ curl -s https://news.ycombinator.com/

Ew, HTML. Let's run that through some ${E_WHITE_FG}pup${E_RESET} selectors:
$ curl -s https://news.ycombinator.com/ | ${E_WHITE_FG}pup 'table table tr:nth-last-of-type(n+2) td.title a'${E_RESET}

Okay, how about only the links?
$ curl -s https://news.ycombinator.com/ | ${E_WHITE_FG}pup 'table table tr:nth-last-of-type(n+2) td.title a attr{href}'${E_RESET}

Even better, let's grab the titles too:
$ curl -s https://news.ycombinator.com/ | ${E_WHITE_FG}pup 'table table tr:nth-last-of-type(n+2) td.title a json{}'${E_RESET}

--------
Download a webpage with wget.
--------

$ wget http://en.wikipedia.org/wiki/Robots_exclusion_standard -O robots.html

-->${E_GREEN_FG}Clean and indent${E_RESET}
-------------------
By default ${E_WHITE_FG}pup${E_RESET} will fill in missing tags and properly indent the page.

$ cat robots.html
# nasty looking HTML
$ cat robots.html | ${E_WHITE_FG}pup --color${E_RESET}
# cleaned, indented, and colorful HTML

-->${E_GREEN_FG}Filter by tag${E_RESET}
----------------
$ cat robots.html | ${E_WHITE_FG}pup 'title'${E_RESET}
<title>
 Robots exclusion standard - Wikipedia, the free encyclopedia
</title>

-->${E_GREEN_FG}Filter by id${E_RESET}
---------------
$ cat robots.html | ${E_WHITE_FG}pup 'span#See_also'${E_RESET}
<span class="mw-headline" id="See_also">
 See also
</span>

-->${E_GREEN_FG}Filter by attribute${E_RESET}
----------------------
$ cat robots.html | ${E_WHITE_FG}pup 'th[scope="row"]'${E_RESET}
<th scope="row" class="navbox-group">
 Exclusion standards
</th>
<th scope="row" class="navbox-group">
 Related marketing topics
</th>
<th scope="row" class="navbox-group">
 Search marketing related topics
</th>
<th scope="row" class="navbox-group">
 Search engine spam
</th>
<th scope="row" class="navbox-group">
 Linking
</th>
<th scope="row" class="navbox-group">
 People
</th>
<th scope="row" class="navbox-group">
 Other
</th>

${E_GREEN_FG}Pseudo Classes${E_RESET}
---------------------------------

CSS selectors have a group of specifiers called "pseudo classes" which are pretty cool. 
${E_WHITE_FG}pup${E_RESET} implements a majority of the relevant ones them.

${E_YELLOW_FG}Here are some examples.

$ cat robots.html | ${E_WHITE_FG}pup 'a[rel]:empty'${E_RESET}
<a rel="license" href="//creativecommons.org/licenses/by-sa/3.0/" style="display:none;">
</a>
$ cat robots.html | ${E_WHITE_FG}pup ':contains("History")'${E_RESET}
<span class="toctext">
 History
</span>
<span class="mw-headline" id="History">
 History
</span>
$ cat robots.html | ${E_WHITE_FG}pup ':parent-of([action="edit"])'${E_RESET}
<span class="wb-langlinks-edit wb-langlinks-link">
 <a action="edit" href="//www.wikidata.org/wiki/Q80776#sitelinks-wikipedia" text="Edit links" title="Edit interlanguage links" class="wbc-editpage">
  Edit links
 </a>
</span>

============================================================
For a complete list, view the implemented selectors section.
============================================================

${E_GREEN_FG}+, >, and ,${E_RESET}
---------------------------------
These are intermediate characters that declare special instructions. 

${E_GREEN_FG}For instance, a comma , allows ${E_WHITE_FG}pup${E_RESET} to specify multiple groups of selectors.${E_RESET}
---------------------------------------------------------------------------
$ cat robots.html | ${E_WHITE_FG}pup 'title, h1 span[dir="auto"]'${E_RESET}
<title>
 Robots exclusion standard - Wikipedia, the free encyclopedia
</title>
<span dir="auto">
 Robots exclusion standard
</span>

Chain selectors together...
${E_GREEN_FG}When combining selectors, the HTML nodes selected by the previous selector will be passed to the next ones.${E_RESET}
-----------------------------------------------------------------------------------------------------------
$ cat robots.html | ${E_WHITE_FG}pup 'h1#firstHeading'${E_RESET}
<h1 id="firstHeading" class="firstHeading" lang="en">
 <span dir="auto">
  Robots exclusion standard
 </span>
</h1>
$ cat robots.html | ${E_WHITE_FG}pup 'h1#firstHeading span'${E_RESET}
<span dir="auto">
 Robots exclusion standard
</span>


${E_BOLD}${E_RED_FG}*${E_RESET}${E_WHITE_FG} Optionally use a formula (an + b).${E_RESET}
Description: 'a' represents a cycle size, 'n' is a counter (starts at 0), and 'b' is an offset value.
So, ${E_WHITE_FG}p:nth-child(3n+0)${E_RESET} references all p elements whose index is a multiple of 3

${E_GREEN_FG}You can mix and match selectors as you wish.${E_RESET}
--------------------------------------------
cat index.html | ${E_WHITE_FG}pup 'element#id[attribute="value"]:first-of-type'${E_RESET}

${E_GREEN_FG}Display Functions${E_RESET}
---------------------------------
Non-HTML selectors which effect the output type are implemented as functions which can be provided as a final argument.

${E_WHITE_FG}text{}${E_RESET} -> Print all text from selected nodes and children in depth first order.
------------------------------------------------------------------------------
$ cat robots.html | ${E_WHITE_FG}pup '.mw-headline text{}'${E_RESET}
History
About the standard
Disadvantages
Alternatives
Examples
Nonstandard extensions
Crawl-delay directive
Allow directive
Sitemap
Host
Universal "*" match
Meta tags and headers
See also
References
External links

${E_WHITE_FG}attr{attrkey}${E_RESET} -> Print the values of all attributes with a given key from all selected nodes.${E_RESET}
---------------------------------------------------------------------------------------------
$ cat robots.html | ${E_WHITE_FG}pup '.catlinks div attr{id}'${E_RESET}
mw-normal-catlinks
mw-hidden-catlinks

${E_WHITE_FG}json{}${E_RESET} -> Print HTML as JSON.${E_RESET}
-----------------------------
$ cat robots.html  | ${E_WHITE_FG}pup 'div#p-namespaces a'${E_RESET}
<a href="/wiki/Robots_exclusion_standard" title="View the content page [c]" accesskey="c">
 Article
</a>
<a href="/wiki/Talk:Robots_exclusion_standard" title="Discussion about the content page [t]" accesskey="t">
 Talk
</a>
$ cat robots.html | ${E_WHITE_FG}pup 'div#p-namespaces a json{}'${E_RESET}
[
 {
  "accesskey": "c",
  "href": "/wiki/Robots_exclusion_standard",
  "tag": "a",
  "text": "Article",
  "title": "View the content page [c]"
 },
 {
  "accesskey": "t",
  "href": "/wiki/Talk:Robots_exclusion_standard",
  "tag": "a",
  "text": "Talk",
  "title": "Discussion about the content page [t]"
 }
]

${E_GREEN_FG}Use the -i / --indent flag to control the indent level.${E_RESET}
-------------------------------------------------------
$ cat robots.html | ${E_WHITE_FG}pup -i 4 'div#p-namespaces a json{}'${E_RESET}
[
    {
        "accesskey": "c",
        "href": "/wiki/Robots_exclusion_standard",
        "tag": "a",
        "text": "Article",
        "title": "View the content page [c]"
    },
    {
        "accesskey": "t",
        "href": "/wiki/Talk:Robots_exclusion_standard",
        "tag": "a",
        "text": "Talk",
        "title": "Discussion about the content page [t]"
    }
]

${E_GREEN_FG}If the selectors only return one element the results will be printed as a JSON object, not a list.${E_RESET}
--------------------------------------------------------------------------------------------------
$ cat robots.html  | ${E_WHITE_FG}pup --indent 4 'title json{}'${E_RESET}
{
    "tag": "title",
    "text": "Robots exclusion standard - Wikipedia, the free encyclopedia"
}

Because there is no universal standard for converting HTML/XML to JSON, a method has been 
chosen which hopefully fits. The goal is simply to get the output of ${E_WHITE_FG}pup${E_RESET} into a more consumable format.

${E_GREEN_FG}Flags${E_RESET}
---------------------------------
Run ${E_WHITE_FG}pup --help${E_RESET} for a list of further options:

Usage
    -pup [flags] [selectors] [optional display function]
Version
    0.4.0
Flags
    -c --color         print result with color
    -f --file          file to read from
    -h --help          display this help
    -i --indent        number of spaces to use for indent or character
    -n --number        print number of elements selected
    -l --limit         restrict number of levels printed
    -p --plain         don't escape html
    --pre              preserve preformatted text
    --charset          specify the charset for pup to use
    --version          display version


${E_BOLD}${E_WHITE_FG}Pup Tutorial${E_RESET}
------------------------------------
${E_WHITE_FG}Selecting elements by tag${E_RESET}

Given this HTML snippet below:
<img src="/files/pages/nyt-displays.jpg">
  the tag of this element is img

To select the img tag, via ${E_WHITE_FG}pup${E_RESET}: cat nyt-sample.html | ${E_WHITE_FG}pup${E_RESET} 'img' 
This returns:

${E_GREEN_FG}<img src="/files/pages/nyt-displays.jpg">${E_RESET}

${E_WHITE_FG}Selecting elements by id or class${E_RESET}

In HTML, there's relatively few kinds of tags. To differentiate between elements with the same tag, 
elements are given different ids or classes.

For example, try selecting all the h1 tags: cat nyt-sample.html | ${E_WHITE_FG}pup${E_RESET} 'h1'

You'll see output that includes this:

${E_GREEN_FG}<h1 id="main-title">
${E_GREEN_FG} Stories from the New York Times
${E_GREEN_FG}</h1>
${E_GREEN_FG}<h1 class="headline">
${E_GREEN_FG} <a href="http://www.nytimes.com/2015/01/09/business/honda-fined-70-million-in-underreporting-safety-issues-to-government.html">
${E_GREEN_FG}  Honda Hit With Record Fine for Not Reporting Deaths
${E_GREEN_FG} </a>
${E_GREEN_FG}</h1>${E_RESET}

${E_WHITE_FG}Selecting elements by id attribute${E_RESET}

To select the first h1 element (that has the text, Stories from the New York Times), 
we can select it exclusively by targeting its id attribute: cat nyt-sample.html | ${E_WHITE_FG}pup${E_RESET} 'h1#main-title'

In this case, since it happens to be the only element on the page with an 
id of main-title, this selector would work just as well:

cat nyt-sample.html | ${E_WHITE_FG}pup${E_RESET} '#main-title'

${E_WHITE_FG}Selecting elements by class attribute${E_RESET}

To get the other h1-tagged elements, we see that they all have a class of headline. 

The dot is used to select for class: cat nyt-sample.html | ${E_WHITE_FG}pup${E_RESET} 'h1.headline'

${E_WHITE_FG}Selecting child elements${E_RESET}

Given this HTML snippet:
<article>
  <h1 class="headline">
    <a href="http://www.nytimes.com/2015/01/09/sports/program-prepares-the...\>
  </h1>
  <p class="description">
    After becoming a grandmaster at the tender age of 13, Sam Sevian is getting some help from the chess champion Garry Kasparov.
  </p>
</article>

The p element can be thought of as the child of the article element. 

To target that p element: cat nyt-sample.html | ${E_WHITE_FG}pup${E_RESET} 'article p'

And you can also see that that a element is a child of the h1 element which itself is a 
child of that article. Here's the most specific way to target that a element:

cat nyt-sample.html | ${E_WHITE_FG}pup${E_RESET} 'article h1 a'

${E_WHITE_FG}Selecting the attribute value of an element${E_RESET}

In the img tag, the src attribute points to where the image file is physically located:
<img src="/files/pages/nyt-displays.jpg">

To get the src attribute of this img tag: cat nyt-sample.html | ${E_WHITE_FG}pup${E_RESET} 'img attr{src}' 

${E_GREEN_FG}/files/pages/nyt-displays.jpg${E_RESET}

The attribute that you'll deal with the most in web-scraping is the href attribute which 
is part of standard a-tagged elements (i.e. anchor links, or, "hyperlinks").

To get all the values of the href attributes for all the a tags on the page: cat nyt-sample.html | ${E_WHITE_FG}pup${E_RESET} 'a attr{href}'

${E_GREEN_FG}http://www.nytimes.com
${E_GREEN_FG}https://www.flickr.com/photos/zokuga/5804588208/in/photostream/
${E_GREEN_FG}http://www.nytimes.com/2015/01/09/business/honda-fined-70-million-in-underreporting-safety-issues-to-government.html
${E_GREEN_FG}http://www.nytimes.com/2015/01/09/sports/program-prepares-the-chess-prodigy-sam-sevian-for-his-next-moves.html
${E_GREEN_FG}http://www.nytimes.com/2015/01/09/us/in-san-franciscos-tenderloin-a-move-to-help-artists-as-wealth-moves-in.html
${E_GREEN_FG}http://nytimes.com/2015/01/09/opinion/the-stumbling-tumbling-euro.html
${E_GREEN_FG}http://www.nytimes.com/2015/01/09/business/democrats-step-up-efforts-to-block-obama-on-trade-promotion-authority.html
${E_RESET}

To get all the values of the href attributes for just the a-tagged elements that are 
children of the h1-tagged elements (with a class of headline): cat nyt-sample.html | ${E_WHITE_FG}pup${E_RESET} 'h1.headline a attr{href}'

${E_GREEN_FG}http://www.nytimes.com/2015/01/09/business/honda-fined-70-million-in-underreporting-safety-issues-to-government.html
${E_GREEN_FG}http://www.nytimes.com/2015/01/09/sports/program-prepares-the-chess-prodigy-sam-sevian-for-his-next-moves.html
${E_GREEN_FG}http://www.nytimes.com/2015/01/09/us/in-san-franciscos-tenderloin-a-move-to-help-artists-as-wealth-moves-in.html
${E_GREEN_FG}http://nytimes.com/2015/01/09/opinion/the-stumbling-tumbling-euro.html
${E_GREEN_FG}http://www.nytimes.com/2015/01/09/business/democrats-step-up-efforts-to-block-obama-on-trade-promotion-authority.html
${E_RESET}

${E_WHITE_FG}Selecting text elements${E_RESET}

Think of the text elements as the literal text that you see on a page when rendered by the browser.
For example, given this HTML snippet:

<h1 id="main-title">Stories from the New York Times</h1>

The text of the h1 element is "Stories from the New York Times"

Using ${E_WHITE_FG}pup${E_RESET} to select only the text of that h1 element: cat nyt-sample.html | ${E_WHITE_FG}pup${E_RESET} 'h1#main-title text{}'

${E_GREEN_FG}Stories from the New York Times${E_RESET}

${E_BOLD}${E_WHITE_FG}CSS Selector (30 Essential) Tutorial ${E_RESET}
------------------------------------
${E_BOLD}${E_CYAN_FG}1.${E_WHITE_FG} *${E_RESET}

${E_WHITE_FG}* {  
${E_WHITE_FG}    margin: 0;  
${E_WHITE_FG}    padding: 0; 
${E_WHITE_FG}}${E_RESET}

Let's knock the obvious ones out, for the beginners, before we move onto the
more advanced selectors.  The star symbol will target every single element on
the page. Many developers will use this trick to zero out the margins and
padding

While this is certainly fine for quick tests, I'd advise you to never use this
in production code.  It adds too much weight on the browser, and is unnecessary.
The * can also be used with child selectors.

${E_WHITE_FG}#container * {
${E_WHITE_FG}    border: 1px solid black; 
${E_WHITE_FG}}${E_RESET}

This will target every single element that is a child of the # Container div.
Again, try not to use this technique very much, if ever.

${E_BOLD}${E_CYAN_FG}2.${E_WHITE_FG} # X${E_RESET}

${E_WHITE_FG}#container {
${E_WHITE_FG}    width: 960px;    
${E_WHITE_FG}    margin: auto; 
${E_WHITE_FG}}${E_RESET}

Prefixing the hash symbol to a selector allows us to target by using id. This is
easily the most common usage, however be cautious when selectors.

Ask yourself: do I absolutely need to apply an id to this element in order to
target it?  selectors are rigid and don't allow for reuse.  If possible, first
try to use a tag name, one of the new HTML5 elements, or even a pseudo-class.

${E_BOLD}${E_CYAN_FG}3.${E_WHITE_FG} .X${E_RESET}

${E_WHITE_FG}.error {
${E_WHITE_FG}  color: red; 
${E_WHITE_FG}}${E_RESET}

This is a class selector. The difference between id's and classes is that, with
the latter, you can target multiple elements. Use classes when you want your
styling to apply to a group of elements. Alternatively, use id's to find a
needle-in-a-haystack, and style only that specific element.

${E_BOLD}${E_CYAN_FG}4.${E_WHITE_FG} X Y${E_RESET}

${E_WHITE_FG}li a {
${E_WHITE_FG}  text-decoration: none; 
${E_WHITE_FG}}${E_RESET}

The next most comment selector is the descendant selector.  When you need to be
more specific with your selectors, you use these. For example, what if, rather
than targeting all anchor tags, you only need to target the anchors which are
within an unordered list? This is specifically when you'd use a descendant
selector.

${E_BOLD}${E_CYAN_FG}5.${E_WHITE_FG} X${E_RESET}

${E_WHITE_FG}a {
${E_WHITE_FG}    color: red; 
${E_WHITE_FG}}
${E_WHITE_FG}ul { 
${E_WHITE_FG}    margin-left: 0; 
${E_WHITE_FG}}${E_RESET}

What if you want to target all elements on a page, according to their type,
     rather than an id or class name? Keep it simple, and use a type selector.
     If you need to target all unordered lists, use ul {}

${E_BOLD}${E_CYAN_FG}6.${E_WHITE_FG} X:visited and X:link${E_RESET}

${E_WHITE_FG}a:link {
${E_WHITE_FG}    color: red; 
${E_WHITE_FG}} 
${E_WHITE_FG}a:visted { 
${E_WHITE_FG}    color: purple; 
${E_WHITE_FG}}${E_RESET}

We use the :link pseudo-class to target all anchors tags which have yet to be
clicked on.  Alternatively, we also have the :visited pseudo class, which, as
you'd expected, allows us to apply specific styling to only the anchor tags on
the page which have been clicked on, or visited.

${E_BOLD}${E_CYAN_FG}7.${E_WHITE_FG} X + Y${E_RESET}

${E_WHITE_FG}ul + p {
${E_WHITE_FG}   color: red; 
${E_WHITE_FG}}${E_RESET}

This is referred to as an adjacent selector. It will select only the element
that is immediately preceded by the former element. In this case, only the first
paragraph after each ul will have red text.

${E_BOLD}${E_CYAN_FG}8.${E_WHITE_FG} X > Y${E_RESET}

${E_WHITE_FG}div#container > ul {
${E_WHITE_FG}  border: 1px solid black; 
${E_WHITE_FG}}${E_RESET}

The difference between the standard X Y and X > Y is that the latter will only
select direct children.  For example, consider the following markup.

${E_WHITE_FG}<div id="container">    
${E_WHITE_FG}    <ul>       
${E_WHITE_FG}        <li> List Item
${E_WHITE_FG}            <ul>            
${E_WHITE_FG}                <li> Child </li>         
${E_WHITE_FG}            </ul>       
${E_WHITE_FG}        </li>       
${E_WHITE_FG}        <li> List Item </li>       
${E_WHITE_FG}        <li> List Item </li>       
${E_WHITE_FG}        <li> List Item </li>    
${E_WHITE_FG}    </ul> 
${E_WHITE_FG}</div>${E_RESET}

A selector of # Container > ul will only target the ul' which are direct children
of the div with an id of container. It will not target, for instance, the ul
that is a child of the first li.  

For this reason, there are performance benefits in using the child combinator.
In fact, it's recommended particularly when working with JavaScript-based CSS
selector engines.

${E_BOLD}${E_CYAN_FG}9.${E_WHITE_FG} X ~ Y${E_RESET}

${E_WHITE_FG}ul ~ p {
${E_WHITE_FG}   color: red; 
${E_WHITE_FG}}${E_RESET}

This sibling combinator is similar to X + Y, however, it's less strict.  While
an adjacent selector ( ul + p ) will only select the first element that is
immediately preceded by the former selector, this one is more generalized.  It
will select, referring to our example above, any p elements, as long as they
follow a ul.

${E_BOLD}${E_CYAN_FG}10.${E_WHITE_FG} X[title]${E_RESET}

${E_WHITE_FG}a[title] {
${E_WHITE_FG}   color: green; 
${E_WHITE_FG}}${E_RESET}

Referred to as an attributes selector, in our example above, this will only
select the anchor tags that have a title attribute. Anchor tags which do not
will not receive this particular styling. But, what if you need to be more
specific? Well...

${E_BOLD}${E_CYAN_FG}11.${E_WHITE_FG} X[href="foo"]${E_RESET}

${E_WHITE_FG}a[href="http://net.tutsplus.com"] {
${E_WHITE_FG}  color: #1f6053; /* nettuts green */ 
${E_WHITE_FG}}${E_RESET}

The snippet above will style all anchor tags which link to
http://net.tutsplus.com; they'll receive our branded green color. All other
anchor tags will remain unaffected.  Note that we're wrapping the value in
quotes.  Remember to also do this when using a JavaScript CSS selector engine.
When possible, always use CSS3 selectors over unofficial methods.

This works well, though, it's a bit rigid. What if the link does indeed direct
to Nettuts+, but, maybe, the path is nettuts.com rather than the full url? In
those cases we can use a bit of the regular expressions syntax.

${E_BOLD}${E_CYAN_FG}12.${E_WHITE_FG} X[href*="nettuts"]${E_RESET}

${E_WHITE_FG}a[href*="tuts"] {
${E_WHITE_FG}  color: #1f6053; /* nettuts green */ 
${E_WHITE_FG}}${E_RESET}

There we go; that's what we need. The star designates that the proceeding value
must appear somewhere in the attribute's value. That way, this covers
nettuts.com, net.tutsplus.com, and even tutsplus.com.  Keep in mind that this is
a broad statement. What if the anchor tag linked to some non-Envato site with
the string tuts in the url? 

When you need to be more specific, use ^ and $, to reference the beginning and
end of a string, respectively.

${E_BOLD}${E_CYAN_FG}13.${E_WHITE_FG} X[href^="http"]${E_RESET}

${E_WHITE_FG}a[href^="http"] { 
${E_WHITE_FG}    background: url(path/to/external/icon.png) no-repeat;
${E_WHITE_FG}    padding-left: 10px;
${E_WHITE_FG}}${E_RESET}

Ever wonder how some websites are able to display a little icon next to the
links which are external? I'm sure you've seen these before; they're nice
reminders that the link will direct you to an entirely different website.  This
is a cinch with the carat symbol. It's most commonly used in regular expressions
to designate the beginning of a string. If we want to target all anchor tags
that have a href which begins with http, we could use a selector similar to the 
snippet shown above.

Notice that we're not searching for with https://; that's unnecessary, and doesn't 
account for the urls that begin http://

Now, what if we wanted to instead style all anchors which link to, say, a photo?
In those cases, let's search for the end of the string.

${E_BOLD}${E_CYAN_FG}14.${E_WHITE_FG} X[href\$=".jpg"]${E_RESET}

${E_WHITE_FG}a[href\$=".jpg"] {
${E_WHITE_FG}    color: red; 
${E_WHITE_FG}}${E_RESET}

Again, we use a regular expressions symbol, an image -- or at least a url that
ends with $, to refer to the end of a string. 
In this case, we're searching for all anchors which link to .jpg
Keep in mind that this certainly won't work for gifs and pngs.

Refer back to number eight; how do we compensate for all of the various image
types: png , jpeg, jpg , gif? Well, we could create multiple selectors, such as:

${E_WHITE_FG}a[href\$=".jpg"], a[href\$=".jpeg"], a[href\$=".png"], a[href\$=".gif"] {
${E_WHITE_FG}    color:
${E_WHITE_FG}    red; 
${E_WHITE_FG}}${E_RESET}

But, that's a pain in the butt, and is inefficient. Another possible solution is
to use custom attributes. What if we added our own filetype data-attribute to each
anchor that links to an image?  

${E_WHITE_FG}<a href="path/to/image.jpg" data-filetype="image"> Image Link </a>${E_RESET}

Then, with that hook in place, we can use a standard attributes selector to
target only those anchors.

${E_WHITE_FG}a[data-filetype="image"] {
${E_WHITE_FG}    color: red; 
${E_WHITE_FG}}${E_RESET}

${E_BOLD}${E_CYAN_FG}16.${E_WHITE_FG} X[foo~="bar"]${E_RESET}

${E_WHITE_FG}a[data-info~="external"] {
${E_WHITE_FG}    color: red; 
${E_WHITE_FG}}${E_RESET}

${E_WHITE_FG}a[data-info~="image"] {
${E_WHITE_FG}    border:
${E_WHITE_FG}    1px solid black; 
${E_WHITE_FG}}${E_RESET}

Here's a special one that'll impress your friends. Not too many people know
about this trick. The tilda ( ~ ) symbol allows us to target an attribute which
has a spaced-separated list of values.  Going along with our custom attribute
from number fifteen, above, we could create a data-info attribute, which can 
receive a space-separated list of anything we need to make note of. 
In this case, we'll make note of external links and links to images -- just for the example.

${E_WHITE_FG}"<a href="path/to/image.jpg" data-info="external image"> Click Me, Fool </a>${E_RESET}

With that markup in place, now we can target any tags that have either of those
values, by using the ~ attributes selector trick.

/* Target data-info attr that contains the value "external" */

${E_WHITE_FG}a[data-info~="external"] {
${E_WHITE_FG}    color: red;
${E_WHITE_FG}}${E_RESET}

/* And which contain the value "image" */

${E_WHITE_FG}a[data-info~="image"] {
${E_WHITE_FG}    border: 1px solid black;
${E_WHITE_FG}}${E_RESET}

Pretty nifty, ay?

${E_BOLD}${E_CYAN_FG}17.${E_WHITE_FG} X:checked${E_RESET}

${E_WHITE_FG}input[type=radio]:checked {
${E_WHITE_FG}    border: 1px solid black;
${E_WHITE_FG}}${E_RESET}

This pseudo class will only target a user interface element that has been
checked - like a radio button, or checkbox. It's as simple as that.

${E_BOLD}${E_CYAN_FG}18.${E_WHITE_FG} X:after The before and after pseudo classes kick butt. 

Every day, it seems, people are finding new and creative ways 
to use them effectively.

They simply generate content around the selected element.  Many were first
introduced to these classes when they encountered the clear-fix hack.

${E_WHITE_FG}.clearfix:after {
${E_WHITE_FG}    content: "";     
${E_WHITE_FG}    display: block;     
${E_WHITE_FG}      clear: both;
${E_WHITE_FG} visibility: hidden;     
${E_WHITE_FG}  font-size: 0;     
${E_WHITE_FG}     height: 0;    
${E_WHITE_FG}}${E_RESET}

${E_WHITE_FG}.clearfix {
${E_WHITE_FG}    *display: inline-block;    
${E_WHITE_FG}     _height: 1%; 
${E_WHITE_FG}}${E_RESET}

This hack uses the :after pseudo class to append a space after the element,
and then clear it. It's an excellent trick to have in your tool bag, 
particularly in the cases when the overflow: hidden; method isn't possible.

For another creative use of this, refer to my quick tip on creating shadows.

According to the CSS3 Selectors specification, you should technically use the
pseudo element syntax of two colons :: . However, to remain compatible, the
user-agent will accept a single colon usage as well. In fact, at this point,
it's smarter to use the single-colon version in your projects.

${E_BOLD}${E_CYAN_FG}19.${E_WHITE_FG} X:hover${E_RESET}

${E_WHITE_FG}div:hover {
${E_WHITE_FG}    background: # E3e3e3;
${E_WHITE_FG}}${E_RESET}

Oh come on. You know this one. The official term for this is user action pseudo class. 
It sounds confusing, but it really isn't. Want to apply specific styling when a user 
hovers over an element? This will get the job done!

Keep in mind that older version of Internet Explorer don't respond 
to anything other than an anchor tag when the :hover pseudo class is applied

You'll most often use this selector when applying, for example, 
a border-bottom to anchor tags, when hovered over.

${E_WHITE_FG}a:hover {  border-bottom: 1px solid black; }${E_RESET}

Pro-tip - border-bottom: 1px solid black; 
looks better than text-decoration: underline.

${E_BOLD}${E_CYAN_FG}20.${E_WHITE_FG} X:not(selector)${E_RESET}

${E_WHITE_FG}The div:not(#container) {
${E_WHITE_FG}    color: blue;
${E_WHITE_FG}}${E_RESET}

negation pseudo class is particularly helpful. Let's say I want to select all divs,
except for the one which has an id of container.
The snippet above will handle that task perfectly.  Or, if I wanted to select
every single element (not advised) except for paragraph tags, we could do: 

${E_WHITE_FG}*:not(p) {
${E_WHITE_FG}      color: green; 
${E_WHITE_FG}}${E_RESET}

${E_BOLD}${E_CYAN_FG}21.${E_WHITE_FG} X::pseudoElement${E_RESET}

${E_WHITE_FG}p::first-line {
${E_WHITE_FG}    font-weight: bold;
${E_WHITE_FG}    font-size: 1.2em;
${E_WHITE_FG}}${E_RESET}

We can use pseudo elements (designated by :: ) to style fragments of an element,
such as the first line, or the first letter.  Keep in mind that these must be 
applied to block level elements in order to take effect.

A pseudo-element is composed of two colons: ::

Target the First Letter of a Paragraph

${E_WHITE_FG}p::first-letter {
${E_WHITE_FG}    float: left;
${E_WHITE_FG}    font-size: 2em;
${E_WHITE_FG}    font-size: 2em;    
${E_WHITE_FG}    font-weight: bold;    
${E_WHITE_FG}    font-family: cursive;
${E_WHITE_FG}    padding-right: 2px;
${E_WHITE_FG}}${E_RESET}

This snippet is an abstraction that will find all paragraphs on the page, and
then sub-target only the first letter of that element.  This is most often used
to create newspaper-like styling for the first-letter of an article.  

Target the First Line of a Paragraph

${E_WHITE_FG}p::first-line {
${E_WHITE_FG}    font-weight: bold;
${E_WHITE_FG}    font-size: 1.2em;
${E_WHITE_FG}}${E_RESET}

Similarly, the ::first-line pseudo element will, as expected, style the first line 
of the element only.

"For compatibility with existing style sheets, user agents must also accept the
previous one-colon notation for pseudo-elements introduced in CSS levels 1 and 2
(namely, :first-line, :first-letter, :before and :after). This compatibility is
not allowed for the new pseudo-elements introduced in this specification." -

${E_BOLD}${E_CYAN_FG}22.${E_WHITE_FG} X:nth-child(n)${E_RESET}

${E_WHITE_FG}li:nth-child(3) {
${E_WHITE_FG}    color: red; 
${E_WHITE_FG}}${E_RESET}

Remember the days when we had no way to target specific elements in a stack? 
The nth-child pseudo class solves that!

Please note that nth-child accepts an integer as a parameter, however, this is not zero-based.

If you wish to target the second list item, use li:nth-child(2) 

We can even use this to select a variable set of children. For example, we could
do  li:nth-child(4n)  to select every fourth list item.


${E_BOLD}${E_CYAN_FG}23.${E_WHITE_FG} X:nth-last-child(n)${E_RESET}

${E_WHITE_FG}li:nth-last-child(2) {
${E_WHITE_FG}    color: red; 
${E_WHITE_FG}}${E_RESET}

What if you had a huge list of items in a ul, and only needed to access, say, the 
third to the last item?  Rather than doing nth-last-child(397), you could instead 
use the nth-child pseudo class.

This technique works almost identically from number sixteen above, however, the
difference is that it begins at the end of the collection, and works its way
back.

${E_BOLD}${E_CYAN_FG}24.${E_WHITE_FG} X:nth-of-type(n)${E_RESET}

${E_WHITE_FG}ul:nth-of-type(3) {
${E_WHITE_FG}    border: 1px solid black;
${E_WHITE_FG}}${E_RESET}

There will be times when, rather than selecting a child, you instead need to select 
according to the type of element.

Imagine mark-up that contains five unordered lists. If you wanted to style only
the third, and didn't have a unique id to hook into, you could use the nth-of-type(n) 
pseudo class. In the snippet above, only the third ul will have a border around it.

${E_BOLD}${E_CYAN_FG}25.${E_WHITE_FG} X:nth-last-of-type(n)${E_RESET}

${E_WHITE_FG}ul:nth-last-of-type(3) {
${E_WHITE_FG}    border: 1px solid black;
${E_WHITE_FG}}${E_RESET}

And yes, to remain consistent, we can also use nth-last-of-type to begin at the end 
of the selectors list, and work our way back to target the desired element.

${E_BOLD}${E_CYAN_FG}26.${E_WHITE_FG} X: first-child${E_RESET}

${E_WHITE_FG}ul li:first-child {
${E_WHITE_FG}    border-top: none; 
${E_WHITE_FG}}${E_RESET}

This structural pseudo class allows us to target only the first child of the element's 
parent. You'll often use this to remove borders from the first and last list items.  

For example, let's say you have a list of rows, and each one has a border-top and a
border-bottom. Well, with that arrangement, the first and last item in that set will 
look a bit odd.  Many designers apply classes of first and last to compensate for this. 
Instead, you can use these pseudo classes.

${E_BOLD}${E_CYAN_FG}27.${E_WHITE_FG} X:last-child${E_RESET}

${E_WHITE_FG}ul > li:last-child {
${E_WHITE_FG}    color: green; 
${E_WHITE_FG}}${E_RESET}

The opposite of first-child, last-child will target the last item of the element's parent.

Example Let's build a simple example to demonstrate one possible use of these
classes. We'll create a styled list item.  

Markup 

${E_WHITE_FG}<ul>
${E_WHITE_FG}    <li> List Item </li>
${E_WHITE_FG}    <li> List Item </li>
${E_WHITE_FG}    <li> List Item </li>
${E_WHITE_FG}</ul>${E_RESET}

Nothing special here; just a simple list.  

CSS

${E_WHITE_FG}ul {
${E_WHITE_FG}    width: 200px;  
${E_WHITE_FG}    background: #292929;  
${E_WHITE_FG}    color: white;  
${E_WHITE_FG}    list-style: none;
${E_WHITE_FG}    padding-left: 0; 
${E_WHITE_FG}}${E_RESET}

${E_WHITE_FG}li {  
${E_WHITE_FG}    padding: 10px;  
${E_WHITE_FG}    border-bottom: 1px solid black;
${E_WHITE_FG}    border-top: 1px solid #3c3c3c; 
${E_WHITE_FG}}${E_RESET}

This styling will set a background, remove the browser-default padding on the ul, 
and apply borders to each li to provide a bit of depth.

To add depth to your lists, apply a border-bottom to each li that is a shade or
two darker than the li's background color. Next, apply a border-top which is a couple
shades lighter.  

The only problem, as shown in the image above, is that a border will be applied
to the very top and bottom of the unordered list - which looks odd. Let's use
the :first-child and :last-child pseudo classes to fix this.

${E_WHITE_FG}li:first-child {
${E_WHITE_FG}    border-top: none; 
${E_WHITE_FG}}${E_RESET}  

${E_WHITE_FG}li:last-child {
${E_WHITE_FG}    border-bottom:
${E_WHITE_FG}    none; 
${E_WHITE_FG}${E_RESET}}

There we go; that fixes it!

${E_BOLD}${E_CYAN_FG}28.${E_WHITE_FG} X:only-child${E_RESET}

${E_WHITE_FG}div p:only-child {
${E_WHITE_FG}    color: red; 
${E_WHITE_FG}}${E_RESET}

Truthfully, you probably won't find yourself using the only-child pseudo class too often.
Nonetheless, it's available, should you need it.

It allows you to target elements which are the only child of its parent. For
example, referencing the snippet above, only the paragraph that is the only
child of the div will be colored, red.

Let's assume the following markup.

${E_WHITE_FG}<div> <p> My paragraph here. </p> </div>${E_RESET}

${E_WHITE_FG}<div>
${E_WHITE_FG}    <p> Two paragraphs total. </p>
${E_WHITE_FG}    <p> Two paragraphs total. </p> 
${E_WHITE_FG}</div>${E_RESET}

In this case, the second div's paragraphs will not be targeted; only the first
div. As soon as you apply more than one child to an element, the only-child
pseudo class ceases to take effect.

${E_BOLD}${E_CYAN_FG}29.${E_WHITE_FG} X:only-of-type${E_RESET}

${E_WHITE_FG}li:only-of-type {
${E_WHITE_FG}    font-weight: bold; 
${E_WHITE_FG}}${E_RESET}

This structural pseudo class can be used in some clever ways. It will target
elements that do not have any siblings within its parent container. As an
example, let's target all ul's, which have only a single list item.

First, ask yourself how you would accomplish this task? You could do ul li, 
but, this would target all list items. The only solution is to use only-of-type.  

${E_WHITE_FG}ul > li:only-of-type {
${E_WHITE_FG}    font-weight: bold;
${E_WHITE_FG}}${E_RESET}

${E_BOLD}${E_CYAN_FG}30.${E_WHITE_FG} X: first-of-type ${E_RESET}

The first-of-type pseudo class allows you to select the first siblings of its type.

A Test To better understand this, let's have a test. Copy the following mark-up
into your code editor:

${E_WHITE_FG}<div> 
${E_WHITE_FG}    <p> My paragraph here. </p>
${E_WHITE_FG}    <ul>
${E_WHITE_FG}        <li> List Item 1 </li>
${E_WHITE_FG}        <li> List Item 2 </li>    
${E_WHITE_FG}    </ul>      
${E_WHITE_FG}    <ul>       
${E_WHITE_FG}        <li> List Item 3 </li>
${E_WHITE_FG}        <li> List Item 4 </li>    
${E_WHITE_FG}    </ul>   
${E_WHITE_FG}</div>${E_RESET}

Now, without reading further, try to figure out how to target only "List Item
2".  When you've figured it out (or given up), read on.

Solution 1 There are a variety of ways to solve this test. We'll review a
handful of them. Let's begin by using first-of-type.

${E_WHITE_FG}ul:first-of-type > li:nth-child(2) {
${E_WHITE_FG}    font-weight: bold; 
${E_WHITE_FG}}${E_RESET}

This snippet essentially says, "find the first unordered list on the page, then
find only the immediate children, which are list items. Next, filter that
down to only the second list item in that set.  

Solution 2 Another option is to use the adjacent selector.

${E_WHITE_FG}p + ul li:last-child {
${E_WHITE_FG}    font-weight: bold;
${E_WHITE_FG}}${E_RESET}

In this scenario, we find the ul that immediately proceeds the p tag, and then
find the very last child of the element.

Solution 3 We can be as obnoxious or as playful as we want with these selectors.

${E_WHITE_FG}ul:first-of-type li:nth-last-child(1) {
${E_WHITE_FG}    font-weight: bold;
${E_WHITE_FG}}${E_RESET}

This time, we grab the first ul on the page, and then find the very first list
item, but starting from the bottom! :)

${E_WHITE_FG}And don't forget HTML-XML-utils${E_RESET}

HTML-XML-utils provides a number of simple utilities for manipulating and
converting HTML and XML files in various ways. The suite consists of the
following tools:

asc2xml      -  convert from UTF-8 to &#nnn; entities 
xml2asc      -  convert from &#nnn; entities to UTF-8 
hxaddid      -  add IDs to selected elements
hxcite       -  replace bibliographic references by hyperlinks 
hxcite-mkbib -  expand references and create bibliography 
hxclean      -  apply heuristics to correct an HTML file 
hxcopy       -  copy an HTML file while preserving relative links 
hxcount      -  count elements and attributes in HTML or XML files
hxextract    -  extract selected elements 
hxincl       -  expand included HTML or XML files 
hxindex      -  create an alphabetically sorted index 
hxmkbib      -  create bibliography from a template 
hxmultitoc   -  create a table of contents for a set of HTML files 
hxname2id    -  move some ID= or NAME= from A elements to their parents 
hxnormalize  -  pretty-print an HTML file 
hxnum        -  number section headings in an HTML file 
hxpipe       -  convert XML to a format easier to parse with Perl or AWK 
hxprintlinks -  number links & add table of URLs at end of an HTML file 
hxprune      -  remove marked elements from an HTML file 
hxselect     -  extract elements that match a (CSS) selector 
hxref        -  generate cross-references 
hxtoc        -  insert a table of contents in an HTML file 
hxuncdata    -  replace CDATA sections by character entities 
hxunent      -  replace HTML predefined character entities to UTF-8 
hxunpipe     -  convert output of pipe back to XML format 
hxunxmlns    -  replace "global names" by XML Namespace prefixes 
hxwls        -  list links in an HTML file 
hxxmlns      -  replace XML Namespace prefixes by "global names"
tip_pup_EOF
) | mypager
