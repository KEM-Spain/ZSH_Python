(
echo ${E_BOLD}${E_WHITE_FG}${(C)${0/tip_/}:t:r} Tips${E_RESET}
cat << tip_regex_EOF_1

${E_WHITE_FG}Collected POSIX/GNU:${E_RESET}

# file: 'test.txt'
foobar bash 1
bash
foobar happy
foobar

GNU grep has the -P option for perl-style regexes, and the -o option to ${E_WHITE_FG}print only${E_RESET}
${E_WHITE_FG}what matches the pattern${E_RESET}. These can be combined using look-around assertions 
(described under Extended Patterns in the perlre manpage) to remove part of the grep 
pattern from what is determined to have matched for the purposes of -o.

#: grep -oP 'foobar \K\w+' test.txt
bash
happy

The \K is the short-form (and more efficient form) of (?<=pattern) which you use as a 
zero-width look-behind assertion before the text you want to output. (?=pattern) can be 
used as a zero-width look-ahead assertion after the text you want to output.

For instance, if you wanted to match the word between foo and bar, you could use:

#: grep -oP 'foo \K\w+(?= bar)' test.txt

or (for symmetry)

#: grep -oP '(?<=foo )\w+(?= bar)' test.txt


${E_WHITE_FG}Regular expressions in Perl${E_RESET}

This document presents a tabular summary of the regular expression
(regexp) syntax in Perl, then illustrates it with a collection of
annotated examples.

${E_WHITE_FG}Metacharacters${E_RESET}

${E_WHITE_FG}Char    Meaning${E_RESET}

^       beginning of string
$       end of string
.       any character except newline
*       match 0 or more times
+       match 1 or more times
?       match 0 or 1 times; or: shortest match
|       alternative
( )     grouping; storing
[ ]     set of characters
{ }     repetition modifier
\       quote or special

To present a metacharacter as a data character standing for itself,
precede it with \ (e.g. \. matches only the period character '.').

In the table above, the characters themselves, in the first column,
are links to descriptions of characters in the ISO Latin 1 character
set - a description with usage notes. Note that the physical
appearance (glyph) of a character may vary from one device or program
or font to another.

${E_WHITE_FG}Repetition${E_RESET}

a*          zero or more a's
a+          one or more a's
a?          zero or one a's (i.e., optional a)
a{m}        exactly m a's
a{m,}       at least m a's
a{m,n}      at least m but at most n a's
a?          shortest match is taken (non greedy)

Read the notation as an occurrences of strings, each of which matches
the pattern a. Read repetition as any of the repetition expressions
listed above it. Shortest match means that the shortest string matching
the pattern is taken. The default is greedy matching, which finds the
longest match. The repetition? construct was introduced in Perl version 5.

${E_WHITE_FG}Special notations with \ (backslash)${E_RESET}

${E_WHITE_FG}Single characters${E_RESET}

\t     tab
\n     newline
\r     return (CR)
\xhh   character with hex code hh

${E_WHITE_FG}Zero-width assertions ${E_RESET}

\b     word boundary
\B     not a word boundary
\w     matches any single character classified as a word character (alphanumeric or _)
\W     matches any non-word character
\s     matches any whitespace character (space, tab, newline)
\S     matches any non-whitespace character
\d     matches any digit character, equiv. to [0-9]
\D     matches any non-digit character

${E_WHITE_FG}Character sets: specialities inside [...]${E_RESET}

Different meanings apply inside a character set (character class)
denoted by [...] so that, instead of the normal rules given here, the
following apply:

[characters]   matches any of the characters in the sequence
[x-y]          matches any of the characters from x to y (inclusively) in the ASCII code
[\-]           matches the hyphen character -
[\n]           matches the newline; other single character denotations with \ apply normally, too
[^something]   matches any character except those that [something] denotes; that is, 
               immediately after the leading [, the circumflex ^ means not applied to all of the rest

${E_WHITE_FG}Examples${E_RESET}
--------

${E_WHITE_FG}Expression  Matches${E_RESET}

abc         abc (that exact character sequence, but anywhere in the string)
^abc        abc at the beginning of the string
abc$        abc at the end of the string
a|b         either of a and b
^abc|abc$   the string abc at the beginning or at the end of the string
ab{2,4}c    an a followed by two, three or four bs followed by a c
ab{2,}c     an a followed by at least two bs followed by a c
ab*c        an a followed by any number (zero or more) of bs followed by a c
ab+c        an a followed by one or more bs followed by a c
ab?c        an a followed by an optional b followed by a c; that is, either abc or ac
a.c         an a followed by any single character (not newline) followed by a c
a\.c        a.c exactly
[abc]       any one of a, b and c
[Aa]bc      either of Abc and abc
[abc]+      any (nonempty) string of as, bs and cs (such as a, abba, acbabcacaa)
[^abc]+     any (nonempty) string which does not contain any of a, b and c (such as defg)
\d\d        any two decimal digits, such as 42; same as \d{2}
\w+         a word: a nonempty sequence of alphanumeric characters and low lines (underscores), such as foo and 12bar8 and foo_1
100\s*mk    the strings 100 and mk optionally separated by any amount of white space (spaces, tabs, newlines)
abc\b       abc when followed by a word boundary (e.g. in abc! but not in abcd)
perl\B      perl when not followed by a word boundary (e.g. in perlert but not in perl stuff)

${E_WHITE_FG}LOOK-AHEAD / LOOK-BEHIND${E_RESET}

(?=foo)     look-ahead: Asserts that what immediately ${E_ITALIC}${E_WHITE_FG}follows the current position${E_RESET} in the string is ${E_WHITE_FG}foo${E_RESET}
(?<=foo)    look-behind: Asserts that what immediately ${E_ITALIC}${E_WHITE_FG}precedes the current position${E_RESET} in the string is ${E_WHITE_FG}foo${E_RESET}
(?!foo)     Negative look-ahead: Asserts that what immediately${E_ITALIC}${E_WHITE_FG}follows the current position${E_RESET} in the string is ${E_BOLD}${E_ITALIC}${E_RED_FG}not${E_RESET} ${E_WHITE_FG}foo${E_RESET}
(?<!foo)    Negative look-behind: Asserts that what immediately${E_ITALIC}${E_WHITE_FG}precedes the current position${E_RESET} in the string is ${E_BOLD}${E_ITALIC}${E_RED_FG}not${E_RESET} ${E_WHITE_FG}foo${E_RESET}

${E_WHITE_FG}COMMON TASKS${E_RESET}

${E_WHITE_FG}Finding the last occurrence${E_RESET}

There are actually a number of ways to get the last occurrence that don't involve look-around, but if you think of "the last foo" 
as "foo that isn't followed by a string containing foo", you can express that notion like this: ${E_WHITE_FG}/foo(?!.*foo)/${E_RESET}

The regular expression engine will do its best to match ${E_WHITE_FG}.*foo${E_RESET}, starting at the end of the string "foo". If it is 
able to match that, then the negative look-ahead will fail, which will force the engine to progress through the string to try the
next foo.  

${E_WHITE_FG}Substituting before, after, or between characters${E_RESET}

Many substitutions match a chunk of text and then replace part or all of it. You can often avoid that by using look-arounds. 
For example, if you want to put a comma after every foo: ${E_WHITE_FG}s/(?<=foo)/,/g;${E_RESET} (without lookbehind: s/foo/foo,/g or s/(foo)/${1},/g)
or to put the hyphen in look-ahead: ${E_WHITE_FG}s/(?<=look)(?=ahead)/-/g;${E_RESET}

This kind of thing is likely to be the bulk of what you use look-arounds for. It is ${E_BOLD}important${E_RESET} to remember that look-behind expressions 
cannot be of variable length. That means you cannot use quantifiers (?, *, +, or {1,5}) or alternation of different-length items inside them.

${E_WHITE_FG}Matching a pattern that doesn't include another pattern${E_RESET}

You might want to capture everything between foo and bar that doesn't include baz. The technique is to have the regex engine 
look-ahead at every character to ensure that it isn't the beginning of the undesired pattern:

${E_WHITE_FG}/foo((?:(?!baz).)*)bar/x;${E_RESET}

/foo       # ${E_WHITE_FG}Match starting at foo${E_RESET}
 (         # ${E_WHITE_FG}Capture${E_RESET}
 (?:       # ${E_WHITE_FG}Complex expression:${E_RESET}
   (?!baz) # ${E_WHITE_FG}make sure we're not at the beginning of baz${E_RESET}
   .       # ${E_WHITE_FG}accept any character${E_RESET}
 )*        # ${E_WHITE_FG}any number of times${E_RESET}
 )         # ${E_WHITE_FG}End capture${E_RESET}
 bar       # ${E_WHITE_FG}and ending at bar${E_RESET}
/x;

${E_WHITE_FG}Nesting${E_RESET}

You can put look-arounds inside of other look-arounds. This has been known to induce a flight response in certain readers 
(me, for example, the first time I saw it), but it's really not such a hard concept. A look-around sub-expression inherits a 
starting position from the enclosing expression, and can walk all around relative to that position without affecting the position 
of the enclosing expression. They all have independent (though initially inherited) bookkeeping for where they are in the string.

The concept is pretty simple, but the notation becomes hairy very quickly, so commented regular expressions are recommended. 
Let's look at the real example of Regex to add space after punctuation sign. The poster wants to put a space after any comma 
(punctuation, actually, but for simplicity, let's say comma) that is not nestled between two digits. Building up the s/// expression:

${E_WHITE_FG}s/(?<=,(?!(?<=\d,)(?=\d)))/ /gx;${E_RESET}

s/(?<=,        # ${E_WHITE_FG}after a comma,${E_RESET}
    (?!        # ${E_WHITE_FG}but not matching${E_RESET}
      (?<=\d,) # ${E_WHITE_FG}digit-comma before, AND${E_RESET}
      (?=\d)   # ${E_WHITE_FG}digit afterward${E_RESET}
    )
  )/ /gx;      # ${E_WHITE_FG}substitute a space${E_RESET}

Note: that multiple lookarounds can be used to enforce multiple conditions at the same place, like an AND condition that complements 
the alternation (vertical bar)'s OR. In fact, you can use Boolean algebra ( NOT (a AND b) === (NOT a OR NOT b) ) to convert the 
expression to use OR:

${E_WHITE_FG}s/(?<=,(?:(?<!\d,)|(?!\d)))/ /gx;${E_RESET}

s/(?<=,        # ${E_WHITE_FG}after a comma, but either${E_RESET}
    (?:
      (?<!\d,) # ${E_WHITE_FG}not matching digit-comma before${E_RESET}
      |        # ${E_WHITE_FG}OR${E_RESET}
      (?!\d)   # ${E_WHITE_FG}not matching digit afterward${E_RESET}
    )
  )/ /gx;      # ${E_WHITE_FG}substitute a space${E_RESET}

${E_WHITE_FG}Capturing${E_RESET}

It is sometimes useful to use capturing parentheses within a look-around. You might think that you wouldn't be able to do that, 
since you're just browsing, but you can. 

But ${E_BOLD}remember${E_RESET}: ${E_ITALIC}the capturing parentheses must be within the look-around expression${E_RESET}; from the enclosing expression's point of view, 
no actual matching was done by the zero-width look-around.

This is most useful for finding overlapping matches in a global pattern match. You can capture substrings without consuming them, 
so they are available for further matching later. Probably the simplest example is to get all right-substrings of a string:

${E_WHITE_FG}print "${1}\n" while /(?=(.*))/g;${E_RESET}

Note: that the pattern technically consumes no characters at all, but Perl knows to advance a character on an empty match, 
to prevent infinite looping.

${E_WHITE_FG}Simple examples of regex use in Perl statements${E_RESET}

These examples use very simple regexps only. The intent is just to show
contexts where regexps might be used, as well as the effect of some
flags to matching and replacements. Note in particular that matching
is by default case-sensitive (Abc does not match abc unless specified
otherwise).

${E_WHITE_FG}s/foo/bar/;${E_RESET}
replaces the first occurrence of the exact character sequence foo in the
current string (in special variable ${_}) by the character sequence bar;
for example, foolish bigfoot would become barlish bigfoot

${E_WHITE_FG}s/foo/bar/g;${E_RESET}
replaces any occurrence of the exact character sequence foo in the current
string by the character sequence bar; for example, foolish bigfoot would
become barlish bigbart

${E_WHITE_FG}s/foo/bar/gi;${E_RESET}
replaces any occurrence of foo case-insensitively in the current string
by the character sequence bar (e.g. Foo and FOO get replaced by bar too)

${E_WHITE_FG}if(m/foo/)...${E_RESET}
tests whether the current string contains the string foo


${E_WHITE_FG}If-Then-Else Conditionals in Regular Expressions${E_RESET}

A special construct ${E_WHITE_FG}(?ifthen|else)${E_RESET} allows you to create conditional regular
expressions. If the if part evaluates to true, then the regex engine will
attempt to match the then part. Otherwise, the else part is attempted instead.
The syntax consists of a pair of parentheses. The opening bracket must be
followed by a question mark, immediately followed by the if part, immediately
followed by the then part. This part can be followed by a vertical bar and the
else part. You may omit the else part, and the vertical bar with it.

For the if part, you can use the look-ahead and look-behind constructs. Using
positive look-ahead, the syntax becomes ${E_WHITE_FG}(?(?=regex)then|else)${E_RESET}. Because the
look-ahead has its own parentheses, the if and then parts are clearly separated.

Remember that the look-around constructs do not consume any characters. If you
use a look-ahead as the if part, then the regex engine will attempt to match the
then or else part (depending on the outcome of the look-ahead) at the same
position where the if was attempted.

Alternatively, you can check in the if part whether a capturing group has taken
part in the match thus far. Place the number of the capturing group inside
parentheses, and use that as the if part. Note that although the syntax for a
conditional check on a backreference is the same as a number inside a capturing
group, no capturing group is created. The number and the parentheses are part
of the if-then-else syntax started with (?.

For the then and else, you can use any regular expression. If you want to use
alternation, you will have to group the then or else together using parentheses
, like in ${E_WHITE_FG}(?(?=condition)(then1|then2|then3)|(else1|else2|else3))${E_RESET}. Otherwise,
there is no need to use parentheses around the then and else parts.

${E_WHITE_FG}Looking Inside The Regex Engine${E_RESET}

The regex ${E_WHITE_FG}(a)?b(?(1)c|d)${E_RESET} consists of the optional capturing group ${E_WHITE_FG}(a)?${E_RESET}, the
literal ${E_WHITE_FG}b${E_RESET}, and the conditional ${E_WHITE_FG}(?(1)c|d)${E_RESET} that tests the capturing group. This
regex matches ${E_WHITE_FG}bd${E_RESET} and ${E_WHITE_FG}abc${E_RESET}. It does not match ${E_WHITE_FG}bc${E_RESET}, but does match ${E_WHITE_FG}bd${E_RESET} in ${E_WHITE_FG}abd${E_RESET}. Let's
see how this regular expression works on each of these four subject strings.

When applied to ${E_WHITE_FG}bd${E_RESET}, ${E_WHITE_FG}a${E_RESET} fails to match. Since the capturing group containing ${E_WHITE_FG}a${E_RESET} is
optional, the engine continues with ${E_WHITE_FG}b${E_RESET} at the start of the subject string. Since
the whole group was optional, the group did not take part in the match. Any
subsequent backreference to it like ${E_WHITE_FG}\1${E_RESET} will fail. Note that ${E_WHITE_FG}(a)?${E_RESET} is very
different from ${E_WHITE_FG}(a?)${E_RESET}. In the former regex, the capturing group does not take
part in the match if ${E_WHITE_FG}a${E_RESET} fails, and backreferences to the group will fail. In the
latter group, the capturing group always takes part in the match, capturing
either ${E_WHITE_FG}a${E_RESET} or nothing. Backreferences to a capturing group that took part in the
match and captured nothing always succeed. Conditionals evaluating such groups
execute the "then" part. In short: if you want to use a reference to a group in
a conditional, use ${E_WHITE_FG}(a)?${E_RESET} instead of ${E_WHITE_FG}(a?)${E_RESET}.

Continuing with our regex, ${E_WHITE_FG}b${E_RESET} matches ${E_WHITE_FG}b${E_RESET}. The regex engine now evaluates the
conditional. The first capturing group did not take part in the match at all,
so the "else" part or ${E_WHITE_FG}d${E_RESET} is attempted. ${E_WHITE_FG}d${E_RESET} matches ${E_WHITE_FG}d${E_RESET} and an overall match is
found.

Moving on to our second subject string ${E_WHITE_FG}abc${E_RESET}, ${E_WHITE_FG}a${E_RESET} matches ${E_WHITE_FG}a${E_RESET}, which is captured by
the capturing group. Subsequently, ${E_WHITE_FG}b${E_RESET} matches ${E_WHITE_FG}b${E_RESET}. The regex engine again
evaluates the conditional. The capturing group took part in the match, so the
"then" part or ${E_WHITE_FG}c${E_RESET} is attempted. ${E_WHITE_FG}c${E_RESET} matches ${E_WHITE_FG}c${E_RESET} and an overall match is found.

Our third subject ${E_WHITE_FG}bc${E_RESET} does not start with ${E_WHITE_FG}a${E_RESET}, so the capturing group does not
take part in the match attempt, like we saw with the first subject string. ${E_WHITE_FG}b${E_RESET}
still matches ${E_WHITE_FG}b${E_RESET}, and the engine moves on to the conditional. The first
capturing group did not take part in the match at all, so the "else" part or ${E_WHITE_FG}d${E_RESET}
is attempted. ${E_WHITE_FG}d${E_RESET} does not match ${E_WHITE_FG}c${E_RESET} and the match attempt at the start of the
string fails. The engine does try again starting at the second character in the
string, but fails since ${E_WHITE_FG}b${E_RESET} does not match ${E_WHITE_FG}c${E_RESET}.

The fourth subject ${E_WHITE_FG}abd${E_RESET} is the most interesting one. Like in the second string,
the capturing group grabs the ${E_WHITE_FG}a${E_RESET} and the ${E_WHITE_FG}b${E_RESET} matches. The capturing group took
part in the match, so the "then" part or ${E_WHITE_FG}c${E_RESET} is attempted. ${E_WHITE_FG}c${E_RESET} fails to match ${E_WHITE_FG}d${E_RESET},
and the match attempt fails. Note that the "else" part is not attempted at this
point. The capturing group took part in the match, so only the "then" part is
used. However, the regex engine isn't done yet. It restarts the regular
expression from the beginning, moving ahead one character in the subject
string.

Starting at the second character in the string, ${E_WHITE_FG}a${E_RESET} fails to match ${E_WHITE_FG}b${E_RESET}. The
capturing group does not take part in the second match attempt which started at
the second character in the string. The regex engine moves beyond the optional
group, and attempts ${E_WHITE_FG}b${E_RESET}, which matches. The regex engine now arrives at the
conditional in the regex, and at the third character in the subject string. The
first capturing group did not take part in the current match attempt, so the
"else" part or ${E_WHITE_FG}d${E_RESET} is attempted. ${E_WHITE_FG}d${E_RESET} matches ${E_WHITE_FG}d${E_RESET} and an overall match ${E_WHITE_FG}bd${E_RESET} is found.

If you want to avoid this last match result, you need to use anchors. 
${E_WHITE_FG}^(a)?b(?(1)c|d)$ ${E_RESET}does not find any matches in the last subject string. The caret fails
to match before the second and third characters in the string.

${E_WHITE_FG}Named and Relative Conditionals${E_RESET}

Conditionals are supported by the JGsoft engine, Perl, PCRE, Python, and the
.NET framework. Ruby supports them starting with version 2.0. Languages such as
Delphi, PHP, and R that have regex features based on PCRE also support
conditionals.

All these flavors also support named capturing groups. You can use the name of
a capturing group instead of its number as the if test. The syntax is slightly
inconsistent between regex flavors. In Python, .NET, and the JGsoft
applications, you simply specify the name of the group between parentheses. 
${E_WHITE_FG}(? <test>a)?b(?(test)c|d)${E_RESET} is the regex from the previous section using named
capture. In Perl or Ruby, you have to put angle brackets or quotes around the
name of the group, and put that between the conditional's 
parentheses: ${E_WHITE_FG}(?<test>a)?b(?(<test>)c|d)${E_RESET} or 
${E_WHITE_FG}(?'test'a)?b(?('test')c|d)${E_RESET}. PCRE supports all three
variants.

PCRE 7.2 and later and JGsoft V2 also support relative conditionals. The syntax
is the same as that of a conditional that references a numbered capturing group
with an added plus or minus sign before the group number. The conditional then
counts the opening parentheses to the left (minus) or to the right (plus)
starting at the ${E_WHITE_FG}(?(${E_RESET} that opens the conditional. ${E_WHITE_FG}(a)?b(?(-1)c|d)${E_RESET} is another way
of writing the above regex. The benefit is that this regex won't break if you
add capturing groups at the start or the end of the regex.

Python supports conditionals using a numbered or named capturing group. Python
does not support conditionals using look-around, even though Python does support
look-around outside conditionals. Instead of a conditional like ${E_WHITE_FG}(?(?=regex)then|
else)${E_RESET}, you can alternate two opposite look-arounds: ${E_WHITE_FG}(?=regex)then|(?!regex)else${E_RESET}.

${E_WHITE_FG}Conditionals Referencing Non-Existent Capturing Groups${E_RESET}

Boost and Ruby treat a conditional that references a non-existent capturing
group as an error. The latest versions of all other flavors discussed in this
tutorial don't. They simply let such conditionals always attempt the "else"
part. A few flavors changed their minds, though. Python 3.4 and prior and PCRE
7.6 and prior (and thus PHP 5.2.5 and prior) used to treat them as errors.

${E_WHITE_FG}Example: Extract Email Headers${E_RESET}

The regex ${E_WHITE_FG}^((From|To)|Subject): ((?(2)\w+@\w+\.[a-z]+|.+))${E_RESET} extracts the From,
To, and Subject headers from an email message. The name of the header is
captured into the first backreference. If the header is the ${E_WHITE_FG}From${E_RESET} or ${E_WHITE_FG}To${E_RESET} header,
it is captured into the second backreference as well.

The second part of the pattern is the if-then-else conditional 
${E_WHITE_FG}(?(2)\w+@\w+\.[a-z]+|.+))${E_RESET}. The if part checks whether the second capturing group took part in
the match thus far. It will have taken part if the header is the ${E_WHITE_FG}From${E_RESET} or ${E_WHITE_FG}To${E_RESET}
header. In that case, the then part of the conditional ${E_WHITE_FG}\w+@\w+\.[a-z]+${E_RESET} tries to
match an email address. To keep the example simple, we use an overly simple
regex to match the email address, and we don't try to match the display name
that is usually also part of the ${E_WHITE_FG}From${E_RESET} or ${E_WHITE_FG}To${E_RESET} header.

If the second capturing group did not participate in the match this far, the
else part ${E_WHITE_FG}.+${E_RESET} is attempted instead. This simply matches the remainder of the
line, allowing for any test subject.

Finally, we place an extra pair of parentheses around the conditional. This
captures the contents of the email header matched by the conditional into the
third backreference. The conditional itself does not capture anything. When
implementing this regular expression, the first capturing group will store the
name of the header ${E_WHITE_FG}("From", "To", or "Subject")${E_RESET}, and the third capturing group
will store the value of the header.

You could try to match even more headers by putting another conditional into
the "else" part. 
E.g. ${E_WHITE_FG}^((From|To)|(Date)|Subject): ((?(2)\w+@\w+\.[a-z]+|(?(3) mm/dd/yyyy|.+)))${E_RESET} 
would match a "From", "To", "Date" or "Subject", and use the
regex ${E_WHITE_FG}mm/dd/yyyy${E_RESET} to check whether the date is valid. Obviously, the date
validation regex is just a dummy to keep the example simple. The header is
captured in the first group, and its validated contents in the fourth group.

As you can see, regular expressions using conditionals quickly become unwieldy.
I recommend that you only use them if one regular expression is all your tool
allows you to use. When programming, you're far better of using the regex 
${E_WHITE_FG}^(From|To|Date|Subject): (.+)${E_RESET} to capture one header with its unvalidated
contents. In your source code, check the name of the header returned in the
first capturing group, and then use a second regular expression to validate the
contents of the header returned in the second capturing group of the first
regex. Though you'll have to write a few lines of extra code, this code will be
much easier to understand and maintain. If you precompile all the regular
expressions, using multiple regular expressions will be just as fast, if not
faster, than the one big regex stuffed with conditionals.

${E_WHITE_FG}In Depth - look-ahead - look-behind${E_RESET}

look-ahead Example: Simple Password Validation
Let's get our feet wet right away with an expression that validates a password. The technique shown here will be useful for all 
kinds of other data you might want to validate (such as email addresses or phone numbers). 
Our password must meet four conditions:

1. The password must have between six and ten word characters \w
2. It must include at least one lowercase character [a-z]
3. It must include at least three uppercase characters [A-Z]
4. It must include at least one digit \d

We'll assume we're working in a regex flavor where \d only matches ASCII digits 0 through 9, unlike .NET and Python where that 
token can match any Unicode digit.

With look-arounds, ${E_WHITE_FG}your feet stay planted on the string. You're just looking, not moving${E_RESET}! Our initial strategy (which we'll later 
tweak) will be to stand at the beginning of the string and look ahead four times—once for each condition. We'll look to check we 
have the right number of characters, then we'll look for a lowercase letter, and so on. If all the look-aheads are successful, we'll 
know the string is a valid password… And we'll simply gobble it all up with a plain .* 

${E_WHITE_FG}Condition 1${E_RESET}

A string that is made of six-to-ten word characters can be written like this: ${E_WHITE_FG}\A\w{6,10}\z${E_RESET}
The ${E_WHITE_FG}\A${E_RESET} anchor asserts that the current position is the beginning of the string. After matching the six to ten word characters, the 
${E_WHITE_FG}\z${E_RESET} anchor asserts that the current position is the end of the string. 

Within a look-ahead, this pattern becomes ${E_WHITE_FG}(?=\A\w{6,10}\z)${E_RESET}. This look-ahead asserts: at the current position in the string, what 
follows is the beginning of the string, six to ten word characters, and the very end of the string. 

We want to make this assertion at the very beginning of the string. Therefore, to continue building our pattern, we want to anchor 
the look-ahead with an ${E_WHITE_FG}\A${E_RESET}. There is no need to duplicate the ${E_WHITE_FG}\A${E_RESET}, so we can take it out of the look-ahead. Our pattern becomes:
${E_WHITE_FG}\A(?=\w{6,10}\z)${E_RESET}

So far, we have an expression that validates that a string is entirely composed of six to ten word characters. Note that we haven't 
matched any of these characters yet: we have only looked ahead. The current position after the look-ahead is still the beginning of 
the string. To check the other conditions, we just add look-aheads.

${E_WHITE_FG}Condition 2${E_RESET}

For our second condition, we need to check that the password contains one lowercase letter. To find one lowercase letter, the 
simplest idea is to use ${E_WHITE_FG}.*[a-z]${E_RESET}. That works, but the ${E_WHITE_FG}dot-star${E_RESET} first shoots down to the end of the string, so we will always need to 
backtrack. Just for the sport, can we think of something more efficient? You might think of making the star quantifier reluctant by 
adding a ${E_WHITE_FG}?${E_RESET}, giving us ${E_WHITE_FG}.*?[a-z]${E_RESET}, but that too requires backtracking as a lazy quantifier requires backtracking at each step.

For this type of situation, I recommend you use something like [^a-z]*[a-z] (or even better, depending on your engine, the atomic 
${E_WHITE_FG}(?>[^a-z]*)[a-z]${E_RESET} or possessive version ${E_WHITE_FG}[^a-z]*+[a-z]${E_RESET} — but we'll discuss that in the footnotes). The negated character class [^a-z] 
is the counterclass of the lowercase letter [a-z] we are looking for: it matches one character that is not a lowercase letter, and 
the ${E_WHITE_FG}*${E_RESET} quantifier makes us match zero or more such characters. The pattern  ${E_WHITE_FG}[^a-z]*[a-z]${E_RESET} is a good example of the principle of 
contrast recommended by the regex style guide. 

Let's use this pattern inside a look-ahead: ${E_WHITE_FG}(?=[^a-z]*[a-z])${E_RESET}
The look-ahead asserts: at this position in the string (i.e., the beginning of the string), we can match zero or more characters 
that are not lowercase letters, then we can match one lowercase letter: ${E_WHITE_FG}[a-z${E_RESET}
Our pattern becomes: ${E_WHITE_FG}\A(?=\w{6,10}\z)(?=[^a-z]*[a-z])${E_RESET}

At this stage, we have asserted that we are at the beginning of the string, and we have looked ahead twice. We still haven't 
matched any characters. Note that on a logical level it doesn't matter which condition we check first. If we swapped the order of 
the look-aheads, the result would be the same. 

We have two more conditions to satisfy: two more look-aheads. 

${E_WHITE_FG}Condition 3${E_RESET}

For our third condition, we need to check that the password contains at least three uppercase letters. The logic is similar to 
condition 2: we look for an optional number of non-uppercase letters, then one uppercase letter… But we need to repeat that three 
times, for which we'll use the quantifier ${E_WHITE_FG}{3}${E_RESET}. 
We'll use this look-ahead: ${E_WHITE_FG}(?=(?:[^A-Z]*[A-Z]){3})${E_RESET} 

The look-ahead asserts: at this position in the string (i.e., the beginning of the string), we can do the following three times: 
match zero or more characters that are not uppercase letters (the job of the negated character class ${E_WHITE_FG}[^A-Z]${E_RESET} with the quantifier ${E_WHITE_FG}*)${E_RESET}, 
then match one uppercase letter: ${E_WHITE_FG}[A-Z]${E_RESET}
Our pattern becomes: 
${E_WHITE_FG}\A(?=\w{6,10}\z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})${E_RESET}

At this stage, we have asserted that we are at the beginning of the string, and we have looked ahead three times. We still haven't 
matched any characters. 

${E_WHITE_FG}Condition 4${E_RESET}

To check that the string contains at least one digit, we use this look-ahead: ${E_WHITE_FG}(?=\D*\d)${E_RESET}. Opposing ${E_WHITE_FG}\d${E_RESET} to its counterclass ${E_WHITE_FG}\D${E_RESET} makes 
good use of the regex principle of contrast. 

The look-ahead asserts: at this position in the string (i.e., the beginning of the string), we can match zero or more characters 
that are not digits (the job of the "not-a-digit" character class ${E_WHITE_FG}\D${E_RESET} and the * quantifier), then we can match one digit: ${E_WHITE_FG}\d${E_RESET}
Our pattern becomes: ${E_WHITE_FG}\A(?=\w{6,10}\z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})(?=\D*\d)${E_RESET}

At this stage, we have asserted that we are at the beginning of the string, and we have looked ahead four times to check our four 
conditions. We still haven't matched any characters, but we have validated our string: we know that it is a valid password. 

If all we wanted was to validate the password, we could stop right there. But if for any reason we also need to match and return 
the entire string—perhaps because we ran the regex on the output of a function and the password's characters haven't yet been 
assigned to a variable — we can easily do so now. 

${E_WHITE_FG}Matching the Validated String${E_RESET}

After checking that the string conforms to all four conditions, we are still standing at the beginning of the string. The five 
assertions we have made (the anchor ${E_WHITE_FG}\A${E_RESET} and the four look-aheads) have not changed our position. At this stage, we can use a simple 
.* to gobble up the string: we know that whatever characters are matched by the ${E_WHITE_FG}dot-star${E_RESET}, the string is a valid password. The 
pattern becomes: ${E_WHITE_FG}\A(?=\w{6,10}\z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})(?=\D*\d).*${E_RESET}

${E_WHITE_FG}Fine-Tuning: Removing One Condition${E_RESET}

For ${E_WHITE_FG}n${E_RESET} conditions,
use ${E_WHITE_FG}n-1${E_RESET} look-aheads If you examine our look-aheads, you may notice that the pattern ${E_WHITE_FG}\w{6,10}\z${E_RESET} inside the first one examines all the 
characters in the string. Therefore, we could have used this pattern to match the whole string instead of the ${E_WHITE_FG}dot-star .*${E_RESET} 

This allows us to remove one look-ahead and to simplify the pattern to this:

${E_WHITE_FG}\A(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})(?=\D*\d)\w{6,10}\z${E_RESET}

The pattern ${E_WHITE_FG}\w{6,10}\z${E_RESET} now serves the double purpose of matching the whole string and of ensuring that the string is entirely 
composed of six to ten word characters. 

Generalizing this result, if you must check for ${E_WHITE_FG}n${E_RESET} conditions, your pattern only needs to include ${E_WHITE_FG}n-1${E_RESET} look-aheads at the most. Often, 
you are even able to combine several conditions into a single look-ahead. 

You may object that we were able to use \w{6,10}\z because it happened to match the whole string. Indeed that was the case. But we 
could also have converted any of the other three look-aheads to match the entire string. For instance, taking the look-ahead 
${E_WHITE_FG}(?=\D*\d)${E_RESET} which checks for the presence of one digit, we can add a simple ${E_WHITE_FG}.*\z${E_RESET} to get us to the end of the string.

The pattern would have become:
${E_WHITE_FG}\A(?=\w{6,10}\z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})\D*\d.*\z${E_RESET}

By the way, you may wonder why I bother using the ${E_WHITE_FG}\z${E_RESET} after the ${E_WHITE_FG}.*${E_RESET}: shouldn't it get me to the end of the string? In general, not 
so: unless we're in DOTALL mode, the dot doesn't match line breaks. Therefore, the ${E_WHITE_FG}.*${E_RESET} only gets you to the end of the first line. 
After this, the string may have line breaks and many more line. A ${E_WHITE_FG}\z${E_RESET} anchor ensures that after the .* we have reached not only the 
end of the line, but also the end of the string. 

In this particular pattern, the first look-around ${E_WHITE_FG}(?=\w{6,10}\z)${E_RESET} already ensures that there cannot be any line breaks in the string, 
so the final ${E_WHITE_FG}\z${E_RESET} is not strictly necessary. 

${E_WHITE_FG}The Order of look-aheads Doesn't Matter… Almost${E_RESET}

In our password validation pattern, since the three look-aheads don't change our position in the string, we can rearrange them in 
any order without affecting the overall logic. 

While the order of look-aheads doesn't matter on a logical level, keep in mind that it may matter for matching speed. If one 
look-ahead is more likely to fail than the other two, it makes little sense to place it in third position and expend a lot of energy 
checking the first two conditions. Make it first, so that if we're going to fail, we fail early—an application of the design to 
fail principle from the regex style guide. 

In fact, this is what we do by placing the anchor ${E_WHITE_FG}\A${E_RESET} in first position. Since it is an assertion that doesn't consume characters, 
it too could swap positions with any of the look-aheads. We'll see why this is a bad idea, but first… 

In passing, consider that ${E_WHITE_FG}\A${E_RESET} can be written with look-arounds: in DOTALL mode, where the dot matches any character including line 
breaks, the negative look-behind ${E_WHITE_FG}(?<!.)${E_RESET} asserts that what precedes the current position is not any character—therefore the 
position must be the beginning of the string. Without DOTALL mode, the negative look-behind ${E_WHITE_FG}(?<![\D\d])${E_RESET} asserts the same, since 
${E_WHITE_FG}[\D\d]${E_RESET} matches one character that is either a digit or a non-digit—in other words, any character. 

Now imagine we set ${E_WHITE_FG}\A${E_RESET} in fourth position, after the three look-aheads. The resulting match would be the same, but it could take a 
lot more time. For instance, suppose the third look-ahead (whose job it is to assert that the string contains at least one digit) 
fails. After failing to find a match at the first position in the string, the engine advances to the second position and tries the 
look-aheads again, one after the other. Once more, the third look-ahead is bound to fail to find a digit. After each failure, the 
engine will start a new match attempt starting at the next position in the string. Even when the two first look-aheads succeed (and 
they may fail, as the uppercase or lowercase letter they check for may have been the lone one in the string, and at a position 
already passed), the third look-ahead will always fail to find a digit. Therefore the anchor ${E_WHITE_FG}\A${E_RESET} is never even attempted: the pattern 
fails before the engine reaches that token. 

In contrast, when ${E_WHITE_FG}\A${E_RESET} is first, it can only match at the first position in the string. The third look-ahead still fails, but when the 
engine tries to match at further positions, the ${E_WHITE_FG}\A${E_RESET} immediately fails, so the engine doesn't need to waste any more time with the 
look-aheads. 

${E_WHITE_FG}Lookarounds Stand their Ground${E_RESET}

If I seem to be flogging a dead horse here, it's only because this point is the most common source of confusion with look-arounds. 
As the password validation example made clear, look-arounds stand their ground. They look immediately to the left or right of the 
engine's current position on the string—but do not alter that position. 

Therefore, do not expect the pattern ${E_WHITE_FG}A(?=5)${E_RESET} to match the ${E_WHITE_FG}A${E_RESET} in the string ${E_WHITE_FG}AB25${E_RESET}. Many beginners assume that the look-ahead says that 
"there is a ${E_WHITE_FG}5${E_RESET} somewhere to the right", but that is not so. After the engine matches the ${E_WHITE_FG}A${E_RESET}, the look-ahead ${E_WHITE_FG}(?=5)${E_RESET} asserts that at the 
current position in the string, what immediately follows is a 5. If you want to check if there is a 5 somewhere (anywhere) to the 
right, you can use ${E_WHITE_FG}(?=[^5]*5)${E_RESET}. 

Moreover, don't expect the pattern ${E_WHITE_FG}A(?=5)(?=[A-Z])${E_RESET} to match the ${E_WHITE_FG}A${E_RESET} in the string ${E_WHITE_FG}A5B${E_RESET}. Many beginners assume that the second 
look-ahead looks to the right of the first look-ahead. It is not so. At the end of the first look-ahead, the engine is still planted 
at the very same spot in the string, after the ${E_WHITE_FG}A${E_RESET}. When the look-ahead ${E_WHITE_FG}(?=[A-Z])${E_RESET} tries to assert that what immediately follows the 
current position is an uppercase letter, it fails because the next character is still the ${E_WHITE_FG}5${E_RESET}. If you want to check that the ${E_WHITE_FG}5${E_RESET} is 
followed by an uppercase letter, just state it in the first look-ahead: ${E_WHITE_FG}(?=5[A-Z])${E_RESET} 

So look-ahead and look-behind don't mean "look way ahead into the distance". They mean "look at the text immediately to the left or 
to the right". If you want to inspect a piece of string further down, you will need to insert "binoculars" inside the look-ahead to 
get you to the part of the string you want to inspect — for instance a ${E_WHITE_FG}.*${E_RESET}, or, ideally, more specific tokens.

${E_WHITE_FG}Various Uses for Lookarounds${E_RESET}

Before we dive into interesting but sometimes terse details, let's get excited about look-arounds by surveying some of their 
terrific uses. 

${E_WHITE_FG}Validation${E_RESET}

The password validation section showed how the combination of several look-aheads can impose a number of conditions on the string to 
be matched, allowing us to validate it with a single pattern. 

${E_WHITE_FG}Restricting a Character Range (Subtraction, Intersection)${E_RESET}

Suppose you want to match one word character \w as long as it is not the letter Q. There are several ways to do it without 
look-arounds:
✽ In engines that support character class subtraction, you can use ${E_WHITE_FG}[\w-[Q]]${E_RESET} (.NET), ${E_WHITE_FG}[\w&&[^Q]]${E_RESET} (Java and Ruby 1.9+) or ${E_WHITE_FG}[\w--Q]${E_RESET} 
(Python with the alternate regex module)
✽ You can build a character class such as ${E_WHITE_FG}[_0-9a-zA-PR-Z]${E_RESET}
✽ You can use ${E_WHITE_FG}[^\WQ]${E_RESET} — an example of an obnoxious double-negative character range. 

If your engine doesn't support character class subtraction, the simplest may be to use the workaround shown on the page about class 
operations. This uses a look-ahead to restrict the character class ${E_WHITE_FG}\w: (?!Q)\w${E_RESET}
After the negative look-ahead asserts that what follows the current position is not a ${E_WHITE_FG}Q${E_RESET}, the ${E_WHITE_FG}\w${E_RESET} matches a word character. 

Not only is this solution easy to read, it is also easy to maintain if we ever decide to exclude the letter ${E_WHITE_FG}K${E_RESET} instead of ${E_WHITE_FG}Q${E_RESET}, or to 
exclude both: ${E_WHITE_FG}(?![QK])\w${E_RESET}

Note that we can also perform the same exclusion task with a negative look-behind:
${E_WHITE_FG}\w(?<!Q)${E_RESET}
After the ${E_WHITE_FG}\w${E_RESET} matches a word character, the negative look-behind asserts that what precedes the current position is not a ${E_WHITE_FG}Q${E_RESET}. 

Using the same idea, if we wanted to match one character in the Arabic script as long as it is not a number, we could use this 
pattern:
${E_WHITE_FG}(?!\p{N})\p{Arabic}${E_RESET}
This would work in Perl, PCRE (C, PHP, R…) and Ruby 2+. In .NET and Java, you would use ${E_WHITE_FG}(?!\p{N})\p{IsArabic}${E_RESET}

Likewise, we can use this technique to perform a DIY character class intersection. For instance, to match one character in the 
Arabic script as long as it is a number, we transform the negative look-ahead above to a positive look-ahead. In the Perl / PCRE / 
Ruby version, this gives us:
${E_WHITE_FG}(?=\p{N})\p{Arabic}${E_RESET}

This is basically the password validation technique with two conditions applied to a single character. 

Needless to say, you can interchange the content of the look-ahead with the token to be matched:
${E_WHITE_FG}(?=\p{Arabic})\p{N}${E_RESET}

${E_WHITE_FG}Tempering the scope of a token${E_RESET}

This use is similar to the last. Instead of removing characters from a class, it restricts the scope within which a token is 
allowed to match.

For instance, suppose we want to match any character as long as it is not followed by ${E_WHITE_FG}{END}${E_RESET}. Using a negative look-ahead, we can use:
${E_WHITE_FG}(?:(?!{END}).)*${E_RESET}
Each . token is tempered by ${E_WHITE_FG}(?!{END})${E_RESET}, which specifies that the dot cannot be the beginning of ${E_WHITE_FG}{END}${E_RESET}. This technique is called 
tempered greedy token on the Quantifiers page.

Another technique is:
${E_WHITE_FG}(?:[^{]++|{(?!END}))*+${E_RESET}
On the left side of the alternation, ${E_WHITE_FG}[^{]++${E_RESET} matches characters that are not an opening brace. On the right side, ${E_WHITE_FG}{(?!END})${E_RESET} matches 
an opening brace that is not followed by ${E_WHITE_FG}END}${E_RESET}. This technique appears in the Explicit Greedy Alternation section of the Quantifiers 
page.

${E_WHITE_FG}Delimiter${E_RESET}

Do you have a string where you want to start matching all characters once the first instance of ${E_WHITE_FG}#START#${E_RESET} is passed? No problem, just 
use a look-behind to make a delimiter:
${E_WHITE_FG}(?<=#START#).*${E_RESET}
After the look-behind asserts that what immediately precedes the current position is ${E_WHITE_FG}#START#${E_RESET}, the ${E_WHITE_FG}dot-star .*${E_RESET} matches all the 
characters to the right. 

Or would you like to match all characters in a string up to, but not including the characters # END#? Make a delimiter using a 
look-ahead:
${E_WHITE_FG}.*?(?=#END#)${E_RESET}

You can, of course, combine the two:
${E_WHITE_FG}(?<=#START#).*?(?=#END#)${E_RESET}

See the page on boundaries for advice on building fancy DIY delimiters. 

${E_WHITE_FG}Inserting Text at a Position${E_RESET}

Someone gave you a file full of film titles in CamelCase, such as HaroldAndKumarGoToWhiteCastle. To make it easier to read, you 
want to insert a space at each position between a lowercase letter and an uppercase letter. This regex matches these exact 
positions: 
${E_WHITE_FG}(?<=[a-z])(?=[A-Z])${E_RESET}

In your text editor's regex replacement function, all you have to do is replace the matches space characters, and spaces be 
inserted in the right spot. 

This regex is what's known as a "zero-width match" because it matches a position without matching any actual characters. How does 
it work? The look-behind asserts that what immediately precedes the current position is a lowercase letter. And the look-ahead 
asserts that what immediately follows the current position is an uppercase letter. 

${E_WHITE_FG}Splitting a String at a Position${E_RESET}

We can use the exact same regex from the previous example to split the string ${E_WHITE_FG}AppleOrangeBananaStrawberryPeach${E_RESET} into a list of 
fruits. Once again, the regex
${E_WHITE_FG}(?<=[a-z])(?=[A-Z])${E_RESET}
matches the positions between a lowercase letter and an uppercase letter. 

In most languages, when you feed this regex to the function that uses a regex pattern to split strings, it returns an array of 
words. 

Note that Python's re module does not split on zero-width matches—but the far superior regex module does. 

${E_WHITE_FG}Finding Overlapping Matches${E_RESET}

Sometimes, you need several matches within the same word. For instance, suppose that from a string such as ${E_WHITE_FG}ABCD${E_RESET} you want to extract 
${E_WHITE_FG}ABCD, BCD, CD and D${E_RESET}. You can do it with this single regex:
${E_WHITE_FG}(?=(\w+))${E_RESET}
When you allow the engine to find all matches, all the substrings will be captured to Group 1

How does this work?

At the first position in the string (before the ${E_WHITE_FG}A)${E_RESET}, the engine starts the first match attempt. The look-ahead asserts that what 
immediately follows the current position is one or more word characters, and captures these characters to Group 1. The look-ahead 
succeeds, and so does the match attempt. Since the pattern didn't match any actual characters (the look-ahead only looks), the 
engine returns a zero-width match (the empty string). It also returns what was captured by Group 1: ${E_WHITE_FG}ABCD${E_RESET}

The engine then moves to the next position in the string and starts the next match attempt. Again, the look-ahead asserts that what 
immediately follows that position is word characters, and captures these characters to Group 1. The match succeeds, and Group 1 
contains ${E_WHITE_FG}BCD${E_RESET}. 

The engine moves to the next position in the string, and the process repeats itself for ${E_WHITE_FG}CD${E_RESET} then ${E_WHITE_FG}D${E_RESET}. 

In .NET, which has infinite look-behind, you can find overlapping matches from the other side of the string. For instance, on the 
same string ${E_WHITE_FG}ABCD${E_RESET}, consider this pattern:
${E_WHITE_FG}(?<=(\w+))${E_RESET}

It will capture ${E_WHITE_FG}A, AB, ABC and ABCD${E_RESET}. To achieve the same in an engine that doesn't support infinite look-behind, you would have to 
reverse the string, use the look-ahead version  ${E_WHITE_FG}(?=(\w+))${E_RESET} then reverse the captures.

${E_WHITE_FG}Zero-Width Matches${E_RESET}

As we've seen, a look-around looks left or right but it doesn't add any characters to the match to be returned by the regex engine. 
Likewise, an anchor such as ^ and a boundary such as ${E_WHITE_FG}\b${E_RESET} can match at a given position in the string, but they do not add any 
characters to the match.

Usually, look-aheads, look-behinds, anchors and boundaries appear in patterns that contain tokens that do match characters, allowing 
the engine to return a matched string. For instance, in ${E_WHITE_FG}(?<=start_)\d+${E_RESET}, the engine matches and returns some digits, but not the 
prefix ${E_WHITE_FG}start_${E_RESET}

However, if a pattern only contains look-arounds, anchors and boundaries, the engine may be able to match the pattern without 
matching any characters. The resulting match is called a zero-width match because it contains no characters.

This can be a useful technique, and we have already seen some applications of zero-width matches in the section on uses for 
look-arounds. To bring them together under one heading, here are some of their main uses. 

${E_WHITE_FG}Validation${E_RESET}

If you string several look-arounds in a row, you can validate that a string conforms to a set of rules, as in the password 
validation technique. 

We saw that when you have n conditions, if you also want to match the string, you usually need n-1 look-arounds at the most as one 
condition can be removed and used in the matching section of the pattern. But if all you want to do is validate, all the conditions 
can stay inside look-arounds, giving you a zero-width match. 

${E_WHITE_FG}Inserting${E_RESET}

You can use a zero-width match regex to match a position in a string and insert text at that position. For instance, by matching 
${E_WHITE_FG}(?m)^${E_RESET} (the beginning of a line in multiline mode) and replacing the match with ${E_WHITE_FG}//${E_RESET} , you can add a prefix to every line of a file.

Likewise, we saw how the zero-width pattern ${E_WHITE_FG}(?<=[a-z])(?=[A-Z])${E_RESET} allows you to insert characters in a CamelCase word. 

${E_WHITE_FG}Splitting${E_RESET}

We saw how the same zero-width pattern ${E_WHITE_FG}(?<=[a-z])(?=[A-Z])${E_RESET} allows you to split a CamelCase word into its components. 

${E_WHITE_FG}Overlapping Matches${E_RESET}

We saw how an unanchored look-around that contains capture groups—such as ${E_WHITE_FG}(?=(\w+))${E_RESET} — allows you to match overlapping string 
segments. 

${E_WHITE_FG}Positioning the Lookaround${E_RESET}

Often, you have two options for positioning a look-around: before the text to be matched, or after. Usually, one of the options is 
more efficient because it requires less work of the engine.

To illustrate this, here are examples for each kind of look-around. I borrowed them from the look-arounds section of the main syntax 
page, where they are discussed in greater detail. 

${E_WHITE_FG}look-ahead${E_RESET}

${E_WHITE_FG}\d+(?= dollars)${E_RESET} and ${E_WHITE_FG}(?=\d+ dollars)\d+${E_RESET} both match ${E_WHITE_FG}100${E_RESET} in ${E_WHITE_FG}100${E_RESET} dollars, but the first is more efficient because the engine needs to 
match ${E_WHITE_FG}\d+${E_RESET} only once. 

${E_WHITE_FG}Negative look-ahead${E_RESET}

${E_WHITE_FG}\d+(?! dollars)${E_RESET} and ${E_WHITE_FG}(?!\d+ dollars)\d+${E_RESET} both match 100 in 100 pesos, but the first is more efficient because the engine needs to 
match \d+ only once. 

${E_WHITE_FG}look-behind${E_RESET}

${E_WHITE_FG}(?<=USD)\d{3}${E_RESET} and ${E_WHITE_FG}\d{3}(?<=USD\d{3})${E_RESET} both match ${E_WHITE_FG}100${E_RESET} in ${E_WHITE_FG}USD100${E_RESET}, but the first is more efficient because the engine needs to match 
${E_WHITE_FG}\d{3}${E_RESET} only once. 

${E_WHITE_FG}Negative look-behind${E_RESET}

${E_WHITE_FG}(?<!USD)\d{3}${E_RESET} and ${E_WHITE_FG}\d{3}(?<!USD\d{3})${E_RESET} both match ${E_WHITE_FG}100${E_RESET} in ${E_WHITE_FG}JPY100${E_RESET}, but the first is more efficient because the engine needs to match 
${E_WHITE_FG}\d{3}${E_RESET} only once. 

What may not be so clear is that each of these look-arounds can be used in two main ways: before the expression to be matched, or 
after it. These two ways have a slightly different feel. Please don't obsess over the differences; rather, just cruise through 
these simple examples to become familiar with the types of effects you can achieve. 

When you compare each pair, the two methods have a different feel. The point of the examples is not to make you memorize "the right 
position", but to expose you to those two basic feels. Once you're familiar with them, you will naturally think of rewriting a 
look-around that feels too heavy. With a bit of practice, the efficient way of positioning your look-arounds will probably come to 
you naturally. 

${E_WHITE_FG}Lookarounds that Look on Both Sides: Back to the Future${E_RESET}

Suppose you want to match a two-digit number surrounded by underscores as in ${E_WHITE_FG}_12_${E_RESET} but not the underscores. 

We have already seen three ways to do this:
✽ You can match everything and capture the digits to Group 1: ${E_WHITE_FG}_(\d{2})_${E_RESET}
✽ You can use a look-behind and a look-ahead: ${E_WHITE_FG}(?<=_)\d{2}(?=_)${E_RESET}
✽ You can use ${E_WHITE_FG}\K${E_RESET} to drop the first underscore from the match: ${E_WHITE_FG}_\K\d{2}(?=_)${E_RESET}

There is a fourth technique I'd like to introduce you to. I call it the "back to the future look-behind." There shouldn't be any 
reason to use it on its own, but sometimes within an intricate pattern it may just what you need, so it's nice to be familiar with 
it and add it to your repertoire.

We can position our back-to-the-future look-behind before or after the digits. Let's start with the before version:
${E_WHITE_FG}(?<=_(?=\d{2}_))\d+${E_RESET}

Wowzy, what does this do? The look-behind asserts that what immediately precedes the current position in the string is an 
underscore, then a position where the look-ahead ${E_WHITE_FG}(?=\d{2}_)${E_RESET} can assert that what immediately follows is two digits and an underscore.

This is interesting for several reasons. First, we have a look-ahead within a look-behind, and even though we were supposed to look 
backwards, this look-ahead jumps over the current position by matching the two digits and the trailing underscore. That's acrobatic. 

Second, note that even though it looks complex, this is a fixed-width look-behind (the width is one character, the underscore), so 
it should work in all flavors of look-behind. (However, it does not work in Ruby as Ruby does not allow look-aheads and negative 
look-behinds inside look-behind.) 

Another interesting feature is how the notion of "current position in the string" is not the same for the look-behind and for the 
look-ahead. You'll remember that look-arounds stand their ground, so that after checking the assertion made by a look-around, the 
engine hasn't moved in the string. Are we breaking that rule?

We're not. In the string ${E_WHITE_FG}10 _16_ 20${E_RESET}, let's say the engine has reached the position between the underscore and the ${E_WHITE_FG}1${E_RESET} in ${E_WHITE_FG}16${E_RESET}. The 
look-behind makes an assertion about what can be matched at that position. When the engine exits the look-behind, it is still 
standing in that same spot, and the token ${E_WHITE_FG}\d{2}${E_RESET} can proceed to match the characters ${E_WHITE_FG}16${E_RESET}. 

But within the look-behind itself, we enter a different little world. You can imagine that outside that world the engine is red, and 
inside the little world of the look-behind, there is another little engine which is yellow. That yellow engine keeps track of its 
own position in the string. In most engines (.NET proceeds differently), the yellow engine is initially dropped at a position in 
the string that is found by taking the red engine's position and subtracting the width of the look-behind, which is 1. The yellow 
engine therefore starts its work before the leading underscore. Within the look-behind's little world, after matching the underscore 
token, the yellow engine's position in the string is between the underscore and the 1. It is that position that the look-ahead 
refers to when it asserts that at the current position in the string (according to the little world of the look-behind and its 
yellow engine), what immediately follows is two digits and an underscore.

After the digits
Here is a second version where the "back-to-the-future look-behind" comes after the digits:
${E_WHITE_FG}\d+(?<=_\d{2}(?=_))${E_RESET}

The look-behind states: what immediately precedes this position in the string is an underscore and two digits, then a position where 
the look-ahead ${E_WHITE_FG}(?=_)${E_RESET} can assert that what immediately follows the current position in the string (according to the yellow engine and 
the look-behind's little world) is an underscore. 

This too is a fixed-width look-behind (the width is three character, i.e. the leading underscore and the two digits), so it should 
work in all flavors of look-behind except Ruby. 

${E_WHITE_FG}Compound look-ahead and Compound look-behind${E_RESET}

The back-to-the-future look-behind introduced us to what I call compound look-arounds, i.e., look-arounds that contain other 
look-arounds. You could also call them nested look-arounds, but for me the idea of compounding captures something more about the feel 
of working with these constructs. 

Let's look at some examples.

Token followed by one character, but not more
How can you match a number that is followed by one underscore, but not more?

You can use this:
${E_WHITE_FG}\d+(?=_(?!_))${E_RESET}
The look-ahead asserts: what follows the current position in the string is one underscore, then a position where the negative 
look-ahead ${E_WHITE_FG}(?!_)${E_RESET} can assert that what follows is not an underscore. A less elegant variation would be ${E_WHITE_FG}\d+(?=(?!__)_)${E_RESET}

Token preceded by one character, but not more
How can you match a number that is preceded by one underscore, but not more?

You can use this:
${E_WHITE_FG}(?<=(?<!_)_)\d+${E_RESET}
The look-behind asserts: what precedes the current position in the string is a position where the negative look-behind ${E_WHITE_FG}(?<!_)${E_RESET} can 
assert that what immediately precedes is not an underscore, then an underscore. A variation would be ${E_WHITE_FG}(?<=_(?<!__))\d+${E_RESET} 

${E_WHITE_FG}Multiple Compounding${E_RESET}

Needless to say, it won't be long until you find occasions to add levels of compounding beyond the two we've just seen. But that 
quickly becomes obnoxious, and it becomes simpler to rearrange the regex. For instance, building on the previous pattern,
${E_WHITE_FG}(?<=(?<!(?<!X)_)_)\d+${E_RESET}
matches a number that is precede by an underscore that is not preceded by an underscore unless that underscore is preceded by an X. 

In .NET, PCRE, Java and Ruby, this could be simplified to ${E_WHITE_FG}(?<=(?<!_)_|X__)\d+ ${E_RESET}
In Perl and Python, you could use ${E_WHITE_FG}(?:(?<=(?<!_)_)|(?<=X__))\d+ ${E_RESET}

${E_WHITE_FG}The Engine Doesn't Backtrack into Lookarounds…${E_WHITE_FG}because they're atomic${E_RESET}

Here's a fun regex task. You have a string like this:
${E_WHITE_FG}_rabbit _dog _mouse DIC:cat:dog:mouse${E_RESET}

The ${E_WHITE_FG}DIC${E_RESET} section at the end contains a list of allowed animals. Our job is to match all the _tokens named after an allowed animal. 
Therefore, we expect to match ${E_WHITE_FG}_dog${E_RESET} and ${E_WHITE_FG}_mouse${E_RESET}. A look-around helps us do this:

${E_WHITE_FG}_(\w+)\b(?=.*:\1\b)${E_RESET}

After matching the underscore, we capture a word to Group 1. Then the look-ahead ${E_WHITE_FG}(?=.*:\1\b)${E_RESET} asserts what follows the current 
position in the string is zero or more characters, then a colon, then the word captured to Group 1. As hoped, this matches both 
${E_WHITE_FG}_dog and _mouse${E_RESET}.

Now suppose we try a "reversed" approach:

${E_WHITE_FG}_(?=.*:(\w+)\b)\1\b${E_RESET}

This only matches ${E_WHITE_FG}_mouse${E_RESET}. Why?

First let's try to understand what this regex hopes to accomplish. It may not be that obvious, but it illustrates an important 
feature of look-arounds. 

After the engine matches the underscore, the look-ahead ${E_WHITE_FG}(?=.*:(\w+)\b)${E_RESET} asserts that what follows the current position in the string 
is any number of characters, then a colon, then a word (captured to Group 1). After passing that assertion, the back-reference ${E_WHITE_FG}\1${E_RESET} 
matches what was captured into Group 1. 

Let's see how this works out. Remember that our string is 
${E_WHITE_FG}_rabbit _dog _mouse DIC:cat:dog:mouse${E_RESET}

After the ${E_WHITE_FG}underscore${E_RESET} that precedes ${E_WHITE_FG}rabbit${E_RESET}, we expect the look-ahead to fail because there is no ${E_WHITE_FG}rabbit${E_RESET} in the ${E_WHITE_FG}DIC section${E_RESET}—and it 
does. The next time we match an ${E_WHITE_FG}underscore${E_RESET} is before ${E_WHITE_FG}dog${E_RESET}. At that stage, inside the look-ahead ${E_WHITE_FG}(?=.*:(\w+)\b)${E_RESET}, the ${E_WHITE_FG}dot-star${E_RESET} shoots 
down to the end of the string, then backtracks just far enough to allow the colon to match, after which the word ${E_WHITE_FG}mouse${E_RESET} is matched 
and captured to Group 1. The look-ahead succeeds. The next token ${E_WHITE_FG}\1${E_RESET} tries to match ${E_WHITE_FG}mouse${E_RESET}, but the next character in the string is 
the ${E_WHITE_FG}d${E_RESET} from ${E_WHITE_FG}dog${E_RESET}, so the token fails. At this stage, having learned everything about backtracking, we might assume that the regex 
engine allows the ${E_WHITE_FG}dot-star${E_RESET} to backtrack even more inside the look-ahead, up to the previous ${E_WHITE_FG}colon${E_RESET}, which would then allow ${E_WHITE_FG}(\w+)${E_RESET} to 
match and capture ${E_WHITE_FG}mouse${E_RESET}. Then the back-reference ${E_WHITE_FG}\1${E_RESET} would match ${E_WHITE_FG}mouse${E_RESET}, and the engine would return a successful match.

However, it does not work that way. Once the regex engine has left a look-around, it will not backtrack into it if something fails 
somewhere down the pattern. On a logical level, that is because the official point of a look-around is to return one of two values: 
true or false. Once a look-ahead evaluates to true at a given position in the string, it is always true. From the engine's 
standpoint, there is nothing to backtrack. What would be the point—since the only other available value is false, and that would 
fail the pattern? 

The fact that the engine will not backtrack into a look-around means that it is an atomic block. This property of look-arounds will 
rarely matter, but if someday, in the middle of building an intricate pattern, a look-ahead refuses to cooperate… This may be the 
reason. 

${E_WHITE_FG}Fixed-Width, Constrained-Width and Infinite-Width look-behind${E_RESET}

In strings such as 123456_ORANGE abc12_APPLE, suppose you are interested in matching uppercase words, provided they are preceded by 
a prefix composed of digits and an underscore character. Therefore, in this string, you want to match ORANGE but not APPLE. 

It's worth remembering that in most regex flavors (.NET is one of the few exceptions), the following pattern is invalid:

${E_WHITE_FG}(?<=\b\d+_)[A-Z]+${E_RESET}

That is because the width of the text matched by the token ${E_WHITE_FG}\d+${E_RESET} can be anything. Most engines require the width of the subexpression 
within a look-behind to be known in advance, as in ${E_WHITE_FG}(?<=\d{3}) ${E_RESET}

Some engines allow the width of the subexpression within a look-behind to take various pre-determined values found on the various 
sides of an alternation, as in ${E_WHITE_FG}(?<=0|128|\d{6})${E_RESET}. Yet others allow the width to vary within a pre-determined range, as in 
${E_WHITE_FG}(?<=d{2,6})${E_RESET} 

For details of what kinds of widths various engines allow in a look-behind, see the look-behind: Fixed-Width / Constrained Width / 
Infinite Width section of the main syntax page. To honor the winners, I'll just repeat here that the only two programming-language 
flavors that support infinite-width look-behind are .NET (C#, VB.NET, …) and Matthew Barnett's regex module for Python. I've also 
implemented an infinite look-behind demo for PCRE. 

Capture Group Inside Variable look-behind: Difference between Java and .NET
Both Java and .NET allow this pattern: 
${E_WHITE_FG}(?<=(\d{1,5}))Z${E_RESET}

.NET allows it because it supports infinite-width look-behind. Java allows it because it supports look-behind whose width falls 
within a defined range. However, they operate differently. As a result, against the string ${E_WHITE_FG}123Z${E_RESET}, this pattern will return different 
Group 1 captures in the two engines.

✽ Java captures ${E_WHITE_FG}3${E_RESET} to Group 1. The engine sees that the width of the string to be matched inside the look-behind must fall between 
one and five characters. Java tries all the possible fixed-width patterns in the range, from the shortest to the longest, until one 
succeeds. The shortest possible fixed-width pattern is ${E_WHITE_FG}(?<=(\d{1}))${E_RESET}. The engine temporarily skips back one character in the string, 
tries to match ${E_WHITE_FG}\d{1}${E_RESET} and succeeds. The look-around succeeds, and Group 1 contains ${E_WHITE_FG}3${E_RESET}.

✽ .NET captures ${E_WHITE_FG}123${E_RESET} to Group 1. The .NET engine has a far more efficient way of processing variable-width look-behinds. Instead of 
trying multiple fixed-width patterns starting at points further and further back in the string, .NET reverses the string as well as 
the pattern inside the look-behind, then attempts to match that single pattern on the reversed string. Therefore, in ${E_WHITE_FG}123Z${E_RESET}, to try 
the look-behind at the point before ${E_WHITE_FG}Z${E_RESET}, it reverses the portion of string to be tested from ${E_WHITE_FG}123${E_RESET} to ${E_WHITE_FG}321${E_RESET}. Likewise, the look-behind 
${E_WHITE_FG}(?<=(\d{1,5}))${E_RESET} is flipped into the look-ahead ${E_WHITE_FG}(?=(\d{1,5}))${E_RESET}. ${E_WHITE_FG}\d{1,5}${E_RESET} matches ${E_WHITE_FG}321${E_RESET}. Reversing that string, Group 1 contains ${E_WHITE_FG}123${E_RESET}. To 
only capture ${E_WHITE_FG}3${E_RESET} as in Java, you would have to make the quantifier lazy:  ${E_WHITE_FG}(?<=(\d{1,5}?))Z${E_RESET} 

✽ Like .NET, the regex alternate regular expressions module for Python captures ${E_WHITE_FG}123${E_RESET} to Group 1.

${E_WHITE_FG}Workarounds${E_RESET}

There are two main workarounds to the lack of support for variable-width (or infinite-width) look-behind:

✽ Capture groups.
Instead of ${E_WHITE_FG}(?<=\b\d+_)[A-Z]+${E_RESET} , you can use ${E_WHITE_FG}\b\d+_([A-Z]+)${E_RESET}, which matches the digits and underscore you don't want to see, then 
matches and captures to Group 1 the uppercase text you want to inspect. This will work in all major regex flavors.

✽ The ${E_WHITE_FG}\K${E_RESET} "keep out" verb, which is available in Perl, PCRE (C, PHP, R…), Ruby 2+ and Python\'s alternate regex engine.
${E_WHITE_FG}\K${E_RESET} tells the engine to drop whatever it has matched so far from the match to be returned. Instead of ${E_WHITE_FG}(?<=\b\d+_)[A-Z]+${E_RESET}, you can 
therefore use ${E_WHITE_FG}\b\d+_\K[A-Z]+${E_RESET}

Compared with look-behinds, both the ${E_WHITE_FG}\K${E_RESET} and capture group workarounds have limitations:

✽ When you look for multiple matches in a string, at the starting position of each match attempt, a look-behind can inspect the 
characters behind the current position in the string. Therefore, against ${E_WHITE_FG}123${E_RESET}, the pattern ${E_WHITE_FG}(?<=\d)\d${E_RESET} (match a digit preceded by a 
digit) will match both ${E_WHITE_FG}2${E_RESET} and ${E_WHITE_FG}3${E_RESET}. In contrast, ${E_WHITE_FG}\d\K\d${E_RESET} can only match ${E_WHITE_FG}2${E_RESET}, as the starting position after the first match is immediately 
before the ${E_WHITE_FG}3${E_RESET}, and there are not enough digits left for a second match. Likewise, \d(\d) can only capture ${E_WHITE_FG}2${E_RESET}. 

✽ With look-behinds, you can impose multiple conditions (similar to our password validation technique) by using multiple 
look-behinds. For instance, to match a digit that is preceded by a lower-case Greek letter, you can use ${E_WHITE_FG}(?<=\p{Ll})(?<=\p{Greek})\d${E_RESET}. 
The first look-behind ${E_WHITE_FG}(?<=\p{Ll})${E_RESET} ensures that the character immediately to the left is a lower-case letter, and the second 
look-behind ${E_WHITE_FG}(?<=\p{Greek})${E_RESET} ensures that the character immediately to the left belongs to the Greek script. With the workarounds, you 
could use ${E_WHITE_FG}\p{Greek}\K\d${E_RESET} to match a digit preceded by a character in the Greek script (or ${E_WHITE_FG}\p{Greek}(\d)${E_RESET} to capture it), but you 
cannot impose a second condition. To get over this limitation, you could capture the Greek character and use a second regex to 
check that it is a lower-case letter. 

${E_WHITE_FG}Lookarounds (Usually) Want to be Anchored${E_RESET}

Let's imagine we want to match a string consisting of one word, provided it contains at least one digit. This pattern offers a 
reasonable solution—one of several:
${E_WHITE_FG}\A(?=\D*\d)\w+\z${E_RESET}

The ${E_WHITE_FG}\A${E_RESET} anchor asserts that the current position is the beginning of the string. The look-ahead ${E_WHITE_FG}(?=\D*\d)${E_RESET} asserts that at the current 
position (which is still the beginning of the string), we can match zero or more non-digits, then one digit. Next, ${E_WHITE_FG}\w+${E_RESET} matches our 
word. Finally, the ${E_WHITE_FG}\z${E_RESET} anchor asserts that the current position is the end of the string. 

Now consider what happens when we forget the anchor ${E_WHITE_FG}\A${E_RESET} and use ${E_WHITE_FG}(?=\D*\d)\w+\z${E_RESET}. To make our oversight seem less severe, let's assume 
we know that our string always contains an uninterrupted string of word characters. This guarantees that if we find a match, it 
will have to be the right one—at the beginning of the string, as we wanted. So what's the problem? 

Suppose we use our regex on a string composed of one hundred characters ${E_WHITE_FG}V${E_RESET}. Since the string doesn't contain a single digit, you and 
I can immediately see that the regex must fail. Let's see how fast the engine comes to the same conclusion. 

As always, the engine begins by trying to match the pattern at the first position in the string. Starting with the first token 
${E_WHITE_FG}(?=\D*\d)${E_RESET}, it tries to assert that at the current position, i.e. the beginning of the string, it can match zero or more non-digits, 
then one digit. Within the subexpression, the \D* matches all the ${E_WHITE_FG}V${E_RESET} characters. The engine then tries to match a digit, but since 
we have reached the end of the string, that fails. 

If we're using a smart engine such as PCRE, at this stage the engine fails the look-around for this first match attempt. That's 
because before starting the match attempt, the engine has studied the pattern and noticed that the \D and \d tokens are mutually 
exclusive, and it has turned the ${E_WHITE_FG}*${E_RESET} quantifier into a possessive quantifier ${E_WHITE_FG}*+${E_RESET}, a process known to PCRE as auto-possessification 
(see footnote). 

A less clever engine will backtrack, giving up all the \D characters it has matched one by one, each time attempting to match a ${E_WHITE_FG}\d${E_RESET} 
after giving up a ${E_WHITE_FG}\D${E_RESET}. Eventually, the engine runs out of characters to backtrack, and the look-ahead fails.

Once the engine understands that the look-ahead must fail (whether it comes to this conclusion cleverly or clumsily), it gives up on 
the entire first match attempt. Next, as always in such cases, the engine moves to the next position in the string (past the first 
${E_WHITE_FG}V)${E_RESET} and starts a new match attempt. Again, the ${E_WHITE_FG}\D*${E_RESET} eats up all the ${E_WHITE_FG}V${E_RESET} characters—although this time, there are only 99 of them. 
Again, the look-ahead fails, either fast if the engine is smart, or, more likely, after backtracking all the way back to the 
starting position. 

After failing a second time, the engine moves past the second ${E_WHITE_FG}V${E_RESET}, starts a new match attempt, and fails… And so on, all the way to 
the end of the string. 

Because the pattern is not anchored at the beginning of the string, at each match attempt, the engine checks whether the look-ahead 
matches at the current position. In doing so, in the best case, it matches 100 ${E_WHITE_FG}V${E_RESET} characters, then 99 on the second attempt, and so 
on—so it needs about 5000 steps before it can see that the pattern will never match. In the more usual case, the engine needs to 
backtrack and try the ${E_WHITE_FG}\d${E_RESET} at each position, adding two steps at each V position. Altogether, it needs about 15,000 steps before it 
can see that the pattern will never match. 

In contrast, with the original anchored pattern ${E_WHITE_FG}\A(?=\D*\d)\w+\z${E_RESET}, after the engine fails the first match attempt, each of the 
following match attempts at further positions in the string fail instantly, because the ${E_WHITE_FG}\A${E_RESET} fails before the engine gets to the 
look-ahead. In the best case, the engine takes about 200 steps to fail (100 steps to match all the V characters, then one step at 
each of the further match attempts.) In the more usual case, the engine takes about 400 steps to fail (300 steps on the first match 
attempt, then one step at each of the further match attempts.) 

Needless to say, the ratio of (15,000 / 400) steps is the kind of performance hit we try to avoid in computing. This makes a solid 
case for helping the engine along by minimizing the number of times look-aheads must be attempted, either by using anchors such as ${E_WHITE_FG}^${E_RESET} 
and ${E_WHITE_FG}\A${E_RESET}, or by matching literal characters immediately before the look-ahead. 

${E_WHITE_FG}One Exception: Overlapping Matches${E_RESET}

There are times when we do want the engine to attempt the look-ahead at every single position in the string. Usually, the purpose of 
such a maneuver is to match a number of overlapping substrings. For instance, against the string word, if the regex ${E_WHITE_FG}(?=(\w+))${E_RESET} is 
allowed to match repeatedly, it will match four times, and each match will capture a different string to Group 1: ${E_WHITE_FG}word, ord, rd, 
then d${E_RESET}. The section on overlapping matches explains how this works. 

${E_WHITE_FG}Footnotes${E_RESET}

Atomic tweak
The atomic variation ${E_WHITE_FG}(?>[^a-z]*)[a-z]${E_RESET} or possessive version ${E_WHITE_FG}[^a-z]*+[a-z]${E_RESET} are tweaks that ensure that if the engine fails to find 
the lowercase letter, it won't "stupidly" backtrack, giving up the non-lowercase letters one by one to see if a lowercase letter 
might fit at that stage. 

Note that before they start matching, some engines notice the mutually exclusive character of ${E_WHITE_FG}[a-z]${E_RESET} and its counterclass and 
automatically make the ${E_WHITE_FG}*${E_RESET} quantifier possessive for you. This optimization is what PCRE calls auto-possessification. It allows you 
to turn it off with the Special Start-of-Pattern Modifier ${E_WHITE_FG}(*NO_AUTO_POSSESS)${E_RESET} — but why would you ever want to? 

tip_regex_EOF_1

cat << tip_regex_EOF_2 | mypager
${E_WHITE_FG}look-ahead and look-behind Zero-Length Assertions${E_RESET}

look-ahead and look-behind, collectively called “look-around”, are zero-length
assertions just like the start and end of line, and start and end of word
anchors explained earlier in this tutorial. The difference is that look-around
actually matches characters, but then gives up the match, returning only the
result: match or no match. That is why they are called “assertions”.  They do
not consume characters in the string, but only assert whether a match is
possible or not. Lookaround allows you to create regular expressions that are
impossible to create without them, or that would get very longwinded without
them.

Positive and Negative look-ahead Negative look-ahead is indispensable if you want
to match something not followed by something else. When explaining character
classes, this tutorial explained why you cannot use a negated character class to
match a ${E_WHITE_FG}q${E_RESET} not followed by a ${E_WHITE_FG}u${E_RESET}. Negative look-ahead provides the solution: ${E_WHITE_FG}q(?!u)${E_RESET}.
The negative look-ahead construct is the pair of parentheses, with the opening
parenthesis followed by a question mark and an exclamation point. Inside the
look-ahead, we have the trivial regex ${E_WHITE_FG}u${E_RESET}.

Positive look-ahead works just the same. ${E_WHITE_FG}q(?=u)${E_RESET} matches a ${E_WHITE_FG}q${E_RESET} that is followed by a
${E_WHITE_FG}u${E_RESET}, without making the ${E_WHITE_FG}u${E_RESET} part of the match. The positive look-ahead construct is a
pair of parentheses, with the opening parenthesis followed by a question mark
and an equals sign.

You can use any regular expression inside the look-ahead (but not look-behind, as
explained below). Any valid regular expression can be used inside the
look-ahead. If it contains capturing groups then those groups will capture as
normal and backreferences to them will work normally, even outside the
look-ahead. (The only exception is Tcl, which treats all groups inside look-ahead
as non-capturing.) The look-ahead itself is not a capturing group. It is
not included in the count towards numbering the backreferences. If you want to
store the match of the regex inside a look-ahead, you have to put capturing
parentheses around the regex inside the look-ahead, like this: ${E_WHITE_FG}(?=(regex))${E_RESET}. The
other way around will not work, because the look-ahead will already have
discarded the regex match by the time the capturing group is to store its match.

Regex Engine Internals First, let’s see how the engine applies ${E_WHITE_FG}q(?!u)${E_RESET} to the
string ${E_WHITE_FG}Iraq${E_RESET}. The first token in the regex is the literal ${E_WHITE_FG}q${E_RESET}. As we already know,
this causes the engine to traverse the string until the ${E_WHITE_FG}q${E_RESET} in the string
is matched. The position in the string is now the void after the string.
The next token is the look-ahead. The engine takes note that it is inside
a look-ahead construct now, and begins matching the regex inside the
look-ahead. So the next token is ${E_WHITE_FG}u${E_RESET}. This does not match the void after the
string. The engine notes that the regex inside the look-ahead failed.
Because the look-ahead is negative, this means that the look-ahead has
successfully matched at the current position. At this point, the entire
regex has matched, and ${E_WHITE_FG}q${E_RESET} is returned as the match.

Let’s try applying the same regex to quit. ${E_WHITE_FG}q${E_RESET} matches ${E_WHITE_FG}q${E_RESET}. The next token is the ${E_WHITE_FG}u
${E_RESET}inside the look-ahead. The next character is the ${E_WHITE_FG}u${E_RESET}. These match. The engine
advances to the next character: ${E_WHITE_FG}i${E_RESET}. However, it is done with the regex inside the
look-ahead. The engine notes success, and discards the regex match. This causes
the engine to step back in the string to ${E_WHITE_FG}u${E_RESET}.

Because the look-ahead is negative, the successful match inside it causes the
look-ahead to fail. Since there are no other permutations of this regex, the
engine has to start again at the beginning. Since ${E_WHITE_FG}q${E_RESET} cannot match anywhere else,
the engine reports failure.

Let’s take one more look inside, to make sure you understand the implications of
the look-ahead. Let’s apply ${E_WHITE_FG}q(?=u)i${E_RESET} to quit. The look-ahead is now positive and is
followed by another token. Again, ${E_WHITE_FG}q${E_RESET} matches ${E_WHITE_FG}q${E_RESET} and ${E_WHITE_FG}u${E_RESET} matches ${E_WHITE_FG}u${E_RESET}. Again, the match
from the look-ahead must be discarded, so the engine steps back from ${E_WHITE_FG}i${E_RESET} in the
string to ${E_WHITE_FG}u${E_RESET}. The look-ahead was successful, so the engine continues with ${E_WHITE_FG}i${E_RESET}. But ${E_WHITE_FG}i
${E_RESET}cannot match ${E_WHITE_FG}u${E_RESET}. So this match attempt fails. All remaining attempts fail as
well, because there are no more ${E_WHITE_FG}q${E_RESET}’s in the string.

The regex ${E_WHITE_FG}q(?=u)i${E_RESET} can never match anything. It tries to match ${E_WHITE_FG}u${E_RESET} and ${E_WHITE_FG}i${E_RESET} at the
same position. If there is a ${E_WHITE_FG}u${E_RESET} immediately after the ${E_WHITE_FG}q${E_RESET} then the look-ahead
succeeds but then ${E_WHITE_FG}i${E_RESET} fails to match ${E_WHITE_FG}u${E_RESET}. If there is anything other than a ${E_WHITE_FG}u
${E_RESET}immediately after the ${E_WHITE_FG}q${E_RESET} then the look-ahead fails.

Positive and Negative look-behind look-behind has the same effect, but works
backwards. It tells the regex engine to temporarily step backwards in the
string, to check if the text inside the look-behind can be matched there. ${E_WHITE_FG}(?<!a)b
${E_RESET}matches a “${E_WHITE_FG}b${E_RESET}” that is not preceded by an “${E_WHITE_FG}a${E_RESET}”, using negative look-behind. It
doesn’t match cab, but matches the ${E_WHITE_FG}b${E_RESET} (and only the ${E_WHITE_FG}b${E_RESET}) in ${E_WHITE_FG}bed${E_RESET} or ${E_WHITE_FG}debt${E_RESET}. ${E_WHITE_FG}(?<=a)b
${E_RESET}(positive look-behind) matches the ${E_WHITE_FG}b${E_RESET} (and only the ${E_WHITE_FG}b${E_RESET}) in ${E_WHITE_FG}cab${E_RESET}, but does not match
${E_WHITE_FG}bed${E_RESET} or ${E_WHITE_FG}debt${E_RESET}.

The construct for positive look-behind is ${E_WHITE_FG}(?<=text)${E_RESET}: a pair of parentheses, with
the opening parenthesis followed by a question mark, “less than” symbol, and an
equals sign. Negative look-behind is written as ${E_WHITE_FG}(?<!text)${E_RESET}, using an exclamation
point instead of an equals sign.

More Regex Engine Internals Let’s apply ${E_WHITE_FG}(?<=a)b${E_RESET} to thingamabob. The engine
starts with the look-behind and the first character in the string. In this case,
the look-behind tells the engine to step back one character, and see if ${E_WHITE_FG}a
${E_RESET}can be matched there. The engine cannot step back one character because
there are no characters before the ${E_WHITE_FG}t${E_RESET}. So the look-behind fails, and the
engine starts again at the next character, the ${E_WHITE_FG}h${E_RESET}. (Note that a negative
look-behind would have succeeded here.) Again, the engine
temporarily steps back one character to check if an “${E_WHITE_FG}a${E_RESET}” can be found
there. It finds a ${E_WHITE_FG}t${E_RESET}, so the positive look-behind fails again.

The look-behind continues to fail until the regex reaches the ${E_WHITE_FG}m${E_RESET} in the string.
The engine again steps back one character, and notices that the ${E_WHITE_FG}a${E_RESET} can be matched
there. The positive look-behind matches. Because it is zero-length, the current
position in the string remains at the ${E_WHITE_FG}m${E_RESET}. The next token is ${E_WHITE_FG}b${E_RESET}, which cannot match
here. The next character is the second ${E_WHITE_FG}a${E_RESET} in the string. The engine steps back,
and finds out that the ${E_WHITE_FG}m${E_RESET} does not match ${E_WHITE_FG}a${E_RESET}.

The next character is the first ${E_WHITE_FG}b${E_RESET} in the string. The engine steps back and finds
out that a satisfies the look-behind. ${E_WHITE_FG}b${E_RESET} matches ${E_WHITE_FG}b${E_RESET}, and the entire regex has been
matched successfully. It matches one character: the first ${E_WHITE_FG}b${E_RESET} in the string.

Important Notes About look-behind The good news is that you can use look-behind
anywhere in the regex, not only at the start. If you want to find a word not
ending with an “${E_WHITE_FG}s${E_RESET}”, you could use ${E_WHITE_FG}\b\w+(?<!s)\b${E_RESET}. This is definitely not the same
as ${E_WHITE_FG}\b\w+[^s]\b${E_RESET}. When applied to ${E_WHITE_FG}John's${E_RESET}, the former matches ${E_WHITE_FG}John${E_RESET} and the latter
matches ${E_WHITE_FG}John'${E_RESET} (including the apostrophe). I will leave it up to you to figure
out why. (Hint: ${E_WHITE_FG}\b${E_RESET} matches between the apostrophe and the ${E_WHITE_FG}s${E_RESET}). The latter also
doesn’t match single-letter words like “${E_WHITE_FG}a${E_RESET}” or “${E_WHITE_FG}I${E_RESET}”. The correct regex without
using look-behind is ${E_WHITE_FG}\b\w*[^s\W]\b${E_RESET} (star instead of plus, and ${E_WHITE_FG}\W${E_RESET} in the character
class). Personally, I find the look-behind easier to understand. The last
regex, which works correctly, has a double negation (the ${E_WHITE_FG}\W${E_RESET} in the negated
character class). Double negations tend to be confusing to humans. Not to
regex engines, though. (Except perhaps for Tcl, which treats negated shorthands
in negated character classes as an error.)

The bad news is that most regex flavors do not allow you to use just any regex
inside a look-behind, because they cannot apply a regular expression backwards.
The regular expression engine needs to be able to figure out how many characters
to step back before checking the look-behind. When evaluating the look-behind, the
regex engine determines the length of the regex inside the look-behind, steps
back that many characters in the subject string, and then applies the regex
inside the look-behind from left to right just as it would with a normal regex.

Many regex flavors, including those used by Perl, Python, and Boost only allow
fixed-length strings. You can use literal text, character escapes, Unicode
escapes other than \X, and character classes. You cannot use quantifiers or
backreferences. You can use alternation, but only if all alternatives have the
same length. These flavors evaluate look-behind by first stepping back through
the subject string for as many characters as the look-behind needs, and then
attempting the regex inside the look-behind from left to right.

Perl 5.30 supports variable-length look-behind as an experimental feature. But
there are many cases in which it does not work correctly. So in practice, the
above is still true for Perl 5.30.

PCRE is not fully Perl-compatible when it comes to look-behind. While Perl
requires alternatives inside look-behind to have the same length, PCRE allows
alternatives of variable length. PHP, Delphi, R, and Ruby also allow this. Each
alternative still has to be fixed-length. Each alternative is treated as a
separate fixed-length look-behind.

Java takes things a step further by allowing finite repetition. You can use the
question mark and the curly braces with the max parameter specified. Java
determines the minimum and maximum possible lengths of the look-behind. The
look-behind in the regex (?<!ab{2,4}c{3,5}d)test has 5 possible lengths. It can
be from 7 through 11 characters long. When Java (version 6 or later) tries to
match the look-behind, it first steps back the minimum number of characters (7 in
this example) in the string and then evaluates the regex inside the
look-behind as usual, from left to right. If it fails, Java steps back one more
character and tries again. If the look-behind continues to fail, Java continues
to step back until the look-behind either matches or it has stepped back the
maximum number of characters (11 in this example). This repeated stepping back
through the subject string kills performance when the number of possible lengths
of the look-behind grows. Keep this in mind. Don’t choose an arbitrarily large
maximum number of repetitions to work around the lack of infinite quantifiers
inside look-behind. Java 4 and 5 have bugs that cause look-behind with alternation
or variable quantifiers to fail when it should succeed in some situations. These
bugs were fixed in Java 6.

Java 13 allows you to use the star and plus inside look-behind, as well as curly
braces without an upper limit. But Java 13 still uses the laborious method of
matching look-behind introduced with Java 6. Java 13 also does not correctly
handle look-behind with multiple quantifiers if one of them is unbounded. In some
situations you may get an error. In other situations you may get incorrect
matches. So for both correctness and performance, we recommend you only use
quantifiers with a low upper bound in look-behind with Java 6 through 13.

The only regex engines that allow you to use a full regular expression inside
look-behind, including infinite repetition and backreferences, are the JGsoft
engine and the .NET framework RegEx classes. These regex engines really apply
the regex inside the look-behind backwards, going through the regex inside the
look-behind and through the subject string from right to left. They only need to
evaluate the look-behind once, regardless of how many different possible lengths
it has.

Finally, flavors like std::regex and Tcl do not support look-behind at all, even
though they do support look-ahead. JavaScript was like that for the longest time
since its inception. But now look-behind is part of the ECMAScript 2018
specification. As of this writing (late 2019), Google’s Chrome browser is the
only popular JavaScript implementation that supports look-behind. So if
cross-browser compatibility matters, you can’t use look-behind in JavaScript.

Lookaround Is Atomic The fact that look-around is zero-length automatically makes
it atomic. As soon as the look-around condition is satisfied, the regex engine
forgets about everything inside the look-around. It will not backtrack inside the
look-around to try different permutations.

The only situation in which this makes any difference is when you use capturing
groups inside the look-around. Since the regex engine does not backtrack into the
look-around, it will not try different permutations of the capturing groups.

For this reason, the regex ${E_WHITE_FG}(?=(\d+))\w+\1${E_RESET} never matches ${E_WHITE_FG}123x12${E_RESET}. First the
look-around captures ${E_WHITE_FG}123${E_RESET} into ${E_WHITE_FG}\1${E_RESET}. ${E_WHITE_FG}\w+${E_RESET} then matches the whole string and
backtracks until it matches only ${E_WHITE_FG}1${E_RESET}. Finally, ${E_WHITE_FG}\w+${E_RESET} fails since ${E_WHITE_FG}\1${E_RESET} cannot be
matched at any position. Now, the regex engine has nothing to backtrack to, and
the overall regex fails. The backtracking steps created by ${E_WHITE_FG}\d+${E_RESET} have been
discarded. It never gets to the point where the look-ahead captures only ${E_WHITE_FG}12${E_RESET}.

Obviously, the regex engine does try further positions in the string. If we
change the subject string, the regex ${E_WHITE_FG}(?=(\d+))\w+\1${E_RESET} does match ${E_WHITE_FG}56x56${E_RESET} in ${E_WHITE_FG}456x56${E_RESET}.

If you don’t use capturing groups inside look-around, then all this doesn’t
matter. Either the look-around condition can be satisfied or it cannot be. In how
many ways it can be satisfied is irrelevant.
tip_regex_EOF_2
cat << tip_regex_EOF_3 | mypager

${E_WHITE_FG}Basic topics${E_RESET}

${E_WHITE_FG}Anchors — ^ and \$${E_RESET}

/^The/       matches any string that starts with "The"
/end$/       matches a string that ends with "end"
/^The end$/  exact string match that starts and ends with "The end"
/roar/       matches any string that has the text "roar" in it

${E_WHITE_FG}Quantifiers — * + ? and {}${E_RESET}

/abc*/        matches a string that has ab followed by zero or more "c"
/abc+/        matches a string that has ab followed by one or more "c"
/abc?/        matches a string that has ab followed by zero or one "c"
/abc{2}/      matches a string that has ab followed by 2 "c"
/abc{2,}/     matches a string that has ab followed by 2 or more "c"
/abc{2,5}/    matches a string that has ab followed by 2 up to 5 "c"
/a(bc)*/      matches a string that has a followed by zero or more copies of the sequence "bc"
/a(bc){2,5}/  matches a string that has a followed by 2 up to 5 copies of the sequence "bc"

${E_WHITE_FG}OR operator — | or []${E_RESET}

/a(b|c)/     matches a string that has "a" followed by "b" or "c" (and captures "b" or "c")  
/a[bc]/      same as previous, but without capturing "b" or "c"

${E_WHITE_FG}Character classes — \d \w \s and .${E_RESET}

/\d/         matches a single character that is a digit  
/\w/         matches a word character (alphanumeric character plus underscore)  
/\s/         matches a whitespace character (includes tabs and line breaks)
/./          matches any character  

Use the . operator carefully since often class or negated character class (which we’ll cover next) 
are faster and more precise.

\d, \w and \s also present their negations with \D, \W and \S respectively.

For example, \D will perform the inverse match with respect to that obtained with \d.

/\D/         matches a single non-digit character  

In order to be taken literally, you must escape the characters "^.[$()|*+?{\" with
a backslash "\" as they have special meaning.

/\$\d/       matches a string that has a "$" before one digit  

Notice that you can match also non-printable characters like tabs \t, new-lines \n, 
carriage returns \r.

${E_WHITE_FG}Flags${E_RESET}

We are learning how to construct a regex but forgetting a fundamental concept: flags.

A regex usually comes within this form /abc/, where the search pattern is delimited 
by two slash characters /.  At the end we can specify a flag with these values 
(we can also combine them each other): g (global) does not return after the first match, 
restarting the subsequent searches from the end of the previous match

m (multi-line) when enabled ^ and $ will match the start and end of a line, instead of the whole string

i (insensitive) makes the whole expression case-insensitive (for instance /aBc/i would match AbC)

${E_WHITE_FG}Intermediate topics${E_RESET}

${E_WHITE_FG}Grouping and capturing — ()${E_RESET}

/a(bc)/           parentheses create a capturing group with value "bc"
/a(?:bc)*/        using ?: we disable the capturing group  
/a(?<foo>bc)/     using ?<foo> we put a name to the group  

This operator is very useful when we need to extract information from strings or data using your preferred 
programming language. Any multiple occurrences captured by several groups will be exposed in the form of a 
classical array: we will access their values specifying using an index on the result of the match.

If we choose to put a name to the groups (using (?<foo>...)) we will be able to retrieve the group values 
using the match result like a dictionary where the keys will be the name of each group.

${E_WHITE_FG}Bracket expressions — []${E_RESET}

/[abc]/           matches a string that has either an "a" or "a b" or "a c"  is the same as a|b|c  
/[a-c]/           same as previous
/[a-fA-F0-9]/     a string that represents a single hexadecimal digit, case insensitively  
/[0-9]%/          a string that has a character from 0 to 9 before a "%" sign
/[^a-zA-Z]/       a string that has not a letter from a to z or from A to Z. In this case the ^ is 
                  used as negation of the expression  

${E_WHITE_FG}Greedy and Lazy match${E_RESET}

The quantifiers ( * + {}) are greedy operators, so they expand the match as far as they can through 
the provided text.

For example, /<.+>/ matches "<div>simple div</div>" in This is a <div> simple div</div> test. In order 
to catch only the div tag we can use a ? to make it lazy:

/<.+?>/          matches any character one or more times included inside < and >, expanding as needed  

Notice that a better solution should avoid the usage of . in favor of a more strict regex:

/<[^<>]+>/       matches any character except < or > one or more times included inside < and >  

${E_WHITE_FG}Advanced topics${E_RESET}

${E_WHITE_FG}Boundaries — \b and \B${E_RESET}

/\babc\b/        performs a "whole words only" search  

\b represents an anchor like caret (it is similar to $ and ^) matching positions where one side is a 
word character (like \w) and the other side is not a word character (for instance it may be the 
beginning of the string or a space character).

It comes with its negation, \B. This matches all positions where \b doesn’t match and could be if we 
want to find a search pattern fully surrounded by word characters.

/\Babc\B/        matches only if the pattern is fully surrounded by word characters  

${E_WHITE_FG}Back-references — \1${E_RESET}

/([abc])\1/              using \1 it matches the same text that was matched by the first capturing group  

/([abc])([de])\2\1/      we can use \2 (\3, \4, etc.) to identify the same text that was matched by the 
                         second (third, fourth, etc.) capturing group  

/(?<foo>[abc])\k<foo>/   we put the name foo to the group and we reference it later (\k<foo>). 
                         The result is the same of the first regex  

${E_WHITE_FG}Look-ahead and Look-behind — (?=) and (?<=)${E_RESET}

/d(?=r)/       matches a "d" only if is followed by "r", but "r" will not be part of the overall regex match  
/(?<=r)d/      matches a "d" only if is preceded by an "r", but "r" will not be part of the overall regex match  

${E_WHITE_FG}You can use also the negation operator!${E_RESET}

/d(?!r)/       matches a "d" only if is not followed by "r", but "r" will not be part of the overall regex match  
/(?<!r)d/      matches a "d" only if is not preceded by an "r", but "r" will not be part of the overall regex match  

${E_WHITE_FG}Summary${E_RESET}

As you’ve seen, the application fields of regex can be multiple and I’m sure that you’ve recognized at least one of 
these tasks among those seen in your developer career, here a quick list:

data validation (for example check if a time string i well-formed)

data scraping (especially web scraping, find all pages that contain a certain set of words eventually in a 
specific order)

data wrangling (transform data from “raw” to another format)

string parsing (for example catch all URL GET parameters, capture text inside a set of parenthesis)

string replacement (for example, even during a code session using a common IDE to translate a Java or C# class 
in the respective JSON object — replace “;” with “,” make it lowercase, avoid type declaration, etc.)

syntax highlightning, file renaming, packet sniffing and many other applications involving strings 
(where data need not be textual)
tip_regex_EOF_3
) | mypager
