(
echo ${E_BOLD}${E_WHITE_FG}${(C)${0/tip_/}:t:r} Tips${E_RESET}
cat << tip_vim_map_EOF


${E_WHITE_FG}Mapping keys in Vim - Tutorial${E_RESET}

Introduction Key mapping refers to creating a shortcut for repeating a sequence of keys or commands. You can map keys to
execute frequently used key sequences or to invoke an Ex command or to invoke a Vim function or to invoke external
commands. Using key maps you can define your own Vim commands.

Vim supports several editing modes - normal, insert, replace, visual, select, command-line and operator-pending. You can
map a key to work in all or some of these modes.

         ${E_WHITE_FG}Command Mode${E_RESET}:Vim starts in Command Mode (navigate, delete, yank, paste, etc. in document)
          ${E_WHITE_FG}Insert Mode${E_RESET}:Enter (i,o,I,O, etc.) you're in INSERT mode. Esc returns to Command mode
          ${E_WHITE_FG}Visual Mode${E_RESET}:Enter ('v', V, Ctrl-v) enters visual, v-line, or v-block mode. Text is highlighted and treated as a unit
          ${E_WHITE_FG}Select Mode${E_RESET}:Enter (gh, gH, g_Ctrl-H) like Visual Mode but with different commands resembling MS Windows. Largely unused.
    ${E_WHITE_FG}Command-line Mode${E_RESET}:set -o vi, the vim CLI to manipulate the unix command line
${E_WHITE_FG}Operator-Pending Mode${E_RESET}:key mapping specific to map a key to a text object. :h text-object for defined objects


The general syntax of a map command is:

${E_WHITE_FG}{cmd} {attr} {lhs} {rhs}${E_RESET}

where 
     {cmd}  is one of ':map' , ':map!' , ':cmap' , ':imap' , ':lmap' , ':nmap' , ':omap' , ':smap' , ':vmap' , ':xmap' , etc.

        map - normal, visual and select and operator pending mode
       map! - insert and command-line mode
       cmap - command-line mode
       imap - insert mode
       nmap - normal mode
       omap - operator pending mode
       smap - select mode
       vmap - visual and select mode
       xmap - visual mode

     {attr} is optional and one or more of the following: <buffer>, <silent>,<expr> <script>, <unique> and <special>.  
            More than one attribute can be specified to a map.  

    <buffer>  applicable only to buffers
    <silent>  silently execute
      <expr>  invoke a function; use return val
    <script>  use recursive maps in your map command, only keys mapped in your script or plugin
    <unique>  useful with the maps defined by a Vim plugin, will fail if the specified key is already mapped
   <special>  in insert mode, pressing <F7> will insert the characters <F7>, to prevent use <special>

        {lhs} left hand side, a sequence of keys that you will use in your shortcut  
        {rhs} right hand side, a sequence of keys that the shortcut will execute

${E_CYAN_FG}Examples${E_RESET}:

map <F2> :echo 'Current time is ' . strftime('%c')<CR> 
map! <F3> <C-R>=strftime('%c')<CR> 
nnoremap <silent> <F2> :lchdir %:p:h<CR>:pwd<CR> 

The first step in creating a map is to ${E_BOLD}${E_ITALIC}decide the sequence of keys${E_RESET} the mapping will run. When you
invoke a map, Vim will execute the sequence of keys as though you entered it from the keyboard. You can test the keys
for your mapping by manually entering the key sequence and verifying that it performs the desired operation.  

The second step is to ${E_BOLD}${E_ITALIC}decide the editing mode${E_RESET} (insert mode, visual mode, command-line mode, normal mode, etc.) in which the map
should work. Instead of creating a map that works in all the modes, it is better to define the map that works only in
selected modes.  

The third step is to ${E_BOLD}${E_ITALIC}find an unused key sequence${E_RESET} that can be used to invoke the map. You can invoke a
map using either a single key or a sequence of keys. :help map-which-keys The above steps are explained in more detail
in the following sections.

${E_WHITE_FG}Creating Keymaps${E_RESET}
${E_WHITE_FG}----------------${E_RESET}
To map a sequence of keys to execute another sequence of keys, use the ':map' command.

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following command maps the <F2> key to display the current date and time.

:map <F2> :echo 'Current time is ' . strftime('%c')<CR> 

The following command maps the <F3> key to insert the current date and time in the current buffer:

:map! <F3> <C-R>=strftime('%c')<CR> 

The ':map' command creates a key map that works in normal, visual, select and operator pending modes. The ':map!'
command creates a key map that works in insert and command-line mode.

A better alternative than using the 'map' and 'map!' commands is to use mode-specific map commands which are described
in later sections.

${E_WHITE_FG}Storing the key maps${E_RESET}
${E_WHITE_FG}--------------------${E_RESET}
If you want to map a key for only one Vim session temporarily, then you don't need to save the map
command in a file. When you quit that Vim instance, the temporary map definition will be lost.

If you want to restore the key maps across Vim instances, you need to save the map definition command in a file.

One place to store the map commands is the \${HOME}/.vimrc or \${HOME}/_vimrc or \${VIM}/_vimrc file. If you have filetype
specific key maps, then you can store them in the filetype specific plugin files. The key maps defined by Vim plugins
are stored in the plugin or script file itself.

When adding the map commands to a file, there is no need to prefix the commands with the ':' character.

${E_WHITE_FG}Listing Key Maps${E_RESET}
${E_WHITE_FG}----------------${E_RESET}
You can display a list of existing key maps using the following commands without any arguments:

:map :map!  The first command displays the maps that work in normal, visual and select and operator pending mode. The
second command displays the maps that work in insert and command-line mode.

To display the mode specific maps, prefix the ':map' command with the letter representing the mode.

:nmap - Display normal mode maps 
:imap - Display insert mode maps 
:vmap - Display visual and select mode maps 
:smap - Display select mode maps 
:xmap - Display visual mode maps 
:cmap - Display command-line mode maps 
:omap - Display operator pending mode maps 

${E_CYAN_FG}Example${E_RESET}:

:nmap n  <C-W>*      * <C-W><C-S>* n  <C-W>#      * <C-W><C-S># n  <F2>        * :lchdir %:p:h<CR>:pwd<CR> 

In the output of the above commands, the first column indicates the mode in which the map works. You can interpret the
first column character using the following table:

n       Normal mode map. Defined using ':nmap' or ':nnoremap'.  
i       Insert mode map. Defined using ':imap' or ':inoremap'.  
v       Visual and select mode map. Defined using ':vmap' or ':vnoremap'.  
x       Visual mode map. Defined using ':xmap' or ':xnoremap'.  
s       Select mode map. Defined using ':smap' or ':snoremap'.  
c       Command-line mode map. Defined using ':cmap' or ':cnoremap'.  
o       Operator pending mode map. Defined using ':omap' or ':onoremap'.
<Space> Normal, Visual and operator pending mode map. Defined using ':map' or ':noremap'.  
!       Insert and command-line mode map. Defined using 'map!' or 'noremap!'.  

The following characters may be displayed before the {rhs} of the map:

*  The {rhs} of the map is not re-mappable. Defined using the ':noremap' or ':nnoremap' or ':inoremap', etc. commands.
&  Only script local mappings are re-mappable in the {rhs} of the map. The map command has the <script> attribute.  
@  A buffer local map command with the <buffer> attribute.  

To display all the key maps that start with a particular key sequence, enter the key sequence in the above commands. For
example, the following command displays all the normal mode maps that start with 'g'.

:nmap g 

To display all the buffer-local maps for the current buffer, use the following commands:

:map <buffer> :map! <buffer> 

Typically the output of the above commands will span several pages. You can use the following set of commands to
redirect the output to the vim_maps.txt file:

:redir! > vim_maps.txt :map :map!  :redir END

${E_WHITE_FG}Removing A Keymap${E_RESET}
${E_WHITE_FG}-----------------${E_RESET}
To permanently remove a map, you first need to locate the place where it is defined by using the ':verbose map {lhs}'
command (replace {lhs} with the mapped key sequence). If the map is defined in the .vimrc or _vimrc file or in one of
the files in the vimfiles or .vim directory, then you can edit the file to remove the map.

Another approach is to use the ':unmap' and ':unmap!' commands to remove the map. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, to remove the map for the <F8> key, you can use the following commands:

:unmap <F8> :unmap! <F8> 

Note that after a key is unmapped using the ':unmap' command, it can be mapped again later.
Also you cannot unmap a key used by one of the Vim internal commands. Instead you have to map it to <Nop> to disable its
functionality. If you are trying to disable a key map defined by a plugin, make sure the unmap command is executed after
the key map is defined by the plugin. To do this in .vimrc, use autocmd:

autocmd VimEnter * unmap! <F8> 

Filetype plugins can be a little tricky, because they can redefine mappings any time you open a file of a certain type.
You can just use a different autocmd event for this, e.g.:

autocmd FileType python unmap! <F8> Or, you can place the unmap command in the appropriate after directory. :help
after-directory.

You can remove a mode-specific map by using the mode specific unmap command. The mode-specific unmap commands are listed
below:

nunmap - Unmap a normal mode map 
vunmap - Unmap a visual and select mode map 
xunmap - Unmap a visual mode map 
sunmap - Unmap a select mode map 
iunmap - Unmap an insert and replace mode map 
cunmap - Unmap a command-line mode map 
ounmap - Unmap an operator pending mode map 

Note that in the above unmap commands, if a space character is present at the end of the unmapped key sequence, then the
command will fail. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following unmap command will fail (replace <Space> with a space character):

:nnoremap <F2> :ls<CR> :nunmap <F2><Space> 

To map a key in only a selected set of modes, you can use the ':map' and ':map!' commands and then unmap them using the
mode specific unmap commands in a few modes. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, to map a key in normal and visual mode but not in operator-pending mode, you can use the following commands:

:map <F6> ....  :ounmap <F6> 

To clear all the mappings for a particular mode, you can use the ':mapclear' command. The mode-specific map clear
commands are listed below:

mapclear  - Clear all normal, visual, select and operating pending mode maps 
mapclear! - Clear all insert and command-line mode maps 
nmapclear - Clear all normal mode maps vmapclear - Clear all visual and select mode maps
xmapclear - Clear all visual mode maps smapclear - Clear all select mode maps 
imapclear - Clear all insert mode maps
cmapclear - Clear all command-line mode maps 
omapclear - Clear all operating pending mode maps Mode-specific maps 

Vim supports creating keymaps that work only in specific editing modes. You can create keymaps that work only in normal,
insert, visual, select, command and operator pending modes. The following table lists the various map commands and their
corresponding editing mode:

Commands                Mode 
nmap, nnoremap, nunmap  Normal mode 
imap, inoremap, iunmap  Insert and Replace mode 
vmap, vnoremap, vunmap  Visual and Select mode 
xmap, xnoremap, xunmap  Visual mode 
smap, snoremap, sunmap  Select mode 
cmap, cnoremap, cunmap  Command-line mode 
omap, onoremap, ounmap  Operator pending mode 

Note that the language specific mappings defined using the ':lmap' and ':lnoremap' commands are not discussed here. For
more information about this refer to the Vim help.

Normal mode maps To map keys that work only in the normal mode, use the ':nmap' or ':nnoremap' command. The 'n' in
':nmap' and ':nnoremap' denotes normal mode.

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following command maps the <F5> key to search for the keyword under the cursor in the current directory
using the 'grep' command:

:nnoremap <F5> :grep <C-R><C-W> *<CR>

${E_CYAN_FG}Examples${E_RESET}:

The following commands map the 'j' key to execute 'gj' and the 'k' key to execute 'gk'. These are useful for moving
between long wrapped lines.

:nnoremap k gk 
:nnoremap j gj 

The following command maps ',b' to display the buffer list and invoke the ':buffer'
command. You can enter the desired buffer number and hit <Enter> to edit the buffer.

:nnoremap ,b :ls<CR>:buffer<Space> 

In the above command, you can enter <Space> at the end of the map command either literally or by pressing the space bar.

To display the currently defined normal mode maps, use the ':nmap' command without any argument:

:nmap 

To remove a keymap from normal mode, use the ':nunmap' command.  

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following command removes the map for the <F9> key from normal mode:

:nunmap <F9> 

If you invoke an Ex command from a map, you have to add a <CR> or <Enter> or <Return> at the end of the Ex
command to execute the command. Otherwise the command will not be executed.  

${E_BOLD}${E_ITALIC}For example${E_RESET}:

:nnoremap <F3> :ls 

With the above map, if you use <F3> in normal mode, you will be left in the ':' command-line after
the text 'ls'. To execute the command, you have to use <CR> at the end of the command:

:nnoremap <F3> :ls<CR> 

Now, when you press <F3>, the 'ls' Ex command will be executed.

From a normal mode map, you can get the keyword under the cursor using the expand('<cword>') function or using the
<C-R><C-W> command.  

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following two map commands provide the same functionality:

:nnoremap ,s :exe 'grep ' . expand('<cword>') . ' *'<CR> 
:nnoremap ,s :grep <C-R><C-W> *<CR> 

Insert mode maps To map keys that work only in the insert and replace modes, use the 'imap' or 'inoremap' command.

${E_CYAN_FG}Example${E_RESET}: The following command maps <F2> to insert the directory name of the current buffer:

:inoremap <F2> <C-R>=expand('%:p:h')<CR> 

To display the currently defined insert mode maps, use the 'imap' command without any argument:

:imap 

To remove a keymap from insert mode, use the ':iunmap' command. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following command removes the insert mode map for <F2>.

:iunmap <F2> 

As printable keys insert a character in the current buffer in insert mode, you should use non-printable keys to create
insert mode maps. Some examples for non-printable keys include the function keys <F2>, keys prefixed with the Ctrl or
Alt key.

Alternatively, you can map keys that you're just not likely to need to insert, such as two capital letters in a row.
This can be an attractive option for quick insert-mode access to common normal-mode commands.

To execute Vim normal mode commands from an insert mode map, you have to go from insert mode to normal mode. But after
executing the map, you may want to restore the mode back to insert mode. To do this, you can use the <CTRL-O>
insert-mode key which temporarily goes to normal-mode for one normal mode command and then comes back to insert mode.

${E_BOLD}${E_ITALIC}For example${E_RESET}, to call the Vim function MyVimFunc() from insert mode, you can use the following map command:

:inoremap <F5> <C-O>:call MyVimFunc()<CR> 

One caveat with using the <C-O> command is that if the cursor is after the last character in a line in insert mode, then
<C-O> moves the cursor one character to the left after executing the map.  If you don't want this, then you can use the
<C-\><C-O> command, which doesn't move the cursor. But now the cursor may be placed on a character beyond the end of a
line. The above map command is modified to use the <C-\><C-O> key:

:inoremap <F5> <C-\><C-O>:call MyVimFunc()<CR> 

Both the <C-O> and <C-\><C-O> commands create a new undo point, i.e. you can undo the text inserted before and after
typing these commands separately.

Another alternative for going from insert mode to normal mode is to use the <Esc> key. But it is preferable to use the
<C-O> or <C-\><C-O> command for this.

If you press <Esc> in normal mode to make sure you are in normal mode, then you will hear the error beep sound. Instead,
you can use the CTRL-\ CTRL-N command to go to normal mode. If you are already in normal mode, this command will not
result in the error bell. This command can be used from a map to go to normal mode.

After executing the normal mode commands from an insert mode map, if the cursor position was moved by the map and no new
text was inserted by the commands invoked, then you can use the gi command to restart the insert mode from the previous
position where the insert mode was last stopped.

You can insert the result of a Vim expression in insert mode using the <C-R>= command. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following command creates an insert mode map command that inserts the current directory:

:inoremap <F2> <C-R>=expand('%:p:h')<CR> 

If you don't want to insert anything then you can return an empty string from the expression. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, you can invoke a function from the insert mode map to perform some operation but return
an empty string from the function.

The <C-R>= command doesn't create a new undo point. You can also call Vim functions using the <C-R>= command:

:inoremap <F2> <C-R>=MyVimFunc()<CR> 

If the return value of MyVimFunc() is to be ignored and not entered after its call, a ternary operator trick may be
used:

:inoremap <F2> <C-R>=MyVimFunc()?'':''<CR> 

This will return an empty string, independent of what MyVimFunc() returns.

When Vim parses a string in a map command, the \<...> sequence of characters is replaced by the corresponding control
character. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, let us say in insert mode you want the down arrow key to execute <C-N> when the insert complete
popup menu is displayed. Otherwise, you want the down arrow key to move the cursor one line down. You can try the
following command (which doesn't work):

:inoremap <Down> <C-R>=pumvisible() ? '\<C-N>' : '\<Down>'<CR> 

When parsing the above command, Vim replaces <C-N> and <Down> with the corresponding control characters. When you press
the down arrow in insert mode, as there are control characters in the expression now, the command will fail.

To fix this, you should escape the '<' character, so that Vim will not replace '\<C-N>' with the control character when
parsing the command. The following command works:

:inoremap <Down> <C-R>=pumvisible() ? '\<lt>C-N>' : '\<lt>Down>'<CR> 

With the above command, Vim will use the control character only when the map is invoked and not when the above command
is parsed.

To insert a template you should use a Vim abbreviation instead of a insert mode map. For more information about
abbreviations refer to the Vim help.

Note that if the 'paste' option is set, then insert mode maps are disabled.

${E_WHITE_FG}Visual Mode Maps${E_RESET}
${E_WHITE_FG}----------------${E_RESET}
To map keys that work only in visual mode, use the ':vmap' or ':vnoremap' commands. These maps are invoked when you
press the mapped keys after visually selecting a range of characters.

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following command maps the g/ key sequence to search for the visually selected sequence of characters:

:vnoremap g/ y/<C-R>"<CR> 

Another visual mode map example to add single quotes around a selected block of text:

:vnoremap qq <Esc>'>a'<Esc>'<i'<Esc> 

To display all the currently defined visual mode maps, use the ':vmap' command without any arguments:

:vmap 

To remove a visual mode map, use the ":vunmap" command. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following command removes the visual mode map for g/:

:vunmap g/ 

From a visual mode map, you can either perform a text editing operation on the selected characters or add/remove
characters at the beginning and/or end of the selected region or pass the selected text to some other internal/external
command.

The '< Vim mark represents the first line of a visual region and the '> mark represents the last line of the visual
region. The similar '< mark represents the beginning character position of the visual region and the '> mark represents
the ending character position of the visual region. You can use these marks in your map to perform operation at the
beginning and end of the visual region. If the map is invoked from visual mode, then these marks will refer to the
beginning and end of the previous selection and not to the current selected region.

If you want to use the visually selected text in your map, then you can yank the text and then use it in your map. You
can either yank the text to a register or use the unnamed (") register. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following command maps the g/ key sequence to search for the visually selected text:

:vnoremap g/ y/<C-R>"<CR> 

Another approach is to use the above described marks and get the text in the region from the buffer using the getline()
function.

To execute an Ex command from a visual mode map, you have to first enter the command-line mode using the ':' character.

After visually selecting a sequence of characters, when you press ':' to execute a Vim Ex command, Vim automatically
inserts the visual block begin ('<') and end ('>') marks. 

If you invoke an Ex command with this range, then the command is executed for every line in this range. This may be
undesirable. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, if you invoke a Vim function, then the function will be executed separately for each line in
the range (unless the function is defined with the '-range' attribute). 

To remove the visual block start and end marks, use the <C-U> command, which removes all the characters between the
start of the line and the current cursor position, at the beginning of your map. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, 

:vnoremap <F2> :<C-U>call MyVimFunc()<CR> 

When you enter a mapped key sequence in character-wise or line-wise or block-wise visual mode, the same visual map is
invoked. You can use the visualmode() function in your map to differentiate between these modes. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following code maps the <F5> keys in visual mode to invoke the MyFunc() function. The MyFunc() function
uses the visualmode() function to distinguish between the visual modes.  

vnoremap <silent> <F5> :<C-U>call MyFunc()<CR> 

function! MyFunc() 
	let m = visualmode() 
	if m ==# 'v' 
		echo 'character-wise visual' 
	elseif m == 'V' 
		echo 'line-wise visual' 
	elseif m == "\<C-V>" 
		echo 'block-wise visual' 
	endif 
endfunction 

Note that we use ==# for the initial comparison instead of ==. This is because ==# will always make a case-sensitive
comparison, whereas == will consider 'v' and 'V' to be the same if the ignorecase option has been set.

When you enter the command mode using ':' in visual mode, the visual mode is stopped. If you want to re-enter the visual
mode from a function invoked from a map, you can use the gv command:

vnoremap <silent> <F5> :<C-U>call MyFunc()<CR> 

function! MyFunc() 
	normal! gv 
endfunction 

The maps created with the ":vmap" and ":vnoremap" commands work in both Visual mode and Select mode. When a map is
invoked in select mode, Vim temporarily switches to visual mode before executing the map and at the end of the map,
switches back to select mode. So the map behaves the same in visual and select mode.

To create a map that works only in Visual mode and not in Select mode use the ":xmap" and ":xnoremap" commands. All the
other descriptions for the ":vmap" and ":vnoremap" commands also apply to the ":xmap" and ":xnoremap" commands.

To create a map that works only in Select mode and not in Visual mode use the ":smap" and ":snoremap" commands.

${E_WHITE_FG}Command-line Mode Map${E_RESET}
${E_WHITE_FG}----------------------${E_RESET}
To map keys to work only in the command-line mode, use the "cmap" or ":cnoremap" commands.

The command-line mode map works in the following command prompts:

:    Ex command prompt /    Forward search prompt ?    Backward search prompt
>    Debug prompt
@    input() prompt
-    :insert and :append prompts.  You can distinguish between the above prompts using the getcmdtype() function in your map. 

${E_CYAN_FG}Example${E_RESET}:

:cnoremap <F8> <C-R>=MyFunc()<CR> 

function! MyFunc() 
	let cmdtype = getcmdtype() 
	if cmdtype == ':' 
		" Perform Ex command map action 
	elseif cmdtype == '/' || cmdtype == '?' 
		" Perform search prompt map action 
	elseif cmdtype == '@' 
		" Perform input() prompt map action 
	else 
		" Perform other command-line prompt action 
	endif 
endfunction 

To invoke functions from a command-line map, you have to use the '<C-R>=' command or the 'CTRL-\ e' command. An example
map that shows this is below:

:cnoremap <C-F6> <C-R>=Somefunc()<CR> :cnoremap <C-F6> <C-\>eSomefunc()<CR> 

The <C-R>= command inserts the value returned by the invoked function at the current location in the command-line. The
<C-\>e command replaces the entire command-line with the value returned by the invoked function.

The <C-R>= and <C-\>e commands cannot be used in the prompt for getting an expression (represented by =). 

${E_BOLD}${E_ITALIC}For example${E_RESET}, to insert the value of the Vim variable 'abc' in the command line, you can use <C-R>=abc<CR> command. In
the prompt where you enter the variable name, you cannot again use <C-R>= and <C-\>e. To do this use the <expr>
attribute to the map command as explained below.

Another way to invoke a function from a command-line mode map is to use the <expr> attribute as shown below:

:cnoremap <expr> <C-F6> Cmdfunc() 

Using the above map, the value returned by Cmdfunc() is inserted at the current location in the command-line.

In the function invoked by the <C-R>= and <C-\>e commands and <expr> attribute, you can use the 
	getcmdpos() function to get the current position of the cursor in the command. You can use the 
	setcmdpos() function to change the location of the cursor in the command-line. You can use the 
	getcmdline() function to get the current command-line.

It is preferable to use a non-printable control character for invoking a command-line mode map. Otherwise, the map may
interfere with the printable characters used in the Vim Ex commands.

Note that if the 'paste' option is set, then command-line mode maps are disabled.

${E_WHITE_FG}Operator pending mode maps${E_RESET}
${E_WHITE_FG}--------------------------${E_RESET}
You can create maps that work only when waiting for a motion command from an operator
command. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the yank command 'y' yanks the text that is selected by the motion that follows the command. To
yank the current line and the two following lines of text, you can use the command 'y2j'. After pressing 'y', Vim waits
for you to enter the motion command. The operator pending maps can be used here. The operator pending mode maps can be
used to define your own text objects.

Operator pending commands are defined using the ":omap" and ":onoremap" commands.

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following command creates an operator pending map for <F6> to select the current inner block defined by
"{" and "}".

:onoremap <F6> iB 

You can now yank an inner block using the y<F6> command, delete an inner block using the d<F6> command, etc.

To change the starting location of the operator from a operator-pending mode map, you can start visual mode and select
the desired range of characters. One disadvantage in starting visual mode is that the previous visual region will be
lost.  

${E_WHITE_FG}Mapping Mouse Event${E_RESET}
${E_WHITE_FG}--------------------${E_RESET}
You can map mouse events similar to mapping keys to perform some action. The following mouse events can be mapped:

<LeftMouse>     - Left mouse button press 
<RightMouse>    - Right mouse button press 
<MiddleMouse>   - Middle mouse button press 
<LeftRelease>   - Left mouse button release 
<RightRelease>  - Right mouse button release 
<MiddleRelease> - Middle mouse button release 
<LeftDrag>      - Mouse drag while Left mouse button is pressed 
<RightDrag>     - Mouse drag while Right mouse button is pressed 
<MiddleDrag>    - Mouse drag while Middle mouse button is pressed 
<2-LeftMouse>   - Left mouse button double-click 
<2-RightMouse>  - Right mouse button double-click 
<3-LeftMouse>   - Left mouse button triple-click 
<3-RightMouse>  - Right mouse button triple-click 
<4-LeftMouse>   - Left mouse button quadruple-click
<4-RightMouse>  - Right mouse button quadruple-click 
<X1Mouse>       - X1 button press 
<X2Mouse>       - X2 button press
<X1Release>     - X1 button release 
<X2Release>     - X2 button release 
<X1Drag>        - Mouse drag while X1 button is pressed 
<X2Drag>        - Mouse drag while X2 button is pressed Few examples for mapping the above mouse events is given below.

To jump to the tag under the cursor when the tag is double clicked, you can use the following map:

:nnoremap <2-LeftMouse> :exe "tag ". expand("<cword>")<CR> 

The above map uses the expand() function to get the keyword under the cursor and then invokes the "tag" command with the
current keyword. The "execute" command is used to concatenate the tag command and the output of the expand() function.

To map the X1 and X2 buttons to go forward and backward in the jump list, you can use the following map:

:nnoremap <X1Mouse> <C-O> :nnoremap <X2Mouse> <C-I> 

The above maps use the <C-O> and <C-I> normal mode commands to walk the jump list.

When you paste text using the middle mouse button, the text is pasted at the current cursor position. To paste at the
position of the middle mouse button click, you can use the following map:

:nnoremap <MiddleMouse> <LeftMouse><MiddleMouse> 

The above map first moves the cursor to the point where the click is made and then invokes the <MiddleMouse> functionality.

If you create a map for one of these mouse events, it overrides the internal default handling of that event by Vim. To
pass the event to Vim, so that the default handling is also done, you can use "nnoremap" and specify the event in the
{rhs} of the map. 

${E_BOLD}${E_ITALIC}For example${E_RESET},

:nnoremap <LeftRelease> <LeftRelease>:call MyFunc()<CR> 

With the above map, when the Left mouse button is pressed, the cursor is moved to that location and then the function
MyFunc() is called.

You can disable a mouse event, by mapping it to <Nop> If you have a scrollwheel and often accidentally paste text when
scrolling text, you can use the following mappings to disable the pasting with the middle mouse button:

:nnoremap <MiddleMouse> <Nop> :inoremap <MiddleMouse> <Nop>

${E_WHITE_FG}Nested (recursive) Maps${E_RESET}
${E_WHITE_FG}-----------------------${E_RESET}
When executing a mapped key sequence, if the {lhs} is not a prefix of the {rhs}, then Vim scans
and recursively replaces any mapped keys in the {rhs} of the map. This allows you to define nested and recursive
mappings. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, consider the following set of commands:

:map <F2>  :echo 'Current time = ' . strftime('%c')<CR> 
:map <F3> <F2> 

When you press <F3>, Vim executes the mapped key sequence for <F2> and displays the current time.

Note that Vim recursively checks for mappings on the {rhs} of a map when executing the map and not when defining the
map. In the above example, if you redefine the map for <F2> later, then <F3> will execute the new map for <F2>.

If you include the {lhs} of a map in the {rhs}, then you will create an infinitely recursive key map. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following insert mode map command creates an infinitely recursive map:

:imap ab xyzab 

With the above map, when you enter "ab" in insert mode, it is replaced with "xyz" followed by "ab" which
is replaced by "xyz" and so on. You can interrupt the recursive map by pressing CTRL-C.

Vim will recursively replace the mapped key sequence in the {rhs} of a map till it encounters an error. This can be used
to create a recursive map that stops on error. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following command creates a map for \s to replace "emacs" with "vi" in all the files
in the argument list:

:nmap \s  :%s/emacs/vi/g \| update \| n<CR>\s 

The "\s" at the end of the {rhs} in the map creates a recursive map. The recursive map will stop when it reaches the
last file in the argument list as the "n" command will fail.

If the {rhs} of a map begins with the {lhs}, then it is not recursively replaced. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following command will not create a recursive map for x:

:nmap x xyz 

If you want to invoke other maps from your map, then define your maps using the ":map", ":map!", ":nmap",
":imap", ":vmap", ":cmap", ":xmap", ":smap" and ":omap" commands.

To prevent Vim from recursively replacing the mapped keys in the {rhs} of map, you can set the 'noremap' option. But
instead of setting this option, it is preferable to use the 'noremap' command.

You can use the 'noremap' command to execute the {rhs} of a map literally without any map substitutions. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, consider the following command which visually selects the current paragraph:

:map <F2> vip 

If a map is defined for any character sequence in the {rhs}, then the above command will break. For
example, consider the following map command which maps 'vi' to invoke 'gg':

:map vi gg 

When you invoke <F2>, "vi" in the {rhs} will be replaced with "gg" resulting in an unexpected result. To prevent this
from happening, you can use the following map command:

:noremap <F2> vip 

Vim has the "noremap" version of the map command for all the mode specific map commands. 
You can use "nnoremap", "inoremap", "cnoremap", "vnoremap", "snoremap", "xnoremap" and "onoremap". In most of the map
commands, it is better to use the "noremap" version of the command to prevent unexpected behavior.

When a key sequence which is mapped using "noremap" is entered at the end of an abbreviation, the abbreviation will not
be expanded. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following command creates an insert mode abbreviation for "vi":

:iabbr vi Vi Improved

In insert mode, when you enter "vi" followed by a space or Enter or some other control character, it is
replaced with "Vi Improved". If you have the following map command for the <Enter> key:

:inoremap <Enter> <Enter><C-G>u 

Now, if you press <Enter> after entering "vi", it will not be expanded to "Vi Improved".  You can expand the
abbreviation by pressing <Space> or by entering Ctrl-].

${E_MAGENTA_FG}Further information: ${E_RESET}

${E_WHITE_FG}Unused Keys${E_RESET}
${E_WHITE_FG}-----------${E_RESET}
In your private maps you should use key sequences that are not used by Vim and by other Vim plugins. 

Finding unused keys :help map-which-keys

Many of the key sequences that you can enter from the keyboard are used by Vim to implement the various internal
commands. If you use a key sequence in your map that is already used by Vim, then you will not be able to use the
functionality provided by Vim for that key sequence. To get a list of the key sequences used by Vim, read the following
help topic:

:help index.txt (File: /usr/share/vim/vim90/doc/index.txt)

If you don't use some Vim functionality invoked by a particular key sequence or you have an alternate key sequence to
use that functionality then you can use that key sequence in your maps.

Some of the key sequences may be used by the existing Vim scripts and plugins. 

To display the list of keys that are currently mapped, use the following commands:

	:map :map!  

To determine the script or plugin that defines a map for a key sequence, use the following command.

	:verbose map <key> 

In the above command, replace <key> with the desired key sequence. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, to list all the locations where maps beginning with "," are defined, use the following command:

	:verbose map , 

Try to use an unused key sequence in your maps. Typically, the <F2>, <F3>, ... etc function keys are unused. The
function keys in combination with Control, Alt and Shift can also be used. But some of the key combinations may not work
in all the terminal emulators. Most of the key combinations should work in GUI Vim.

You can also prefix the desired key sequence with a backslash (\) or comma (,) or underscore (_), etc. and use that in
your maps.

Note that you cannot map the Shift or Alt or Ctrl keys alone as they are key modifiers. You have to combine these key
modifiers with other keys to create a map.

You should not use a frequently used Vim key sequence at the start of your maps. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, you should not start your normal mode map key sequence with "j" or "k" or "l" or "h".
These keys are used for moving the cursor in normal mode. If you use any of these keys at the beginning of your maps,
then you will observe a delay when you enter a single "j" or "k" or "l" or "h".

${E_WHITE_FG}Key notation${E_RESET}
${E_WHITE_FG}------------${E_RESET}
When defining a map command, you can enter printable characters like 'a', 'V', etc. literally. You can
enter non-printable control characters (like Ctrl-G, Alt-U, Ctrl-Shift-F2, F2, etc.) in several different ways.

You can enter a non-printable control character in a map command by preceding it with CTRL-V. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, to map the Ctrl-K key to display the buffer list, you can use the following map command:

:map <press Ctrl-V><press Ctrl-K> :ls<press Ctrl-V><press Enter> 

The Ctrl-V key sequence is used to escape the following control character.

The following table shows the mapping between some of the keys on the keyboard and the equivalent Ctrl-key combination:

Ctrl-I      Tab 
Ctrl-[      Esc 
Ctrl-M      Enter 
Ctrl-H      Backspace 

If you use one of the Ctrl-key combination in the above table in a map, the map also applies to the corresponding key.

Both the keys produce the same key scan code.

${E_BOLD}${E_ITALIC}For example${E_RESET}, if you create a map for CTRL-I, then you can invoke the map by pressing Ctrl-I or the Tab key.

On Unix like systems, the Ctrl-S and Ctrl-Q keys may be used for terminal flow control. If you map these keys in Vim,
then when you invoke them, Vim will not receive these key sequences. To use these keys in Vim, you have to change the
flow control characters used by the terminal using the 'stty start' and stty stop' commands to some other character or
disable the terminal flow control using the following command:

\$ stty -ixon Similarly, Ctrl-Z is used to suspend Vim on Unix-like systems. To use Ctrl-Z in your maps, you can change
the suspend character using the 'stty susp' command.

On MS-Windows, if the mswin.vim file is used, then CTRL-V is mapped to paste text from the clipboard. In this case, you
can use CTRL-Q or CTRL+SHIFT+V instead of CTRL-V to escape control characters.

To create a map for the Ctrl-v key, you have to enter it four times:

:imap ^V^V^V^V EscapeCharacter 

In the above command to enter a single ^V, you have to press Ctrl and v. When Vim parses the above command, it replaces
the ^V^V^V^V sequence with ^V^V (two Ctrl-V characters). When the map is invoked, Vim replaces the two Ctrl-V characters
with a single Ctrl-V character.

The Ctrl-J character represents the linefeed and is internally used by Vim to represent the Nul character. You cannot
create a map for Ctrl-J by using the following command:

"The following command doesn't work 

:imap <press Ctrl-V><press Ctrl-j> Newlinecharacter 

You can also enter a control character by pressing Ctrl-V followed by the decimal or octal or hexadecimal value of the
character. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, to enter CTRL-P, you can press Ctrl-V followed by 016 (decimal) or x10 (hexadecimal) or o020.

Instead of entering the control characters directly in a map command as described above, it is preferable to use
symbolic key notation for the control characters for readability. Vim supports representing control characters using
symbolic notation like <F1>, <C-W>, <C-S-F1>, etc.

To determine the special key code representation that can be used in a map command, in insert mode, press the <CTRL-K>
key followed by the key.

 Ctrl key modifier: <C-key> (Ctrl-R is <C-R>). 
Shift key modifier: <S-key> (Shift-F2 is <S-F2>) 
  Alt key modifier: <A-key> or <M-key>

You can combine one or more key modifiers: Ctrl+Shift+F3 you can use <C-S-F3>. 

Super is represented <D-key> in MacVim and <T-key> in gtk2 gvim. In gvim it doesn't work with all the keys.

The Vim key notation for other special characters is listed below:

<BS>           Backspace 
<Tab>          Tab 
<CR>           Enter 
<Enter>        Enter 
<Return>       Enter 
<Esc>          Escape 
<Space>        Space 
<Up>           Up arrow 
<Down>         Down arrow 
<Left>         Left arrow 
<Right>        Right arrow 
<F1> - <F12>   Function keys 1 to 12 #1, #2..#9,#0  Function keys F1 to F9, F10 
<Insert>       Insert 
<Del>          Delete 
<Home>         Home 
<End>          End 
<PageUp>       Page-Up 
<PageDown>     Page-Down 
<bar>          the '|' character, which otherwise needs to be escaped '\|' 

Note that Vim understands only those keys that are supplied by the operating system to Vim. If a particular key sequence
is handled by a window manager or is intercepted by the operating system, then Vim will not see that key sequence. Then,
you can not use that key sequence in Vim.

To determine whether Vim receives a key sequence, in insert mode press <CTRL-V> followed by the key sequence. If you see
some characters in the buffer, then Vim is receiving the entered key sequence.

If the escape sequence received by Vim is not a standard sequence, you can set the sequence to the desired key. For
example, let us say <PageUp> is generating a non-standard key sequence in your system. Then you can use the following
command:

:set <PageUp>=<type Ctrl-V><type PageUp> 

In the above command, the first <PageUp> is inserted literally (8 characters).  The argument after = is entered by
pressing Ctrl-V followed by the <PageUp> key.

You can also specify a character by its numeric value in a map. A character is represented by <Char-xxx>, where xxx is
the value of the character in decimal or octal or hexadecimal.

${E_BOLD}${E_ITALIC}For example${E_RESET}, the key CTRL-P has a value of 16 (decimal). This is represented by <Char-16> (in decimal), <Char-020> (in
octal) and <Char-0x10> (in hexadecimal). You can create a map for <CTRL-P> using any one of the following commands:

:nnoremap <C-P> { :nnoremap <Char-16> { :nnoremap <Char-020> { :nnoremap <Char-0x10> { 

You can also use the termcap entry for a key in the map. The termcap entries are represented using the format <t_xx>
where 'xx' is replaced with the key. You can get a list of termcap keys using the ":set termcap" command. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, to map F8 you can use <t_F8>:

:nnoremap <t_F8> :make<CR> 

But it is preferable to use key notations instead of terminal codes for special keys.


${E_WHITE_FG}Maps With The Same Prefix${E_RESET}
${E_WHITE_FG}-------------------------${E_RESET}
If more than one mapped key sequence starts with the same subsequence of keys then when invoking the map you will notice
a delay. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the ";" (semi-colon) command in normal mode repeats the previous f or t or F or T command. Assume
that your map commands also start with ";". When you press ";", Vim needs to wait for you to enter sufficient number of
characters to distinguish between the built-in internal command and your mapped commands.

When the 'timeout' option is set (which is the default), then Vim waits for the number of milliseconds specified in the
'timeoutlen' option for a mapped key sequence to complete. The default setting for 'timeoutlen' is one second.

If the 'timeout' option is reset, then Vim will not timeout for mapped key sequences. But it is better not to change the
'timeout' option setting and leave the option in its default value. Instead, if you want more or less delay before a
mapped key sequence times out, you can try increasing or decreasing the 'timeoutlen' setting.

Consider the following maps:

:nnoremap ;g :echo 'First command'<CR> :nnoremap ;k :echo 'Second command'<CR> 

When you press ';' to repeat the last 't' or 'f' or 'T' or 'F' command, Vim will now wait for 'timeoutlen' milliseconds
to check whether you are going to enter 'g' or 'k'. If you enter any other character or don't enter any character for a
second, then Vim will repeat the last 't' or 'f' or 'T' or 'F' command. If you enter 'g' or 'k' after ';', then Vim will
execute the corresponding map.

For the above described reason, it is better to avoid starting your mapped key sequence with a frequently used Vim
command like j, k, l, etc.


${E_WHITE_FG}Map Comments${E_RESET}
${E_WHITE_FG}------------${E_RESET}
You cannot add a Vim comment in the same line as the map command. The comment will be included in the map
command and executed when the key sequence is entered. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, using the following command, when you press <F2>, Vim will try to execute the comment
also as a series of key presses (resulting in error).

:map <F2> :ls<CR>     " Map to display the list of buffers 

You can add the comment before the line that defines the map:

"Map to display the list of buffers 
:map <F2> :ls<CR> 

${E_WHITE_FG}Supplying A Count To A Map${E_RESET}
${E_WHITE_FG}--------------------------${E_RESET}
To repeat a normal mode Vim command, you can specify a count before the command. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, to move the cursor 3 lines up, you can use the '3k' command. If you specify a count
before a mapped key sequence, the map may not be repeated by the specified count.

When a count is entered before invoking a map, the count will be prepended to the key sequence executed for the map. For
example, assume you have mapped <F7> to move the cursor by 5 characters to the right:

:nnoremap <F7> 5l 

If you invoke the above map with a count of 2 using 2<F7>, the cursor will not be moved 10 characters to the right.
Instead, the cursor will be moved 25 characters to the right. This is because the count 2 is prepended to the 5 in the
map resulting in 25.

To allow repeating a map by a specified count, you have to define your map using either the '=' expression register, the
execute command, or a Vim function.

The '=' expression register allows you to specify an expression for the register contents. To use the expression
register in your map, you have to combine that with the '@' operator. The '@' operator executes the contents of a
register. If a count is specified before the '@' operator, then it executes the contents of a register by the specified
count.

${E_BOLD}${E_ITALIC}For example${E_RESET}, change the above map command to:

:nnoremap <F7> @='5l'<CR> 

Now, if you use 2<F7>, the cursor will be moved 10 characters to the right.

Some things to note about using the '=' register in your map. After specifying an expression, you have to use <CR> to
end the command-line. If you want to use the escape character in the expression, you have to escape it using CTRL-V. For
example, if you want to define a map to add the '#' character at the beginning of the current line, exit the insert mode
and move the cursor one line down, you can use the following command:

:nnoremap <F4> @='I#<C-V><Esc>j'<CR> 
Now if you press 3<F4>, the 3 lines starting from the current line are prefixed with the '#' character.

In the above map, if you specify a key sequence after the contents of the expression register, then those keys will not
be executed by the '@' operator. So the specified count doesn't apply to those keys. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, in the above map, if you move the 'j' out of the contents of the expression register:

:nnoremap <F4> @='I#<C-V><Esc>'<CR>j 

Now, if you execute '3<F4>', three '#' characters will be added to the beginning of the current line and the cursor is
moved to the following line.

Another approach, which is useful when mapping to Ex commands, is to build a command string with the concatenate
operator '.' and execute this with the 'execute' command. 

${E_CYAN_FG}Example${E_RESET}:

:nnoremap g<C-T> :<C-U>exe v:count1 . "tag"<CR> 

This will map 'g<C-T>' to ':tag' and '5g<C-T>' to ':5tag'.

The v:count1 variable returns 1 if a count is not specified to the last normal mode command. The v:count variable
returns 0 if a count is not specified to the last normal mode command/map. In the above map, <C-U> is used to erase the
text on the command-line before invoking the function.

A third approach to allow repeating a map is to use a Vim function to define the map. A Vim function can be defined to
accept a count and repeat an operation that many number of times. You can use the "range" attribute to define a function
that accepts a count.

If you supply a count to a function that doesn't accept a range, then you will get the 'Invalid range' error message.

${E_CYAN_FG}Example${E_RESET}:

function! Myfunc() 
	" Function that doesn't accept a range 
endfunction 

:nnoremap _w :call Myfunc()<CR> 

If you specify a count to the _w command, then you will see the 'Invalid range' error message.

If you want your map to accept a range, then you have to specify the range attribute when defining the function as shown
below:

function! Myfunc()
	range echo 'range = ' . a:firstline . ',' . a:lastline 
endfunction 

:nnoremap _w :call Myfunc()<CR>

Now you can pass a count to the _w map. The a:firstline and a:lastline variables in the function refer to the starting
line number and ending line number of the range supplied to the function. The default is the current line number.

You can also use the internal v:count and v:count1 Vim variables in your function to get the count specified to the last
normal mode command or map. 

${E_CYAN_FG}Example${E_RESET}:

:nnoremap <C-W> :<C-U>call Myfunc()<CR> 

function! Myfunc() 
	let c = v:count 
	" Do something count number of times
endfunction

${E_WHITE_FG}Using Multiple Ex Commands In A Map${E_RESET}
${E_WHITE_FG}-----------------------------------${E_RESET}
You can specify multiple Ex commands separated by "|" (bar) in the Ex command line (":"). The "|" is used as the command
separator. 

${E_BOLD}${E_ITALIC}For example${E_RESET},

:set invignorecase | set ignorecase?  

If you specify "|" in the {rhs} of a map, then Vim will treat it as a command separator and only the first command will
be part of the map and the subsequent commands will be executed when defining the map. 

${E_BOLD}${E_ITALIC}For example${E_RESET},

:nnoremap <F9> :set invignorecase | set ignorecase?<CR> 

In the above command, "set ignorecase?" will not be part of the map for <F9>.

You have to escape the "|" by using backslash (\) or by using the <Bar> symbolic notation or by using CTRL-V. The
following commands will work:

:nnoremap <F9> :set invignorecase \| set ignorecase?<CR>
:nnoremap <F9> :set invignorecase <Bar> set ignorecase?<CR> 
:nnoremap <F9> :set invignorecase <press Ctrl-V>| set ignorecase?<CR> 

Some Ex commands use the command that follows them (separated by |) as part of the command itself. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the ":global" (or ":g") command repeats the command that follows it for every matched
pattern. In the following command,

:g/foo/s/abc/xyz/g | echo 'Completed substitution' 

The ":echo" command is repeated for every 'foo' found in the current buffer. To execute the ":echo" command only once
after the ":g" command completes, you have to use the ":exe" command.

:exe 'g/foo/s/abc/xyz/ge' | echo 'Completed substitution' 

If your map uses one of these commands like ":g" then you have to use ":exe" in your map command.

Another way to invoke multiple Ex commands from a map is to invoke them separately as shown below:

:nnoremap <F9> :set invignorecase<CR>:set ignorecase?<CR> 

Ex commands invoked from a map are not added to the command history. You can't recall the individual commands invoked by
a map from the command-line.

${E_WHITE_FG}Using Space Characters In A Map${E_RESET}
${E_WHITE_FG}-------------------------------${E_RESET}
If you want to use a space character in the {lhs} of a map command, then you have to use
<Space> or escape the space character with CTRL-V (need to use two CTRL-Vs). 

${E_CYAN_FG}Example${E_RESET}:

nnoremap q<Space> M 

The above command creates a normal mode map for the key sequence "q" followed by the space character to move the cursor
to the middle of the page.

If you want to use the space character at the beginning of the {rhs} of a map command, then use <Space>. In other places
in the {rhs}, you can use the space character by pressing the space bar. 

${E_CYAN_FG}Example${E_RESET}:

inoremap <C-F4> <Space><Space><Space> 

The above command creates an insert mode map for the key sequence CTRL-F4 to enter three space characters.

Note that if you inadvertently use a space character at the end of the {rhs} in a map command, then the map may behave
differently. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following command maps the backspace character in normal mode to behave like the 'X'
command and delete the character before the cursor:

nnoremap <BS> X 

If there is a space character after "X" in the above command, then the map will delete the character before the cursor
but leave the cursor at the current location instead of moving it back by one position. You can locate these kinds of
errors, by looking at the output of the ":map" command. In the ":map" output, the space character at the end of the
{rhs} in a map will be shown as "<Space>".

${E_WHITE_FG}Disabling Key And Mouse Event${E_RESET}
${E_WHITE_FG}------------------------------${E_RESET}
You can disable key and mouse events by mapping them to the special string "<Nop>". 

${E_BOLD}${E_ITALIC}For example${E_RESET}, to disable the <F4> key in normal mode, you can use the following command:

:nmap <F4> <Nop> 

You can use the mode specific map command to disable a key in a particular mode.

The <Nop> sequence has a special meaning only if it appears by itself in the {rhs} of a map. You cannot use <Nop> with
other keys in the {rhs} of a map. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following command will not disable the <F1> key:

:inoremap <F1> <Nop><Nop> 

You can disable mouse buttons and mouse events by mapping them to <Nop>. 

${E_BOLD}${E_ITALIC}For example${E_RESET} to disable the <MiddleMouse> button, you can use the following command:

:imap <MiddleMouse> <Nop> 

${E_WHITE_FG}Error In Mapped Key Sequence${E_RESET}
${E_WHITE_FG}-----------------------------${E_RESET}
When executing the key sequences in a key map, if Vim encounters an error, then the map will be aborted and the
remaining key sequences will not be executed. You will not see any error message indicating that this has happened. If
you have the 'errorbells' or 'visualbell' option set, then you will see the screen flash or hear the audio beep.

${E_BOLD}${E_ITALIC}For example${E_RESET}, consider the following key map that maps <F5> to toggle the case of the first letter of the current word.

nmap <F5> wb~ 

In most cases the above map will work as desired. But when the cursor is at the last word in the last line of a file,
the above map will not work. In the last word of a file, the "w" command will fail and will not move the cursor to
the next word. So the remaining part of the map will not be executed.

One way to workaround this problem is to split the command into two parts and execute them using the ":exec" command:

nmap <F5> :exec 'normal w'<Bar>exec 'normal b~'<CR> 

${E_WHITE_FG}Maps And 'cpoptions' Option${E_RESET}
${E_WHITE_FG}---------------------------${E_RESET}
The 'cpoptions' Vim option contains many flags that control the compatibility level of Vim with the Vi behavior. To get
the current value of the 'cpoptions' option, use the following command:

:set cpoptions?  

When Vim is running in Vi-compatible mode, all the possible flags are set in the 'cpoptions' option.

The flags in the 'cpoptions' Vim option affect map definitions and their usage. These flags are described below.

If the flag 'b' is present in 'cpoptions', then a "|" character in a map command is treated as the end of the map
command. This means that you cannot use backslash (\) to escape the "|" character in map command definitions.

${E_CYAN_FG}Example${E_RESET}:

:nnoremap <F5> :set invhlsearch \| set hlsearch?<CR> 

If the 'b' flag is present in 'cpoptions', then the above map command definition will fail. All the characters after the
backslash will not be part of the map.

If the flag 'B' is present in 'cpoptions', then the backslash character is not treated as a special character in map
commands. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, let us say you want to create an insert-mode map for the <F6> key to insert the text "Press
<Home> to go to first character". For this, you can try using the following command:

imap <F6> Press <Home> to go to first character 

When you press <F6> in the insert mode, the <Home> in the above map will cause Vim to move the cursor to the first
character in the line and insert the reminder of the text there. To literally enter the text "<Home>", you need to
escape it:

imap <F6> Press \<Home> to go to first character If the flag 'B' is not present in 'cpoptions', then the above map
command will insert the correct text. If the flag 'B' is present, then the backslash character is not treated as a
special character and the above map will not insert the correct text. To treat <Home> literally independent of the
'cpoptions' setting, you can use the following command:

imap <F6> Press <lt>Home> to go to first character 

In the above command, the notation <lt> is used for "<" in "<Home>".

If the flag 'K' is present in 'cpoptions', then you can cancel the invocation of a map in the middle of the key sequence
by pressing <Esc>. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, let us say you have the following map command:

:nnoremap <F3><F3> :ls<CR> 

If the flag 'K' is present, then after entering the first <F3>, you can cancel the map by pressing <Esc>. If the flag
'K' is not present, then if you don't press any key after the first <F3>, Vim will wait for 'timeoutlen' milliseconds
before cancelling the map (assuming the 'timeout' option is set).

If the flag 'k' is present in 'cpoptions', then raw key codes are not recognized in map commands. You can enter raw key
code in a map command by pressing Ctrl-V followed by a control key. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, consider the following map command:

nnoremap <press Ctrl-V><press Up arrow> gk 

The above command maps the raw key code for the up arrow key to invoke the gk command. If the 'k' flag is not present in
'cpoptions', then the above command will properly work. If the 'k' flag is present in 'cpoptions', then the above map
command will not work.

If the flag '<' is present in 'cpoptions', then special keys codes like <Tab>, <C-K>, <F1>, etc. are not recognized in
maps. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, consider the following maps:

:nnoremap <M-Right> <C-W>l :nnoremap <M-Left> <C-W>h 

If the '<' flag is present in 'cpoptions', then the above map commands will not work as the special key codes <M-Right>,
<M-Left> and <C-W> will not be recognized.

${E_WHITE_FG}Maps And 'paste' Option${E_RESET}
${E_WHITE_FG}-----------------------${E_RESET}
While pasting text into a Vim buffer, to disable automatic indentation and interpreting mapped
key sequences in the inserted text, you can set the 'paste' option. When the 'paste' option is set, mapped key sequences
are ignored. By default, the 'paste' option is disabled. If your mapped keys are not working in a buffer, check whether
the 'paste' option is set.

Map attributes You can modify the behavior of a key map by specifying several attributes in the map command. The
supported attributes are <buffer>, <silent>, <special>, <script>, <expr>, and <unique>. You can specify one or more of
these attributes in a map command immediately after the map command name.

Buffer-local maps When you create a map, the mapped key can be used in all the Vim buffers. To create a map that is
applicable only to specific buffers, use the <buffer> attribute to the map command. 

${E_BOLD}${E_ITALIC}For example${E_RESET},

:setlocal makeprg=gcc\ -o\ %< :nnoremap <buffer> <F3> :make<CR> 

The above command creates a map to compile the file opened in the current buffer. You can add the above set of commands
to a filetype plugin. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, you can add it to file ~/.vim/after/ftplugin/c.vim (Unix) or
\${HOME}/vimfiles/after/ftplugin/c.vim (Windows)—create any missing directories or files. Now, you can compile a C file in
the current buffer, by pressing the <F3> key. When you open a Java file, this command will not be available.

When a buffer is deleted, the buffer local mappings for that buffer are removed. When a buffer is unloaded or hidden,
you will not lose the mappings.

When you remove a buffer local map, you have to specify the <buffer> attribute to the ":unmap" or ":mapclear" command.
Without the <buffer> attribute you cannot remove the map.

To display all the buffer-local mappings for the current buffer, use the following commands:

:map <buffer> 
:map! <buffer> 

To display the mode specific buffer-local maps, use the map command for that mode in the above command.

${E_WHITE_FG}Silent Maps${E_RESET}
${E_WHITE_FG}-----------${E_RESET}
When a map is invoked, the sequence of keys executed is displayed on the screen. If an Ex command is invoked
by the map, then you can see the Ex command at the Vim status line. To silently execute a map, use the <silent>
attribute for the map. 

${E_BOLD}${E_ITALIC}For example${E_RESET},

:nnoremap <silent> <F2> :lchdir %:p:h<CR>:pwd<CR> 

The above command maps the <F2> key to change to the directory of the current file and then display the current
directory. When you invoke the above command, due to the <silent> attribute, you will not see the commands that are
executed.

If the commands invoked by the map display a message, then those messages will be visible even though <silent> attribute
is specified for the map command. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, in the above command, the current directory displayed by the ":pwd" command will be visible.

Expression maps For simple maps, the action to be carried out for a key sequence can be defined without using a Vim
function. But for complex maps, it is simpler to use a Vim function to implement the action for the map.

You can use the <expr> attribute to a map command to invoke a Vim function and use the returned value as the key
sequence to execute.

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following code creates a normal mode map to change to the directory of the current buffer.

function! ChangeToLocalDir() 
	lchdir %:p:h 
	return '' 
endfunction 

nnoremap <expr> _c ChangeToLocalDir() 

In this example, the function returns an empty string so the map takes no action other than executing the function.

The <expr> attribute can be used with all the mode specific map commands.

${E_WHITE_FG}Special Characters In Map${E_RESET}
${E_WHITE_FG}--------------------------${E_RESET}
To use non-printable characters using the <> notation like <F5> in a map command, the '<' flag should not be present in
the 'cpoptions' option. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the following map command will not work:

:set cpo+=< :inoremap <F7> <C-X><C-N> 

In insert mode, if you press <F7>, instead of executing the map, the characters <F7> will be inserted. To prevent this,
you can use the <special> map attribute:

:inoremap <special> <F7> <C-X><C-N> 

With the <special> map attribute, independent of the 'cpoptions' option setting, Vim will correctly process the <> key
codes in the {rhs} of a map command.

Using maps in Vim plugins and scripts A Vim plugin or script can define new key maps to let the user invoke the commands
and functions provided by the plugin. A Vim plugin can also invoke key maps defined by other Vim plugins.

A plugin can choose to map any available key. But to avoid surprising (annoying) the user, it is better not to use the
keys that already have pre-defined functionality in Vim.

In a Vim plugin, the ":normal" command is used to execute normal mode commands. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, the "gqip" normal mode command is used to format a paragraph. To invoke this command from
a Vim plugin, the following line can be used:

normal gqip If any of the keys in "gqip" is mapped, then the mapped key sequence will be executed. This may change the
expected behavior of the "gqip" command. To avoid this, add the "!" suffix to the "normal" command:

normal! gqip With the "!" suffix, the "normal" command executes the built-in functionality provided by Vim for the
specified sequence of keys.

To invoke a script local function, defined with the "s:" prefix, from a map, you have to prefix the function name with
<SID>. You cannot use the "s:" prefix for the script-local function, as the map will be invoked from outside of the
script context.

:inoremap <expr> <C-U> <SID>InsertFunc() 

A plugin may map one or more keys to easily invoke the functionality provided by the plugin. In the plugin functions
used by these types of maps, it is advisable not to alter user Vim option settings, register contents and marks.
Otherwise, the user will be surprised to see that some options are changed after invoking a plugin provided map.

${E_WHITE_FG}Map Leader${E_RESET}
${E_WHITE_FG}----------${E_RESET}
If the key maps provided by all the Vim plugins start with the same key, then it is easier for a user to
distinguish between their own key maps and the ones provided by plugins. To facilitate this, Vim provides a special
keyword that can be used in a map command.

If the {lhs} key sequence of a map command starts with the string "<Leader>", then Vim replaces it with the key set in
the 'mapleader' variable. The default setting for the 'mapleader' variable is backslash ('\'). Note that 'mapleader' is
a Vim variable and not a Vim option. The value of this variable can be changed using the 'let' command. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, to set it to '_' (underscore), you can use the following command in your vimrc file:

let mapleader = "_" 

Vim replaces <Leader> with the 'mapleader' value only when defining the map and not when the map is
invoked. This means that after several map commands are defined if the 'mapleader' variable is changed, it will not
affect the previously defined maps.

${E_BOLD}${E_ITALIC}For example${E_RESET}, consider the following map command defined by a plugin:

nnoremap <Leader>f :call <SID>JumpToFile()<CR> 

When defining the above command, Vim replaces <Leader> with the value of the 'mapleader' variable. If the user didn't
set the 'mapleader' variable then the above map can be invoked by entering \f. If the user sets the 'mapleader' to a
comma (','), then it can be invoked using ,f.

The <Leader> prefix should be used for global mappings (applicable to all buffers) defined by a plugin. For buffer-local
mappings, the <LocalLeader> prefix should be used. Vim will replace this with the value set in the 'maplocalleader'
variable. The default value for this variable is backslash ('\'). The <LocalLeader> is generally used in mappings
defined by a Vim filetype plugin.

The 'mapleader' and 'maplocalleader' variables allow the user to choose different keys as starting keys for global
mappings and buffer-local mappings defined by Vim plugins.

Script maps If you want to use recursive maps in your map command, but want to use only those keys mapped in your script
or plugin, then you can use the <script> attribute in the map definition. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, consider the following two map commands in a script file:

noremap <SID>(FindTopic) /Topic<CR> 
nmap <script> ,dt <SID>(FindTopic)dd 

Within the second map command, only the '<SID>(FindTopic)' part is remapped. Without '<script>', 'dd' could be remapped
too if someone defined a mapping for it.

If you use the <script> attribute with a ":noremap" command, then the <script> attribute overrides the ":noremap"
command. The {rhs} of the map is still scanned for script-local key mappings. But the maps defined outside of the script
are not used.

Unique maps If you want to make sure that the mapped key is unique and doesn't interfere with other existing mappings,
use the <unique> map attribute. This attribute is particularly useful with the maps defined by a Vim plugin. A map
definition with the <unique> attribute will fail if the specified key is already mapped.

:nnoremap <unique> \s :set invhlsearch<CR> 

The above command will fail, if the user already has a mapping for the "\s" key sequence.

Use of <Plug> If you are developing a Vim plugin or script and you want to provide the user with the flexibility of
assigning their own key map to invoke a function provided by your script, then you can prefix the map with <Plug>.

${E_BOLD}${E_ITALIC}For example${E_RESET}, let us say a plugin has a function s:VimScriptFn() and the user has to create a map to assign a key to
invoke this function. The plugin can provide the following map to simplify this:

noremap <unique> <Plug>ScriptFunc :call <SID>VimScriptFn()<CR> Note that in the above map command, instead of the
typical key sequence for the {lhs} of the map, the <Plug>ScriptFunc text is used. The <Plug> generates a unique key
sequence that a user cannot enter from a keyboard. The above map is visible outside of the script where it is defined.

With the above command, the user can assign _p to invoke the script function as shown below:

:nmap _p <Plug>ScriptFunc

Map related functions Vim provides built-in functions to check whether a key sequence is mapped or not and to get the
mapped key sequence.

maparg() To get the {rhs} of a map command from a script or plugin, use the maparg() function. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, consider the following commands:

:nnoremap <C-F2> 2<C-G> :let x = maparg("<C-F2>", "n") :echo x 

The variable 'x' will be set to the mapped key sequence "2<C-G>".

The first argument to the maparg() function specifies the key sequence and the second argument specifies the editing
mode. The maparg() function checks whether the specified key sequence is mapped in the specified mode and returns the
{rhs} of the map if it is defined. If the mode is not specified, then the maparg() function checks for the map in the
normal, visual and operator pending modes.

The maparg() function can be used to chain map commands. 

${E_BOLD}${E_ITALIC}For example${E_RESET}, let us say you want to define a map for <Tab>. But at the same time you don't want to
lose the existing map (if any) for <Tab>. Then you can do the following:

:exe 'nnoremap <Tab> ==' . maparg('<Tab>', 'n') 

The above command maps <Tab> to invoke the == command and then invoke the existing map for <Tab> in normal mode.

${E_WHITE_FG}mapcheck({name} [, {mode} [, {abbr}]])${E_RESET}
${E_WHITE_FG}--------------------------------------${E_RESET}

To check whether a map is defined for a key sequence, you can use the mapcheck() function. 

${E_CYAN_FG}Example${E_RESET}:

:echo mapcheck(';g', 'n') mode() 

In a map command, you can use the mode() Vim function to get the current editing mode.  But this function returns 'n'
(normal) or 'c (command-line) in most cases. So this function cannot be used reliably from a map command to get the
current mode. Instead, you should pass the current mode as an argument to the called function.  

${E_BOLD}${E_ITALIC}For example${E_RESET}, if you want to use a Vim function Somefunc() in several mode-specific map commands and
want to distinguish between the modes in the function, then you can do the following:

:nnoremap _g :call Somefunc('n')<CR> 
:inoremap _g <C-O>:call Somefunc('i')<CR> 
:vnoremap _g :<C-U>call Somefunc('v')<CR> hasmapto() 

To check whether a map is defined for a particular key sequence, you can use the hasmapto() function. Note that this
function checks for the key sequence in the {rhs} of a map. 

${E_CYAN_FG}Example${E_RESET}:

if !hasmapto(":grep") 
	" Define a mapping to invoke the :grep command 
endif 

The hasmapto() function checks for the specified key sequence anywhere in the {rhs} of a map (not necessarily at the
beginning of the map).

The hasmapto() function also accepts an optional {mode} argument which allows you to check whether a map definition
exists in a particular mode.

if !hasmapto(":grep", 'n') 
	" Define a normal mode map to invoke :grep 
endif

${E_WHITE_FG}Additional Info${E_RESET}
${E_WHITE_FG}---------------${E_RESET}

Verbose Commands 

The more pieces of configuration and plugins you’ll add to Vim, the more you’ll wonder where they’ve
been created in your config files. 

The command :verbose can help you: it will output at what line of what file a precise
configuration have been declared.

More precisely, :verbose can output the declarations of:

Abbreviations Options Mapping User commands 

For example, I’ve set the option undodir in my vimrc. If I run :verbose set undodir?, 
I’ll get the following output:

Last set from ~/.config/nvim/init.vim line 354 

Keeping your configuration well organized and simple is the best strategy. 
But everything gets messy overtime, especially when experimenting with new configuration or plugins. 
I don’t use verbose often but, when I need it, I’m always happy to have it.

Vim help :help :verbose-cmd 

Mapping Special Arguments 

We’ve seen the basics of mapping in a previous article, but we didn’t speak about the special arguments it can take.
Most of them can be used for abbreviations, too.

Here are the most useful ones:

	<silent> - Doesn’t output the mapping in the Vim command-line. If you want to also drop the output of the command linked
	to the mapping, add the command :silent.  

	<buffer> - The mapping’s scope is reduced to the current buffer only. These mappings have the priority on the global
	ones.  

	<expr> - The mapping executes a Vimscript expression instead of a Vim command.  

	<unique> - The mapping fails if it already exists. It’s useful if you don’t want to override any mapping defined
	previously.  

	<Cmd> - The mapping can run a command without quitting the current mode you’re in.  A special argument should be used as
	first argument for any mapping or abbreviation. The argument 

	<Cmd> is an exception: it should be used just before the command itself.

To understand how it works, let’s take some examples:

:nnoremap <silent> <leader><f6> :source \${MYVIMRC}<CR> 
The command :source \${MYVIMRC} won’t be displayed in the Vim command-line when hitting LEADER F6.  

:iab <expr> cdate strftime('%Y-%m-%d') 
The Vimscript function strftime is executed when the abbreviation cdate is used.  

:inoremap <c-d> <Cmd>delete<cr> 
Execute the command :delete without leaving INSERT mode.  

:nnoremap <leader><f6> :silent :source \${MYVIMRC}<CR> 
The output of the command :source \${MYVIMRC} will be dropped, thanks to the command :silent.  We’ll see a use case for
the special argument <buffer> below.

Vim help :help map-arguments 

Mapping Operator Pending Mode 

Operators are NORMAL mode keystrokes which need to be combined with motions or text-objects. For example, d, c, or y are
operators. I’ve written about them in the very first article of this series.

When we type one of these operators in NORMAL mode, we switch to OPERATING-PENDING mode. At that point, vim waits for a
motion (or text-object), and then come back to NORMAL mode.

Vim let’s you create new mapping for this OPERATOR-PENDING mode with the command :onoremap. Concretely, you’ll be able
to create new motions for all existing operators.

For example:

:onoremap ic i{ 
We’ve created here a new text-object ic to use an operator inside curly brackets. 
You can try it out to delete the content between two curly brackets for example, by:

Placing the cursor inside the curly brackets.  Hitting dic in NORMAL mode.  

The text-object (or motion) created with :onoremap always begins where your cursor is. That’s why we need to place our
cursor inside the curly brackets in our previous example. But it would be even better if we could act on the next curly
brackets on the current line, without worrying where the cursor is. 

The following command will make this dream a reality:
:onoremap nc :normal! f{vi{<cr> 

Let’s look at this example more closely:

:normal!  Execute keystrokes as if you were in NORMAL mode (see Vim for Advanced Users).  
f{        Find the next curly bracket on the line (see Vim for Beginners).  
vi{       Switch to VISUAL mode and select inside the curly brackets.  
<cr>      Key notation for the ENTER key to validate our command (carriage return, see Vim for Intermediate Users).  

The operator will be applied on the selection made in VISUAL mode. 

To illustrate this idea, let’s look at the following content:

My super┃line {with curly brackets} 

The symbol ┃ represents the cursor position. If you hit the keystroke dnc, you’ll delete what’s inside the next curly
bracket. 

The result will be:

My super line {} 

The cursor will end up on the last curly bracket.

Vim help :help omap-info 

The Command Execute 

Let’s look again at the mapping we’ve set above:

:onoremap nc :normal! f{vi{<cr> 

The key notation <cr> is considered a special character when you create a mapping. It works with mappings, but it won’t
work with the :normal command by itself.

For example, you can try to run the following to replace the next occurrence of “emacs” with “vim”:

:normal /emacs<cr>ciwvim 

This time, Vim doesn’t recognize <cr> as a special character, so the command won’t work. To go around this limitation,
you can use CTRL+V (see Vim for Adept Users). In that precise case, we would need to hit CTRL+V ENTER while writing our
command. We would end up with something like this:

:normal! /emacs^Miwvim 

The command :execute can solve our problem in a more elegant way. It lets you execute a command from a string. You can
then use string constants for these special characters, all prefixed with a \. 

Here’s an equivalent of our silly example:

:execute "normal! /emacs\<cr>ciwvim" 

All the key notations you can use with :map or :abbreviate have their string constant equivalents.

When you give multiple arguments to execute, they’re concatenated into one string and separated with spaces. If you
don’t want the spaces, use a dot instead. 

For example:

:execute 'echo "this" "is" "a" "str"."ing"' 

The output will be: “this is a string”.

Vim help :help execute :help expr-quote 

Autocommands Basics 

Autocommands can automatically run a command when a specific event happens. More precisely, it adds a command to a list
of command linked to a precise event. When this event is fired, every command of the list of commands are executed.

An event can be opening Vim, reading any file, or writing a markdown file for example.

Here are the basics to manipulate autocommands:

:autocmd <event> <pattern> <cmd> or :au <event> <pattern> <cmd> 

Add the command <cmd> to the list of commands executed automatically when the event <event> is fired. The pattern
<pattern> filter the files where the autocommand should be applied.  :autocmd <event> or :au <event> - Output the list
of commands executed when the event <event> is fired.  :autocmd! <event> or :au! <event> - Delete the list of
autocommands of the event <event>.  

To clarify all this jargon, here are some examples:

:autocmd BufWrite * echom "Write..." 
Output “Write” each time any file is saved. The wildcard * means “every file”.

:autocmd BufNew *.md echom "Read..." 
Output “Read” each time a new markdown buffer is created. Unsurprisingly, The pattern *.md means every filename
finishing with .md.  After running these commands, you can try to write a file (command :w) to see if it works. If you
don’t see the message in the command-line, run :messages to display them.

Multiple Events and Patterns You can also create an autocommand with more than one event or pattern, separated with a
comma. 

For example:

:autocmd BufNew,BufWrite *.md,*.js,*.php echom "Create or write md, js, or php..." The command echom "Create or write
md, js or php..." will run when a markdown, JavaScript, or PHP buffer is created (BufNew) or saved (BufWrite).

Note that the pattern can be a bit different depending on the events you listen to. For a description of all events
available, see :help autocommand-events.

Finally, if you want the scope of the autocmd to be limited to the current buffer, you can use the special pattern
<buffer>.

Autocommand Groups 

Why Using Autocommand Groups?  As the name indicates, an autocommand group is a group of one or more autocommands. When
you create an autocommand as we did above, it’s added automatically to a default autocommand group without a name. You
can create autocommand groups with names and add autocommands to it, too. You can think of it as namespaces for
autocommands.

To understand this concept, let’s see where it’s useful to use autocommand groups. As we saw, each time you create an
autocommand, it’s added to the list of command triggered when a specific event occurs; even if this command is already
part of the list.

Let’s look at an example. 

First, let’s add this autocommand to your vimrc:

autocmd BufWritePre * echom "Write..." 

You can then try the following:

Source your virmc twice (by running :source \${MYVIMRC} twice).  Run :autocmd BufWrite.  This last command will output the
list of commands executed when the event BufWrite is triggered. It will output something like this:

BufWritePre *         echom "Write..." echom "Write..." 

The command echom "Write..." appears two times in the command list for the pattern *. As a result, each time the event
occurs on any file, the command will run two times.

More often than not, we want to add our commands to the command list only once. Otherwise, it will impact performances
each time the event is fired and, if the command is not idempotent, nasty bugs will pop up.

Using autocommand groups can solve this problem. Here are the basic commands you can use to manipulate these groups:

:augroup
Output all autocommand groups.  

:augroup <name> or aug <name> 
Call a new autocommand group named <name>.

All autocommands created after this command will be part of the group.  

:augroup! <name> or aug! <name> 
Delete the group named <name>.  

:augroup END 
End the autocommand group. If you define an autocommand after this one, it won’t be part of the group.  

As always, here’s an example:

:augroup messages :autocmd BufWrite * echom "Write..." :augroup END 
The autocmd is now part of the autocommand group messages.

By itself, it doesn’t solve our problem. If you add the three lines above in your vimrc and source multiple times, the
autocommand in the group messages will be added to the autocommand list each time.

We saw above that you can delete autocommands with the command au! <event>. This will work if the autocommand is not in
a named group. If you run au! BufWrite for example, it will delete every autocommand in the nameless autocommand group
(the default one), but not the one in the group messages we’ve created above.

To solve our problem, we could delete every autocommand belonging to the group messages after creating the group itself:

:augroup messages :au! messages :autocmd BufWrite * echom "Write..." :augroup END 

If these lines are in your vimrc and you source it three times, every autocommand will be deleted from the group
messages each time, before being added again. In short, our problem is solved: the command echom "Write..." will always
appear once and only once in our list of command.

When we use au! between the initialization of the group (augroup messages) and the end of the initialization (augroup
END), we don’t have to indicate the name of the group. Vim will understand, in that case, that we want to delete every
autocommand of the group declared just before. In short, the following commands are equivalent to the ones above:

:augroup messages :au!  :autocmd BufWrite * echom "Write..." :augroup END 
Redeclaring an autocommand group won’t recreate it, but it will add autocommands in the existing group instead. For
example, you can do something like that:

augroup vimrc au!  augroup END

augroup vimrc autocmd BufWrite * echom "Write..." augroup END 

Two things happen here:

A group vimrc is declared.  Autocommands are declared and added to the group vimrc.  In short, every autocommand added
to the group vimrc is merged with the command :au!. You can even do better: when you create an autocommand, you can add
it to an existing group directly. To do that, you can indicate the name of the group just between the command autocmd
and the event name as follows:

augroup vimrc au!  augroup END

autocmd vimrc BufWrite * echom "Write..." 

You’re now able to reload your vimrc as much as you want, your autocommands will only appear once in the autocommand
list. It applies for other sourced files too, like the ones you might have in your folder ftplugin for example.

Ignoring Events If you want to run a command without firing any event, you can use the command :noautocmd. To take our
previous example, if you want to ignore the event BufWrite when running the command :w, you can run the following:

:noautocmd w Vim help :help autocmd :help autocommand-events :help autocmd-events-abc 

Custom Functions 
Writing custom functions for Vim to make your craziest dreams come true should be the goal of any Vim Follower out there.

It’s true that many functions are already available on the infinite Internet. You can simply copy and paste them without
worrying how they work. That said, knowing the basics of Vimscript functions can allow you to adapt them to your needs.

Checking Existing Functions 
Let’s see first how you can display the functions already available:

:function or :fu - List all declared function.  :function /<pattern> or :fu /<pattern> - Filter all declared functions
with the pattern <pattern>.  Creating Or Copying Functions Looking at a simple function will help us understand how they
work. Here’s one:

function DeleteTrailingWS() abort normal mz %s/\v\s+\$//ge normal \'z endfunc This function delete trailing whitespaces in
a whole buffer. Let’s look at it in more details:

function - Keyword to declare a function. You can add a bang (function!) to overwrite a previously declared function
with the same name.  DeleteTrailingWS - Name of the function. It should always begin with an uppercase letter.  abort -
Stop the function when an error occurs.  Be careful if you use function! (with a bang): you might overwrite a function
from one of your plugin. It can open the door to random bugs difficult to fix.

If you look at the body of our function, they are simply Vim commands. They are executed in order:

normal mz - Save the cursor position using the mark z.  %s/\v\s+\$//ge - Delete every whitespace in the current buffer,
using the substitute command.  % - Range for the whole buffer.  \v - Use the very magic mode.  \s - Represent any
whitespace.  Flag e - Doesn’t output an error if the search pattern fail.  normal \'z - Go back to the mark z (the cursor
position when the function was invoked).  I’ve already written about all these commands in Vim for Advanced Users. For
more details about Vim regexes, see Vim for Adept Users.

You can then call the function using the command :call as follows:

:call DeleteTrailingWS() You can also create a new mapping for some of your function if you want to:

nnoremap <leader>ds :call DeleteTrailingWS() Autoloading Functions You can create function in your vimrc directly as we
did above, but it might create some problems. Imagine that the name of the function conflict with a function from one of
your plugin: the bugs occuring can be difficult to debug.

Additionally, all the functions declared in your vimrc will be automatically loaded when you open Vim, even if you never
use them. It would be more efficient to load them when you call them the first time.

It’s where the autoload folder comes in handy. This folder is located in the Vim’s runtime paths.

When Vim needs to find something, it will look at the Vim’s runtime paths. The folder containing your vimrc is one of
these paths, for example. To display all of them, you can run the command :set runtimepath?.

The folder autoload is one of these paths too. Any function created in this folder will have namespaces, and they will
be loaded on demand. Exactly what we want!

You can create the autoload folder where your vimrc is. Then, you can create Vimscript files in there; the name of the
file will be the namespace for your functions.

For example, you can create the file “general.vim” in the autoload folder. Then, you can write in the file the following
function:

function general#DeleteTrailingWS() abort normal mz %s/\v\s+\$//ge normal \'z endfunc When you call the function with
:call general#DeleteTrailingWS(), Vim will:

Look inside the autoload directory for a file called general.  Search for a function called DeleteTrailingWS inside this
file.  Load and execute the function.  Additionally, you can easily display every function for the namespace <namespace>
by running the command :function /<namespace>. For example, if you want to display all the functions for the namespace
general, run :function /general.

For more fine-grained namespaces, you can add sub-directories in the autoload directory. For example, you can create the
following:

autoload/my/super/namespace.vim Then, you’ll need to add the namespace “my#super#namespace” to the functions you create
in the file namespace.vim. For example:

function my#super#namespace#DeleteTrailingWS() abort normal mz %s/\v\s+\$//ge normal \'z endfunc Vim help :help functions
:help autoload-function :help call :help 'runtimepath' User Commands Now that we’re able to create our own functions,
what about increasing our power with our own custom Vim commands? We’ll then be able to run these user commands using
the COMMAND-LINE mode, like any other command.

Basics Like functions, custom user commands should always begin with an uppercase letter, to differentiate them from
Vim’s built-in commands.

Continuing our ritual, here are three useful commands to manipulate user commands:

:command or :com - Output all user commands.  :command <command> or :com <command> - Output all user commands starting
with <command>.  :command <attributes> <name> <cmd> or :com <attributes> <name> <cmd> - Define a new user command with
the name <name> running the command <cmd>. The attributes <attributes> indicate the number of arguments (among other
things).  Similarly to custom functions, you can add a bang when you declare a command (:command!). In that case, if a
command already exists with the same name, it will be overwritten.

Attributes for User Commands There are four different categories of attribute you can use when creating a user command:

Argument handling Range handling Completion behavior Special cases We’ll only cover the most important one in this
article: the argument handling. It allows us to specify the number of argument a user command can take, with the
attribute -nargs:

-nargs=0 - No argument allowed (default).  -nargs=1 - One argument is required.  -nargs=* - Any number of arguments
allowed.  -nargs=? - 0 or 1 argument allowed.  -nargs=+ - One argument or more are required.  To indicate where the
arguments should be inserted in the command, you need to use the placeholder <args>. For example, you can write the
following in your vimrc:

function IScream(content) 
	echom toupper(a:content) 
endfunction

command -nargs=1 Scream call IScream(<args>) As you can see, you can call the arguments of a function in its body using
a:<arg_name>. To try your new user command, source your vimrc with :source \${MYVIMRC} and run the following:

:Scream "hello" When a user command call a function which can take multiple arguments, you need to separate them with
whitespaces and use the placeholder <f-args> instead of <args>.

If there is only one argument allowed, Vim will consider the whitespace as part of the argument itself.

Finally, if you need your user command to be only available in the current buffer, you can also add the attribute
-buffer. It’s mandatory if you create user commands in your runtime folder ftplugin.

Vim help :help user-commands Special Strings for Vim Commands Let’s now look at special strings you can use in
COMMAND-LINE mode. These placeholders will be replaced under the hood with their representations. Here’s a list of the
most useful ones:

% - Relative path of the current file.  <cword> - Word under the cursor.  <cWORD> - WORD under the cursor.  <cfile> -
Filepath under the cursor.  <afile> - File open in the buffer when executing autocommands.  <sfile> - Filename of
sourced file when used with command :source.  You can also use the following with %:

:p - Output the absolute path instead of the relative one. Also expand the tilda ~ to the home directory.  :. - Make the
file path relative to the working directory.  :~ - Make the file path relative to the home directory (if possible).  :h
- Keep the head of the file path (remove the last element).  :t - Keep the tail of the file path (remove everything
except the last element).  :r - Keep the root of the file name (remove its extension).  :e - Remove everything except
the extension of the filename.  :s?pat?sub? - Substitute the first occurrence of “pat” with “sub”.  :gs?pat?sub? -
Substitute all occurrences of “pat” with “sub”.  These special strings only work when a command expects a filename as
argument; as a result, it makes this functionality quite limited. Fortunately, You can use the function
expand(<special_string>) to expand these placeholders in any command.

For example, you can try to run the following:

:echom expand("%") :echom expand("%:p") :echom expand("<cword>") Here’s a more useful example we already saw in the
article Vim for Advanced Users:

nnoremap gX <silent> execute \ "!xdg-open" expand('%:p:h') . "/" . expand("<cfile>") " &"<cr> You should now be able to
understand this command:

<silent> - The mapping won’t appear in the command line when used.  execute - Execute a string as a Vim command.
expand('%:p:h') - Output the head of the absolute path.  expand("<cfile>") - Output the filepath under the cursor in the
current buffer.  In short, this mapping will open the relative filepath under the cursor using the CLI xdg-open.

This command shouldn’t take more than one line, but the backslash \ allows us to write it on two lines for a better
readibility. Its fancy name is “line continuation symbol”.

If you’re used to write shell scripts, remember that the line continuation symbol is not at the end of the line, but at
the beginning of the next one.

Vim help :help cmdline-special :help line-continuation A Complete Example Let’s summarize most of what we saw in this
article with a final example. We want to:

Create the user command DevDocs. This command will automatically open the website https://devdocs.io/ and search the
word under the cursor.  Map the command to <leader>D in NORMAL mode. This mapping will be available for python, ruby,
JavaScript, go, html, and PHP filetypes.  Here’s a possible solution:

augroup vimrc autocmd!  augroup END

command! -nargs=? DevDocs call system('xdg-open https://devdocs.io/#q=<args>')

autocmd vimrc FileType python,ruby,javascript,go,html,php nnoremap <buffer><leader>D execute "DevDocs " .
expand('<cword>')<CR> We first declare an autocommand group vimrc.  We declare the user command DevDocs, accepting 0 or
1 argument.  We declare an autocommand linked to the event FileType. We indicate the filetypes which will trigger the
autocommand.  We use the special argument <buffer> to make the mapping only available in the current buffer. Without
that, the mapping would be available in every buffer regardless of the filetype.  The autocommand use expand('<cword>'),
which is replaced by the word under the cursor.  The event FileType can be useful to assign precise mappings to a whole
range of filetypes. We need, with this event, to give filetypes as autocommand patterns (like python or ruby for
example). Remember that you can output the filetype of the current buffer with :set filetype?.

The binary xdg-open is only available for Linux-based systems. If you want the autocommand to work on macOS too, you can
use the following:

command -nargs=? DevDocs call system('type open &>/dev/null && open https://devdocs.io/#q=<args> || xdg-open
https://devdocs.io/#q=<args>') The autocommand verifies if the binary open exists (for macOS) and, if it doesn’t, it
uses xdg-open.

Take Control of Your Vim Destiny Creating your own functions, commands, and mapping for tedious operations will help you
focus on more important tasks. Additionally, you’ll bring more efficient in your whole workflow. How great is that?

Let’s summarize what we saw in this article:

You can use the command :verbose to output where an abbreviation, option, mapping, or user command, is defined.  Special
arguments are available for your mappings to extend its power.  Operator pending map allow you to define motions for
operators.  The command :execute can execute a string as if it was a command.  Autocommands can run a defined command
when an event is triggered.  You can use autocommand groups to organize your autocommand.  Autocommand groups are
mandatory if you don’t want to add multiple times the same command in the autocommand list. It can happen when a
Vimscript file is loaded multiple time (like your vimrc).  Custom functions can execute numerous Vim commands one after
the other.  It’s better to autoload custom functions to be able to use namespaces and for Vim to start quicker.  User
commands are commands you can personalize for your own needs.  A last tip: if you want the list of Vimscript functions
you can use, split in different category (like “Variables” or “Date and Time”), you can look at :help function-list.


tip_vim_map_EOF
) | mypager
