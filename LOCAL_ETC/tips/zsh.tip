(
cat << tip_zsh_EOF_1
${E_BOLD}${E_WHITE_FG}${(C)${0/tip_/}:t:r} Tips${E_RESET}

${E_CYAN_FG}Search headers: STRINGS ARRAYS PARAM TYPESET READ REDIRECTION BUILTIN VI ${E_RESET}

${E_WHITE_FG}Operators${E_RESET}
In the native mode of operation, the following operators are supported (listed in decreasing order of precedence):

${E_CYAN_FG}= += -= *= /= %= &= ^= |= <<= >>= &&= ||= ^^= **= ${E_WHITE_FG}assignment${E_RESET}
${E_CYAN_FG}                                    + - ! ~ ++ -- ${E_WHITE_FG}unary plus/minus, logical NOT, complement, {pre,post}{in,de}crement${E_RESET}
${E_CYAN_FG}                                               ** ${E_WHITE_FG}exponentiation${E_RESET}
${E_CYAN_FG}                                            * / % ${E_WHITE_FG}multiplication, division, modulus (remainder)${E_RESET}
${E_CYAN_FG}                                              + - ${E_WHITE_FG}addition, subtraction${E_RESET}
${E_CYAN_FG}                                        < > <= >= ${E_WHITE_FG}comparison${E_RESET}
${E_CYAN_FG}                                            == != ${E_WHITE_FG}equality and inequality${E_RESET}
${E_CYAN_FG}                                               && ${E_WHITE_FG}logical AND${E_RESET}
${E_CYAN_FG}                                            || ^^ ${E_WHITE_FG}logical OR, XOR${E_RESET}
${E_CYAN_FG}                                              ? : ${E_WHITE_FG}ternary operator${E_RESET}
${E_CYAN_FG}                                                , ${E_WHITE_FG}comma operator${E_RESET}
${E_CYAN_FG}                                            << >> ${E_WHITE_FG}bitwise shift left, right${E_RESET}
${E_CYAN_FG}                                                & ${E_WHITE_FG}bitwise AND${E_RESET}
${E_CYAN_FG}                                                ^ ${E_WHITE_FG}bitwise XOR${E_RESET}
${E_CYAN_FG}                                                | ${E_WHITE_FG}bitwise OR${E_RESET}
 The  operators  ‘&&’,  ‘||’,  ‘&&=’, and ‘||=’ are short-circuiting, and only one of the latter two expressions in a ternary operator is evaluated.
 Note the precedence of the bitwise AND, OR, and XOR operators.

${E_WHITE_FG}CONDITIONAL EXPRESSIONS${E_RESET}
       A  conditional  expression  is  used  with the [[ compound command to test attributes of files and to compare strings.  Each expression can be con‐
       structed from one or more of the following unary or binary expressions:

       ${E_WHITE_FG}-a${E_RESET} file
              true if file exists.

       ${E_WHITE_FG}-b${E_RESET} file
              true if file exists and is a block special file.

       ${E_WHITE_FG}-c${E_RESET} file
              true if file exists and is a character special file.

       ${E_WHITE_FG}-d${E_RESET} file
              true if file exists and is a directory.

       ${E_WHITE_FG}-e${E_RESET} file
              true if file exists.

       ${E_WHITE_FG}-f${E_RESET} file
              true if file exists and is a regular file.

       ${E_WHITE_FG}-g${E_RESET} file
              true if file exists and has its setgid bit set.

       ${E_WHITE_FG}-h${E_RESET} file
              true if file exists and is a symbolic link.

       ${E_WHITE_FG}-k${E_RESET} file
              true if file exists and has its sticky bit set.

       ${E_WHITE_FG}-n${E_RESET} string
              true if length of string is non-zero.

       ${E_WHITE_FG}-o${E_RESET} option
              true if option named option is on.  option may be a single character, in which case it is a single letter option  name.   (See  the  section
              ‘Specifying Options’.)

              When no option named option exists, and the POSIX_BUILTINS option hasn’t been set, return 3 with a warning.  If that option is set, return 1
              with no warning.

       ${E_WHITE_FG}-p${E_RESET} file
              true if file exists and is a FIFO special file (named pipe).

       ${E_WHITE_FG}-r${E_RESET} file
              true if file exists and is readable by current process.

       ${E_WHITE_FG}-s${E_RESET} file
              true if file exists and has size greater than zero.

       ${E_WHITE_FG}-t${E_RESET} fd  true if file descriptor number fd is open and associated with a terminal device.  (note: fd is not optional)

       ${E_WHITE_FG}-u${E_RESET} file
              true if file exists and has its setuid bit set.

       ${E_WHITE_FG}-v${E_RESET} varname
              true if shell variable varname is set.

       ${E_WHITE_FG}-w${E_RESET} file
              true if file exists and is writable by current process.

       ${E_WHITE_FG}-x${E_RESET} file
              true  if  file  exists  and is executable by current process.  If file exists and is a directory, then the current process has permission to
              search in the directory.

       ${E_WHITE_FG}-z${E_RESET} string
              true if length of string is zero.

       ${E_WHITE_FG}-L${E_RESET} file
              true if file exists and is a symbolic link.

       ${E_WHITE_FG}-O${E_RESET} file
              true if file exists and is owned by the effective user ID of this process.

       ${E_WHITE_FG}-G${E_RESET} file
              true if file exists and its group matches the effective group ID of this process.

       ${E_WHITE_FG}-S${E_RESET} file
              true if file exists and is a socket.

       ${E_WHITE_FG}-N${E_RESET} file
              true if file exists and its access time is not newer than its modification time.

       file1 ${E_WHITE_FG}-nt${E_RESET} file2
              true if file1 exists and is newer than file2.

       file1 ${E_WHITE_FG}-ot${E_RESET} file2
              true if file1 exists and is older than file2.

       file1 ${E_WHITE_FG}-ef${E_RESET} file2
              true if file1 and file2 exist and refer to the same file.

       string ${E_WHITE_FG}=${E_RESET} pattern
       string ${E_WHITE_FG}==${E_RESET} pattern
              true if string matches pattern.  The two forms are exactly equivalent.  The ‘=’ form is the traditional shell syntax (and hence the only one
              generally used with the test and [ builtins); the ‘==’ form provides compatibility with other sorts of computer language.

       string ${E_WHITE_FG}!=${E_RESET} pattern
              true if string does not match pattern.

       string ${E_WHITE_FG}=~${E_RESET} regexp
              true if string matches the regular expression regexp.  If the option RE_MATCH_PCRE is set regexp is tested as a PCRE regular expression  us‐
              ing  the  zsh/pcre module, else it is tested as a POSIX extended regular expression using the zsh/regex module.  Upon successful match, some
              variables will be updated; no variables are changed if the matching fails.

              If the option BASH_REMATCH is not set the scalar parameter MATCH is set to the substring that matched the pattern and the integer parameters
              MBEGIN and MEND to the index of the start and end, respectively, of the match in string, such that if string is contained  in  variable  var
              the  expression  ‘\${var[\$MBEGIN,\$MEND]}’  is identical to ‘\$MATCH’.  The setting of the option KSH_ARRAYS is respected.  Likewise, the array
              match is set to the substrings that matched parenthesised subexpressions and the arrays mbegin and mend to the indices of the start and  end
              positions,  respectively, of the substrings within string.  The arrays are not set if there were no parenthesised subexpressions.  For exam‐
              ple, if the string ‘a short string’ is matched against the regular expression ‘s(...)t’, then (assuming the option KSH_ARRAYS  is  not  set)
              MATCH,  MBEGIN  and  MEND  are  ‘short’,  3 and 7, respectively, while match, mbegin and mend are single entry arrays containing the strings
              ‘hor’, ‘4’ and ‘6’, respectively.

              If the option BASH_REMATCH is set the array BASH_REMATCH is set to the substring that matched the pattern followed by  the  substrings  that
              matched parenthesised subexpressions within the pattern.

       string1 ${E_WHITE_FG}<${E_RESET} string2
              true if string1 comes before string2 based on ASCII value of their characters.

       string1 ${E_WHITE_FG}>${E_RESET} string2
              true if string1 comes after string2 based on ASCII value of their characters.

       exp1 ${E_WHITE_FG}-eq${E_RESET} exp2
              true  if  exp1  is  numerically equal to exp2.  Note that for purely numeric comparisons use of the ((...)) builtin described in the section
              ‘ARITHMETIC EVALUATION’ is more convenient than conditional expressions.

       exp1 ${E_WHITE_FG}-ne${E_RESET} exp2
              true if exp1 is numerically not equal to exp2.

       exp1 ${E_WHITE_FG}-lt${E_RESET} exp2
              true if exp1 is numerically less than exp2.

       exp1 ${E_WHITE_FG}-gt${E_RESET} exp2
              true if exp1 is numerically greater than exp2.

       exp1 ${E_WHITE_FG}-le${E_RESET} exp2
              true if exp1 is numerically less than or equal to exp2.

       exp1 ${E_WHITE_FG}-ge${E_RESET} exp2
              true if exp1 is numerically greater than or equal to exp2.

       ${E_WHITE_FG}(${E_RESET} exp ${E_WHITE_FG})${E_RESET}
              true if exp is true.

       ${E_WHITE_FG}!${E_RESET} exp  true if exp is false.

       exp1 ${E_WHITE_FG}&&${E_RESET} exp2
              true if exp1 and exp2 are both true.

       exp1 ${E_WHITE_FG}||${E_RESET} exp2
              true if either exp1 or exp2 is true.

 

${E_WHITE_FG}Dead Tilde${E_RESET}
Compose Key:<Right><Alt>

For á you press Compose+' then a
For € you press Compose+= then e

etc...

${E_WHITE_FG}Sudo Execution${E_RESET}
Not working: sudo echo 300 > /sys/block/md0/md/stripe_cache_size"

The "echo 300" is executed using sudo, which outputs 300 to stdout in the normal way. Then as your normal user, you are
trying to take that output and write to /sys/

Sudo isn't a magic command that elevates privileges for your whole command line. It takes the arguments you passed to
it and executes them as a program. Bash (which is running as a normal user) executes 'sudo echo 300' then takes that
output and tries to write it to a file. Note that the writing to the file is done by zsh which is running as the
normal user.

This should work:

sudo zsh -c "echo 300 > /sys/block/md0/md/stripe_cache_size"

sudo will execute zsh with higher privileges, and then that root zsh will execute the whole command.

${E_WHITE_FG}Redirect output of command${E_RESET}
<(command)

${E_WHITE_FG}Redirect output of command to another command${E_RESET}
< <(command)

As in:

while read X;do
	do_something_with_X
done< <(command)

${E_WHITE_FG}Redirect output of command to another command using a different file descriptor${E_RESET}

while IFS= read -ru3 LINE || [ -n "\$LINE" ]; do
	if [[ \${LINE:l} =~ "interfacesadded" && \${LINE:l} =~ "terminal" ]];then
		win_max terminal
	elif [[ \${LINE:l} =~ "startservicebyname" ]];then
		WAIT_FOR=deluge
	elif [[ \${LINE:l} =~ "desktop" ]];then
		if [[ -n \${WAIT_FOR} && \${LINE:l} =~ \${WAIT_FOR} ]];then
			win_max \${WAIT_FOR}
			WAIT_FOR=''
		fi
	fi
done 3< <( dbus-monitor | grep --line-buffered -i "startservicebyname\|desktop\|interfacesadded")
${E_WHITE_FG}See also ${E_CYAN_FG}REDIRECTION${E_RESET}


${E_WHITE_FG}Find command regex types${E_RESET}
find: valid -regextype values
-----------------------------
‘findutils-default’
‘ed’
‘emacs’
‘gnu-awk’
‘grep’
‘posix-awk’
‘awk’
‘posix-basic’
‘posix-egrep’
‘egrep’
‘posix-extended’
‘posix-minimal-basic’
‘sed’
-----------------------------

${E_WHITE_FG}Embed foreign script within zsh script${E_RESET}
inline_edit () {
	local PROMPT=${1}
	local CUR_VALUE=${2}
	local PERL_SCRIPT

	read -r -d '' PERL_SCRIPT <<'___EOF'
	use warnings;
	use strict;
	use Term::ReadLine;

	my $term = new Term::ReadLine 'gsq';
	$term->parse_and_bind("set editing-mode vi");

	system('sleep .1;xdotool key Home &');
	while ( defined ($_ = $term->readline($ARGV[0],$ARGV[1])) ) {
		print $_;
		exit;
	}
___EOF

perl -e "$PERL_SCRIPT" ${PROMPT} ${CUR_VALUE}
}

${E_WHITE_FG}Reformat text with long lines${E_RESET}
fold -w120 -s <(sed -e 's/^ *//g' -e 's/\t/ /g' -e 's/  / /g' zsh_redir.txt)

${E_WHITE_FG}Get last field with cut${E_RESET}
VAL=(echo \${Z} | rev | cut -d'|' -f1 | rev)

${E_WHITE_FG}Test for empty response from read -sk1 RESPONSE${E_RESET}
[[ \${RESPONSE} == \$'\x0A' ]] && exit

${E_MAGENTA_FG}Order of Operations ${E_WHITE_FG}PEMDAS${E_RESET}
The order of operations can be remembered by the acronym PEMDAS,
which stands for: parentheses, exponents, multiplication and division from left to right,
and addition and subtraction from left to right. If there are no parentheses or exponents,
start with multiplication and division from left to right.

${E_MAGENTA_FG}Unique HEAD lines in sorted list${E_RESET}
LAST_HEAD=?
for L in \${LIST};do
	HEAD=\${L:h}
	TAIL=\${L:t}
	[[ \${LAST_HEAD} != \${HEAD} ]] && echo "\n\${E_WHITE_FG}\${HEAD}\${E_RESET}"
	echo "\${TAIL}"
	LAST_HEAD=\${HEAD}
done

${E_MAGENTA_FG}ZSH Redirecting only stderr to a pipe.${E_RESET}
==========================================
exec 3>&1                              # Save current "value" of stdout.
ls -l 2>&1 >&3 3>&- | grep bad 3>&-    # Close fd 3 for 'grep' (but not 'ls').
#              ^^^^   ^^^^
exec 3>&-                              # Now close it for the remainder of the script.
==========================================

${E_MAGENTA_FG}Unique Lines (no sort)${E_RESET}
awk '!x[\${0}]++'

${E_MAGENTA_FG}Counting chars in a string${E_RESET}
MATCHED=\$(awk '{print gsub(/\|/,"")}' <<<\${STRING}) # Count pipe delimiters

${E_MAGENTA_FG}Mounting Notes${E_RESET}
Remount / as RW
mount -o rw,remount /

Mount Mac drive as RW
sudo mount -t hfsplus -o force,rw /dev/sdb2 /media/kmiller/MAC_DRIVE

${E_WHITE_FG}File to variable ${E_RESET}
var=\$(< file)

${E_WHITE_FG}Command to variables with read${E_RESET}
read -r var1 var2 var3 < <(COMMAND)
Ex: read -r WEEK YEAR MONTH DAY HOUR MINUTE SECOND < <(date +'%W %Y %m %d %H %M %S')

${E_WHITE_FG}Using Command Substitution and the Here-String${E_RESET}
read -r var1 var2 var3 <<< "101 202 303"
Ex: read -r WEEK YEAR MONTH DAY HOUR MINUTE SECOND <<< "$(date +'%W %Y %m %d %H %M %S')"

${E_WHITE_FG}Changing the Delimiter${E_RESET}
IFS='@' read -r WEEK_NO DATE_TIME WEEK_DAY <<< "$(date +'%W@%F %T@%A')"

${E_WHITE_FG}Using an Array${E_RESET}
readarray -d' ' -t ARR <<< "$(date +'%W %Y %m %d %H %M %S')"
The default delimiter used by the readarray command is a newline character. 
Change the delimiter using the -d option.

${E_MAGENTA_FG}STRINGS${E_RESET}
${E_WHITE_FG}=======${E_RESET}
${E_WHITE_FG}LENGTH${E_RESET}
Get the length of a string with #. This is similar to string length in fish.

str="abcdefghijklmnopqrstuvwxyz"
echo \${#str}
26

${E_WHITE_FG}PAD/TRIM${E_RESET}
Left pad a string with the l expansion flag. Right pad a string with the r expansion flag. This is similar to string pad in fish.

str="abc"
echo \${(l(10)(-))str}
-------abc
echo \${(r(10)(ABC))str}
abcABCABCA

The docs can be confusing. They show the syntax as l:expr::string1::string2:, which uses colons instead of the more 
readable parens. Don't be confused by the double colon, which is really just the closing/opening combo )(. 
If you choose to follow the docs, the syntax looks like this:

str="abc"
echo \${(r:10::-:)str}
abc-------

Trim requires the use of sed. This is similar to string trim in fish.

str="   \t\t\t   abc   \t\t\t   "
echo "\$str" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*\$//'
abc

Trimming strings other than whitespace can be accomplished with the '#' and '%' parameter expansions.

# removes at the start of the string. # is the shortest match, and ## is the longest.

str="a/b/c/d/e/f/g"
echo \${str#*/}
b/c/d/e/f/g
echo \${str##*/}
g

% removes at the end of the string. % is the shortest match, and %% is the longest.

str="a/b/c/d/e/f/g"
echo \${str%/*}
a/b/c/d/e/f
echo \${str%%/*}
a

${E_WHITE_FG}SUBSTRING${E_RESET}
Get a substing from string with comma indexing [start,end]. This is similar to string sub in fish.

str="abcdefghijklmnopqrstuvwxyz"
echo \${str[3,6]}
cdef

You can also use the \${var:offset:length} syntax:

str="abcdefghijklmnopqrstuvwxyz"
echo \${str:3:6}
defghi
echo \${str:(-4)}
wxyz

${E_WHITE_FG}REPEAT${E_RESET}
Repeat a string by using printf. This is similar to string repeat in fish.

str="abc"
abc3=\$(printf "\$str%.0s" {1..3})
echo \$abc3
abcabcabc

${E_WHITE_FG}JOIN/SPLIT${E_RESET}
Join strings with the j expansion flag. This is similar to string join in fish.

words=(abc def ghi)
sep=:
echo \${(pj.\$sep.)words}
abc:def:ghi

A common join seperator is the null character. This is similar to string join0 in fish.

words=(abc def ghi)
sep="\x00"
echo \${\${(pj.\$sep.)words}:q}
abc\x00def\x00ghi

Split strings with the s expansion flag. This is similar to string split in fish.

@: Preserves empty elements. "In double quotes, array elements are put into separate words".
p: Use print syntax. "Recognize the same escape sequences as the print."
s: Split. "Force field splitting at the separator string."
str="a:b::c"
sep=:
printf '%s\n' "\${(@ps.\$sep.)str}"
a
b

c

A common split seperator is the null character. This is similar to string split0 in fish.

str="abc\x00def\x00ghi"
sep="\x00"
arr=(\${(ps.\$sep.)str})
printf '%s\n' \$arr
abc
def
ghi

${E_WHITE_FG}UPPER/LOWER${E_RESET}
Convert a string to uppercase with the u modifier. This is similar to string upper in fish.

str="AbCdEfGhIjKlMnOpQrStUvWxYz"
echo "\${str:u}"
ABCDEFGHIJKLMNOPQRSTUVWXYZ

Convert a string to lowercase with the l modifier. This is similar to string lower in fish.

str="AbCdEfGhIjKlMnOpQrStUvWxYz"
echo "\${str:l}"
abcdefghijklmnopqrstuvwxyz

${E_WHITE_FG}MATCH/REPLACE${E_RESET}
The zsh/pcre module allows you to match strings in Zsh.

zmodload zsh/pcre
str="The following are zip codes: 78884 90210 99513"
setopt REMATCH_PCRE
[[ \$str =~ '\d{5}' ]] && echo "contains zips" || echo "no zips"
contains zips

zmodload zsh/pcre
str="https://gist.github.com/mattmc3/110eca74a876154c842423471b8e5cbb"
pattern='^(ftp|https?)://'
pcre_compile -smx \$pattern
pcre_match -b -- \$str
[[ \$? -eq 0 ]] && echo "match: \$MATCH, position: \$ZPCRE_OP" || echo "no match"
match: https://, position: 0 8

Replacing leverages the s modifier. 'g' Means globally.

url=https://github.com/zsh-users/zsh-autosuggestions.git
url=\${url%.git}
url=\${url:gs/\@/-AT-}
url=\${url:gs/\:/-COLON-}
url=\${url:gs/\//-SLASH-}
echo \$url
https-COLON--SLASH--SLASH-github.com-SLASH-zsh-users-SLASH-zsh-autosuggestions

${E_WHITE_FG}COLLECT${E_RESET}
There are lots of different ways strings need collected. Sometimes you have a string with embedded newlines 
that you need to split into an array, preserving blanks.

str=\$(printf '%s\n' four score '' "&" '' seven years ago)
echo \${(q-)str}
'four
score

&

seven
years
ago'
# remove blanks
arr=(\${(f@)str})
echo \$#arr
6
# preserve blanks
arr=("\${(f@)str}")
echo \$#arr
8

${E_MAGENTA_FG}ARRAYS${E_RESET}
${E_WHITE_FG}======${E_RESET}
${E_WHITE_FG}Regular arrays${E_RESET}
typeset -a TEST
TEST=("one" "two" "three times") # Assignment

${E_WHITE_FG}To get index:${E_RESET}
for I in \${arr}; do
	echo "index \${arr[(ie)\${I}]}";
done

${E_WHITE_FG}To delete an element from a regular array: ${E_RESET}
TEST[N]=() # Method 1

TEST=("\${(@)TEST:#two}") # Method 2

TEST=(\${TEST[@]/#%three times}) # Method 2a
The #% prefix forces whole word matching.  Very important if the elements contain spaces!

${E_WHITE_FG}To test for element in array${E_RESET}
foo=(a b c)
[[ \${foo[(i)b]} -le \${#foo} ]] && echo yes || echo no

You can see what you get out of those two expressions by simply doing:

echo \${foo[(i)a]} \${#foo}
1 3

echo \${foo[(i)b]} \${#foo}
2 3

echo \${foo[(i)c]} \${#foo}
3 3

echo \${foo[(i)d]} \${#foo}
4 3

Method 2: 
if ((\${array}[(Ie)\${value}])); then
	echo "HIT"
fi

${E_WHITE_FG}Searching for text${E_RESET}

Array snippet - elements 14:20

5013:13:126:miles
5014:14:126:miles
5017:17:126:miles:last
5088:8:128:miles:last
5054:14:127:miles:last
5250:10:132:miles
5276:36:132:miles

echo \${LIST[(r)*last]} 5017:17:126:miles:last
echo \${LIST[(R)*last]} 5054:14:127:miles:last
echo \${LIST[(i)*last]} 16
echo \${LIST[(I)*last]} 18


${E_WHITE_FG}To prepend an element in array${E_RESET}
ARRAY=('PREPEND' \${ARRAY[@]})

${E_WHITE_FG}Associative arrays${E_RESET}
typeset -A ARR
ARR[key]=value # Assignment

\${(k)ARR} = access keys
\${(v)ARR} = access values

${E_WHITE_FG}To delete elements from a associative array:${E_RESET}
unset "associative_array[key]"

And with an associative array such as:

typeset -A h
h[foo]=bar
h[empty]=""

To delete the empty ones:

h=("\${(kv@)h[(R)?*]}")

${E_WHITE_FG}Word Splitting${E_RESET}
To supress: LIST=("\${(@f)\$(command)}") 
LIST = array of command results i.e. LIST = ( "\${ (@f) \$(command) }" )

To force: \${=LIST}

var="two words"
If you assign an element directly: DIR+=\${var}, no splitting takes place

${E_WHITE_FG}Reverse Lookups${E_RESET}
\${(k)ARRAY[(r)\${VALUE}]} reverse lookup

${E_WHITE_FG}Reverse Keys${E_RESET}
To reverse keys <=> values
In zsh, where the primary syntax for defining a hash is hash=(k1 v1 k2 v2...) like in perl

keys=( "\${(@k)hash}" )
values=( "\${(@v)hash}" )

typeset -A reversed
reversed=( "\${(@)values:^keys}" ) # Array zipping operator
Or using the Oa parameter expansion flag to reverse the order of the key+value list:

typeset -A reversed
reversed=( "\${(@kvOa)hash}" )

or using a loop:
for k v ( "\${(@kv}hash}" ) reversed[\$v]=\$k

The @ and double quotes is to preserve empty keys and values 

As the expansion of elements in associative arrays is in no particular order, if 
several elements of \$hash have the same value (which will end up being a key in 
\$reversed), you can't tell which key will be used as the value in \$reversed.

${E_WHITE_FG}loop${E_RESET}
You'd use the R hash subscript flag to get elements based on value instead of key, 
combined with e for exact (as opposed to wildcard) match, and then get the keys for 
those elements with the k parameter expansion flag:

for value ("\${(@u)hash}")
  print -r "elements with '\$value' as value: \${(@k)hash[(Re)\$value]}"

${E_WHITE_FG}perl approach${E_RESET}
zsh (contrary to ksh93) doesn't support arrays of arrays, but its variables can contain 
the NUL byte, so you could use that to separate elements if the elements don't otherwise 
contain NUL bytes, or use the \${(q)var} / \${(Q)\${(z)var}} to encode/decode a list using quoting.

typeset -A seen
for k v ("\${(@kv)hash}")
  seen[\$v]+=" \${(q)k}"

for k v ("\${(@kv)seen}")
  print -r "elements with '\$k' as value: \${(Q@)\${(z)v}}"

${E_WHITE_FG}ksh93${E_RESET}
ksh93 was the first shell to introduce associative arrays in 1993. The syntax for assigning 
values as a whole means it's very difficult to do it programmatically contrary to zsh, but 
at least it's somewhat justified in ksh93 in that ksh93 supports complex nested data structures.

In particular, here ksh93 supports arrays as values for hash elements, so you can do:

typeset -A seen
for k in "\${!hash[@]}"; do
  seen[\${hash[\$k]}]+=("\$k")
done

for k in "\${!seen[@]}"; do
  print -r "elements with '\$k' as value \${x[\$k][@]}"
done

${E_WHITE_FG}bash${E_RESET}
bash added support for associative arrays decades later, copied the ksh93 syntax, but not the other 
advanced data structures, and doesn't have any of the advanced parameter expansion operators of zsh.
(note that bash associative arrays don't support empty keys). 

In bash, you could use the quoted list approach mentioned in the zsh using printf %q or with newer 
versions \${var@Q}.

typeset -A seen
for k in "\${!hash[@]}"; do
  printf -v quoted_k %q "\$k"
  seen[\${hash[\$k]}]+=" \$quoted_k"
done

for k in "\${!seen[@]}"; do
  eval "elements=(\${seen[\$k]})"
  echo -E "elements with '\$k' as value: \${elements[@]}"
done

Since bash associative arrays don't support the empty value as a key, it won't 
work if some of \$hash's values are empty. You could choose to replace the empty string with some place 
holder like <EMPTY> or prefix the key with some character that you'd later strip for display.


${E_WHITE_FG}Some common array flags${E_RESET}
\${(k)ARRAY} = keys (assoc array)
\${(v)ARRAY} = values (assoc array)
\${(kv)ARRAY} = keys and values (assoc array)
\${(o)ARRAY} = lex sort asc
\${(on)ARRAY} = numeric element sort asc
\${(On)ARRAY} = numeric element sort desc
\${(O)ARRAY} = lex sort desc
\${(a)ARRAY} = index sort
\${(Oa)ARRAY} = index sort desc
\${(q)ARRAY} = quoted elements
\${(Q)ARRAY} = strip quoted elements
\${(L)ARRAY} = lower case elements
\${(U)ARRAY} = upper case elements
\${(C)ARRAY} = upper case first letter of elements
\${(u)ARRAY} = unique elements
\${(P)ARRAY} = variable reference (any variable - not only arrays)

${E_WHITE_FG}Variable references:${E_RESET}
typeset -a ARRAY_1=(one two three)
typeset -A ARRAY_2=()

ARRAY_2[one]=1
ARRAY_2[two]=2
ARRAY_2[three]=3

STR="ARRAY_1"
echo "REAL:\${#ARRAY_1}" # Number of elements
echo "REAL:\${ARRAY_1}"  # Values

echo "REF:\${(P)#STR}" # Number of elements (ref)
echo "REF:\${(P)STR}"  # Values (ref)

STR="ARRAY_2"
echo "REAL:\${#ARRAY_2}"     # Number of elements
echo "REAL:\${(kv)ARRAY_2}"  # Keys and values
echo "REAL:\${ARRAY_2[two]}" # Value for key

echo "REF:\${(P)#STR}"        # Number of elements (ref)
echo "REF:\${(kv)\${(P)STR}}"  # Keys and values (ref)
echo "REF:\${\${(P)STR}[two]}" # Value for key (ref)

${E_WHITE_FG}Some useful gymnastics${E_RESET}
\${ARRAY[(ie)\${ELEMENT}]} = return index of element

${E_MAGENTA_FG}Some common filename modifiers:${E_RESET}
${E_CYAN_FG}Example${E_RESET}:${E_WHITE_FG}VAR=/one/two/three/xxx.txt${E_RESET}
\${VAR:t} = xxx.txt, the filename w/o path like basename
\${VAR:h} = /one/two/three, the path like dirname
\${VAR:e} = txt, the file extension
\${VAR:r} = /one/two/three/xxx, the filename without extension
\${VAR:t:r} = xxx, the filename without path or extension by combining flags

${E_WHITE_FG}Substring matching:${E_RESET}

${E_MAGENTA_FG}To match a string with a substring, we can use:${E_RESET}
\${str#substr} Deletes shortest match of \${substr} from front of \${str}
\${str##substr} Deletes longest match of \${substr} from front of \${str}

${E_WHITE_FG}WORD='hello - world - how - are - you'${E_RESET}

${E_MAGENTA_FG}For example: remove part before 'how*', or o*${E_RESET}

\${WORD%how*} == 'hello - world - '
\${WORD%o*} == 'hello - world - how - are - y'
\${WORD%%o*} == 'hell'

${E_MAGENTA_FG}Or remove the part after '* - '${E_RESET}

\${WORD#* - } = 'world - how - are - you'
\${WORD##* - } = 'you'


tip_zsh_EOF_1

local VAR=/one/two/three/xxx.txt
echo "Live Code..."
echo "${E_GREEN_FG}\${VAR:t} -> ${E_WHITE_FG}${VAR:t}${E_RESET}"
echo "${E_GREEN_FG}\${VAR:h} -> ${E_WHITE_FG}${VAR:h}${E_RESET}"
echo "${E_GREEN_FG}\${VAR:e} -> ${E_WHITE_FG}${VAR:e}${E_RESET}"
echo "${E_GREEN_FG}\${VAR:r} -> ${E_WHITE_FG}${VAR:r}${E_RESET}"
echo "${E_GREEN_FG}\${VAR:t:r} -> ${E_WHITE_FG}${VAR:t:r}${E_RESET}\n"

cat << tip_zsh_EOF_2
${E_WHITE_FG}Word Splitting${E_RESET}
\${(s/:/)PATH}

${E_MAGENTA_FG}Tests${E_RESET}
-----
(( \${1} )) && echo "\${1} is not missing" || echo "\${1} is missing"
(( \${2} )) && echo "\${2} is not missing" || echo "\${2} is missing"

[[ \${1} -eq 1 ]] && echo "\${1} is 1"
[[ \${1} -eq 1 ]] && echo "\${1} is 1" || echo "\${1} not 1"
[[ \${1} -eq 1 && \${2} -eq 1 ]] && echo "\${1} AND \${2} are 1" || echo "\${1} not 1 OR \${2} not 1"

${E_WHITE_FG}Testing STDIN, STDOUT, STDDERR${E_RESET}
if [[ -t 0 ]];then
	echo "input is from terminal"
else
	echo "input is redirected"
fi

if [[ -t 1 ]];then
	echo "output is to terminal"
else
	echo "output is redirected"
fi

if [[ -t 2 ]];then
	echo "stderr goes to terminal"
else
	echo "stderr is redirected"
fi

${E_WHITE_FG}Testing for piped input${E_RESET}
PIPE=false
if [[ ! -t 0 ]];then
	PIPE=true
fi
if [[ \${PIPE} == "false" ]];then
	echo "Args: \${@}"
else
	{ read a; echo "Piped Args:\${a}" } 
fi

${E_WHITE_FG}Example Output${E_RESET}
--------------
echo "xxx.txt" | testit -s A B
Args: -s A B
Piped Args:xxx.txt

${E_MAGENTA_FG}String Indexing${E_RESET}
---------------
$ a=abcdefghijklmnopqrstuvwxyz b=xyzd
$ echo \${a[(i)[\${b}]]}
4

With i, you get the index of the first match 
(or one plus the length of the haystack if 
there's no match). With I instead, you get 
the last match (or 0 if there's no match).

${E_MAGENTA_FG}Increment Operator${E_RESET}
------------------
for i in {1..7}
do
	   # Stuff
done

${E_MAGENTA_FG}DEBUG Arrays${E_RESET}

funcfiletrace
-------------
This array contains the absolute line numbers and corresponding file names for the point where 
the current function, sourced file, or (if EVAL_LINENO is set) eval command was called. The 
array is of the same length as funcsourcetrace and functrace, but differs from funcsourcetrace 
in that the line and file are the point of call, not the point of definition, and differs 
from functrace in that all values are absolute line numbers in files, rather than relative to 
the start of a function, if any.

funcsourcetrace
---------------
This array contains the file names and line numbers of the points where the functions, sourced 
files, and (if EVAL_LINENO is set) eval commands currently being executed were defined. The 
line number is the line where the 'function name' or 'name ()' started. In the case of an 
autoloaded function the line number is reported as zero. The format of each element is 
filename:lineno.

For functions autoloaded from a file in native zsh format, where only the body of the function 
occurs in the file, or for files that have been executed by the source or '.' builtins, the 
trace information is shown as filename:0, since the entire file is the definition. The source 
file name is resolved to an absolute path when the function is loaded or the path to it
otherwise resolved.

Most users will be interested in the information in the funcfiletrace array instead.

funcstack
---------
This array contains the names of the functions, sourced files, and (if EVAL_LINENO is set) eval 
commands. currently being executed. The first element is the name of the function using the 
parameter.

The standard shell array zsh_eval_context can be used to determine the type of shell construct 
being executed at each depth: note, however, that is in the opposite order, with the most 
recent item last, and it is more detailed, for example including an entry for toplevel, the main 
shell code being executed either interactively or from a script, which is not present in 
${funcstack}.

functrace
---------
This array contains the names and line numbers of the callers corresponding to the functions 
currently being executed. The format of each element is name:lineno. Callers are also shown for 
sourced files; the caller is the point where the source or '.' command was executed.


${E_WHITE_FG}PARAMETER EXPANSION${E_RESET}
-------------------
       The  character  '\$'  is	used to introduce parameter expansions.  See zshparam(1) for a description of
       parameters, including arrays, associative arrays, and sub‐ script notation to access individual array
       elements.

       Note in particular the fact that words of unquoted parameters are not automatically split on whitespace
       unless the option SH_WORD_SPLIT is set; see references to this option below for more details.  This is an
       important difference from other shells.

       In  the	expansions  discussed  below that require a pattern, the form of the pattern is the same as that
       used for filename generation; see the section 'Filename Generation'.  Note that these patterns, along
       with the replacement text of any substitutions, are themselves subject to parameter  expansion,	command
       substitu‐ tion, and arithmetic expansion.  In addition to the following operations, the colon modifiers
       described in the section 'Modifiers' in the section 'History Expan‐ sion' can be applied:  for example,
       \${i:s/foo/bar/} performs string substitution on the expansion of parameter \${i}.

       In the following descriptions, 'word' refers to a single word substituted on the command line, not necessarily
       a space delimited  word.   With	default  options, after the assignments:

	      array=("first word" "second word") scalar="only word"

       then  \${array}  substitutes  two  words,  'first  word'  and 'second word', and \${scalar} substitutes a single
       word 'only word'.  This may be modified by explicit or implicit word-splitting, however.  The full rules
       are complicated and are noted at the end.

       \${name}
	      The value, if any, of the parameter name is substituted.	The braces are required if the expansion is
	      to be followed by a  letter,  digit,  or	underscore that  is not to be interpreted as part of name.
	      In addition, more complicated forms of substitution usually require the braces to be present;
	      exceptions, which only apply if the option KSH_ARRAYS is not set, are a single subscript or any
	      colon modifiers appearing after the name, or  any  of  the  characters '^', '=', '~', '#' or '+'
	      appearing before the name, all of which work with or without braces.

	      If  name is an array parameter, and the KSH_ARRAYS option is not set, then the value of each element
	      of name is substituted, one element per word.  Other‐ wise, the expansion results in one word only;
	      with KSH_ARRAYS, this is the first element of an array.  No field splitting is done on the result
	      unless the SH_WORD_SPLIT option is set.  See also the flags = and s:string:.

       \${+name}
	      If name is the name of a set parameter '1' is substituted, otherwise '0' is substituted.

       \${name-word} \${name:-word}
	      If name is set, or in the second form is non-null, then substitute its value; otherwise substitute word.
	      In the second form name may be omitted, in which case word is always substituted.

       \${name+word} \${name:+word}
	      If name is set, or in the second form is non-null, then substitute word; otherwise substitute nothing.

       \${name=word} \${name:=word} \${name::=word}
	      In the first form, if name is unset then set it to word; in the second form, if name is unset or
	      null then set it to word; and in the third form, uncondi‐ tionally set name to word.  In all forms,
	      the value of the parameter is then substituted.

       \${name?word} \${name:?word}
	      In  the first form, if name is set, or in the second form if name is both set and non-null, then
	      substitute its value; otherwise, print word and exit from the shell.  Interactive shells instead
	      return to the prompt.  If word is omitted, then a standard message is printed.

       In any of the above expressions that test a variable and substitute an alternate word, note that you
       can use standard shell quoting in the word value  to  selec‐ tively override the splitting done by the
       SH_WORD_SPLIT option and the = flag, but not splitting by the s:string: flag.

       In the following expressions, when name is an array and the substitution is not quoted, or if the '(@)'
       flag or the name[@] syntax is used, matching and replace‐ ment is performed on each array element separately.


	      If the pattern matches the beginning of the value of name, then substitute the value of name with
	      the matched portion deleted; otherwise, just  substitute the value of name.  In the first form, the
	      smallest matching pattern is preferred; in the second form, the largest matching pattern is preferred.

       \${name%pattern} \${name%%pattern}
	      If  the  pattern	matches the end of the value of name, then substitute the value of name with
	      the matched portion deleted; otherwise, just substitute the value of name.  In the first form, the
	      smallest matching pattern is preferred; in the second form, the largest matching pattern is preferred.

       \${name:#pattern}
	      If the pattern matches the value of name, then substitute the empty string; otherwise, just substitute
	      the value of name.  If name is an array the  match‐ ing array elements are removed (use the '(M)'
	      flag to remove the non-matched elements).

       \${name:|arrayname}
	      If  arrayname  is  the name (N.B., not contents) of an array variable, then any elements contained in
	      arrayname are removed from the substitution of name.  If the substitution is scalar, either because
	      name is a scalar variable or the expression is quoted, the elements of arrayname are instead tested
	      against the entire expression.

       \${name:*arrayname}
	      Similar  to  the preceding substitution, but in the opposite sense, so that entries present in both
	      the original substitution and as elements of arrayname are retained and others removed.

       \${name:^arrayname} \${name:^^arrayname}
	      Zips two arrays, such that the output array is twice as long as the shortest (longest for ':^^')
	      of name and arrayname, with  the	elements  alternatingly being picked from them. For ':^', if one
	      of the input arrays is longer, the output will stop when the end of the shorter array is reached.  Thus,

		     a=(1 2 3 4); b=(a b); print \${a:^b}

	      will output '1 a 2 b'.  For ':^^', then the input is repeated until all of the longer array has been
	      used up and the above will output '1 a 2 b 3 a 4 b'.

	      Either  or  both	inputs	may be a scalar, they will be treated as an array of length 1 with the scalar
	      as the only element. If either array is empty, the other array is output with no extra elements inserted.

	      Currently the following code will output 'a b' and '1' as two separate elements, which can be
	      unexpected. The second print  provides  a  workaround  which should continue to work if this is changed.

		     a=(a b); b=(1 2); print -l "\${a:^b}"; print -l "\${\${a:^b}}"

       \${name:offset} \${name:offset:length}
	      This  syntax  gives effects similar to parameter subscripting in the form \${name}[start,end], but is
	      compatible with other shells; note that both offset and length are interpreted differently from the
	      components of a subscript.

	      If offset is non-negative, then if the variable name is a scalar substitute the contents starting
	      offset  characters  from	the  first  character  of  the string,	and if name is an array substitute
	      elements starting offset elements from the first element.  If length is given, substitute that many
	      characters or elements, otherwise the entire rest of the scalar or array.

	      A positive offset is always treated as the offset of a character or element in name from the first
	      character or element of the array  (this	is  different from native zsh subscript notation).  Hence 0
	      refers to the first character or element regardless of the setting of the option KSH_ARRAYS.

	      A negative offset counts backwards from the end of the scalar or array, so that -1 corresponds to
	      the last character or element, and so on.

	      When  positive,  length  counts  from the offset position toward the end of the scalar or array.
	      When negative, length counts back from the end.  If this results in a position smaller than offset,
	      a diagnostic is printed and nothing is substituted.

	      The option MULTIBYTE is obeyed, i.e. the offset and length count multibyte characters where appropriate.

	      offset and length undergo the same set of shell substitutions as for scalar assignment; in addition,
	      they  are  then  subject	to  arithmetic	evaluation.  Hence, for example

		     print \${foo:3} print \${foo: 1 + 2} print \${foo:\$(( 1 + 2))} print \${foo:\$(echo 1 + 2)}

	      all have the same effect, extracting the string starting at the fourth character of \${foo} if the
	      substitution would otherwise return a scalar, or the array starting at the fourth element if \${foo}
	      would return an array.  Note that with the option KSH_ARRAYS \${foo} always returns a scalar (regardless
	      of the use of the offset syntax) and a form such as \${foo[*]:3} is required to extract elements of
	      an array named foo.

	      If  offset  is  negative,  the - may not appear immediately after the : as this indicates the
	      \${name:-word} form of substitution.  Instead, a space may be inserted before the -.  Furthermore,
	      neither offset nor length may begin with an alphabetic character or & as these are  used	to
	      indicate	history-style modifiers.  To substitute a value from a variable, the recommended approach
	      is to precede it with a \$ as this signifies the intention (parameter substitu‐ tion can easily be
	      rendered unreadable); however, as arithmetic substitution is performed, the expression \${var: offs}
	      does work,  retrieving  the  offset from \${offs}.

	      For  further  compatibility with other shells there is a special case for array offset 0.  This usually
	      accesses the first element of the array.	However, if the substitution refers to the positional
	      parameter array, e.g. \${@} or \$*, then offset 0 instead refers to \${0}, offset 1 refers to \${1},  and
	      so  on.	In other words, the positional parameter array is effectively extended by prepending \${0}.
	      Hence \${*:0:1} substitutes \${0} and \${*:1:1} substitutes \${1}.

       \${name/pattern/repl} \${name//pattern/repl} \${name:/pattern/repl}
	      Replace  the  longest possible match of pattern in the expansion of parameter name by string repl.
	      The first form replaces just the first occurrence, the second form all occurrences, and the third
	      form replaces only if pattern matches the entire string.	Both pattern and repl are  subject  to
	      double-quoted substitution,  so  that expressions like \${name/\${opat}/\${npat}} will work, but obey
	      the usual rule that pattern characters in \${opat} are not treated specially unless either the option
	      GLOB_SUBST is set, or \${opat} is instead substituted as \${~opat}.

	      The pattern may begin with a '#', in which case the pattern must match at the start of the string,
	      or '%', in which case it must match at the end  of  the string, or '#%' in which case the pattern
	      must match the entire string.  The repl may be an empty string, in which case the final '/' may also
	      be omitted.  To quote the final '/' in other cases it should be preceded by a single backslash;
	      this is not necessary if the '/' occurs inside a substituted parameter.  Note also that the '#',
	      '%' and '#%' are not active if they occur inside a substituted parameter, even at the start.

	      If, after quoting rules apply, \${name} expands to an array, the replacements act on each element
	      individually.  Note also the effect of the I and S param‐ eter expansion flags below; however,
	      the flags M, R, B, E and N are not useful.

	      For example,

		     foo="twinkle twinkle little star" sub="t*e" rep="spy" print \${foo//\${~sub}/\${rep}} print
		     \${(S)foo//\${~sub}/\${rep}}

	      Here, the '~' ensures that the text of \${sub} is treated as a pattern rather than a plain string.
	      In the first case, the longest match for t*e  is	substi‐ tuted and the result is 'spy star',
	      while in the second case, the shortest matches are taken and the result is 'spy spy lispy star'.

       \${#spec}
	      If  spec	is  one of the above substitutions, substitute the length in characters of the result
	      instead of the result itself.  If spec is an array expres‐ sion, substitute the number of elements
	      of the result.  This has the side-effect that joining is skipped even in quoted  forms,  which  may
	      affect  other sub-expressions in spec.  Note that '^', '=', and '~', below, must appear to the left of
	      '#' when these forms are combined.

	      If  the option POSIX_IDENTIFIERS is not set, and spec is a simple name, then the braces are optional;
	      this is true even for special parameters so e.g. \${#}- and \${#}* take the length of the string \$- and
	      the array \$* respectively.  If POSIX_IDENTIFIERS is set, then braces are required for the # To be
	      treated  in this fashion.

       \${^spec}
	      Turn  on the RC_EXPAND_PARAM option for the evaluation of spec; if the '^' is doubled, turn it off.
	      When this option is set, array expansions of the form foo\${xx}bar, where the parameter xx is set
	      to (a b c), are substituted with 'fooabar foobbar foocbar' instead of the default 'fooa b cbar'.
	      Note that  an empty array will therefore cause all arguments to be removed.

	      Internally,  each such expansion is converted into the equivalent list for brace expansion.  E.g.,
	      \${^var} becomes {\${var}[1],\${var}[2],...}, and is processed as described in the section 'Brace Expansion'
	      below: note, however, the expansion happens immediately, with any explicit brace expansion happening
	      later.  If word splitting is also in effect the \${var}[N] may themselves be split into different
	      list elements.

       \${=spec}
	      Perform  word splitting using the rules for SH_WORD_SPLIT during the evaluation of spec, but regardless
	      of whether the parameter appears in double quotes; if the '=' is doubled, turn it off.  This forces
	      parameter expansions to be split into separate words before substitution, using IFS as a delimiter.
	      This is done by default in most other shells.

	      Note  that  splitting  is  applied  to  word in the assignment forms of spec before the assignment
	      to name is performed.  This affects the result of array assignments with the A flag.

       \${~spec}
	      Turn on the GLOB_SUBST option for the evaluation of spec; if the '~' is doubled, turn it off.  When this
	      option is set,  the  string  resulting  from  the expansion  will be interpreted as a pattern anywhere
	      that is possible, such as in filename expansion and filename generation and pattern-matching contexts
	      like the right hand side of the '=' and '!=' operators in conditions.

	      In nested substitutions, note that the effect of the ~ applies to the result of the current level of
	      substitution.  A surrounding pattern operation on the result  may  cancel it.  Hence, for example,
	      if the parameter foo is set to *, \${~foo//\*/*.c} is substituted by the pattern *.c, which may be
	      expanded by filename generation, but \${\${~foo}//\*/*.c} substitutes to the string *.c, which will
	      not be further expanded.

       If a \${...} type parameter expression or a \$(...) type command substitution is used in place of name
       above, it is expanded first and the result is used as if  it were  the  value  of  name.   Thus	it  is
       possible to perform nested operations:  \${\${foo#head}%tail} substitutes the value of \${foo} with both 'head'
       and 'tail' deleted.  The form with \$(...) is often useful in combination with the flags described next;
       see the examples below.	Each name or nested \${...} in  a  parameter expansion may also be followed by a
       subscript expression as described in Array Parameters in zshparam(1).

       Note  that  double  quotes  may appear around nested expressions, in which case only the part inside is
       treated as quoted; for example, \${(f)"\$(foo)"} quotes the result of \$(foo), but the flag '(f)' (see below)
       is applied using the rules for unquoted expansions.  Note further that quotes are themselves nested in
       this con‐ text;  for  example,  in  "\${(@f)"\$(foo)"}",  there are two sets of quotes, one surrounding
       the whole expression, the other (redundant) surrounding the \$(foo) as before.

${E_WHITE_FG}Parameter Expansion Flags${E_RESET}
-------------------------
       If the opening brace is directly followed by an opening parenthesis, the string up to the matching closing
       parenthesis will be taken as  alist  of  flags.   In cases  where repeating a flag is meaningful, the
       repetitions need not be consecutive; for example, '(q%q%q)' means the same thing as the more readable
       '(%%qqq)'.  The following flags are supported:

       #      Evaluate the resulting words as numeric expressions and output the characters corresponding to the resulting integer.  
              Note that this form is entirely distinct from use of the # Without parentheses.

              If the MULTIBYTE option is set and the number is greater than 127 (i.e. not an ASCII character) it is treated as a Unicode character.

       %      Expand  all % escapes in the resulting words in the same way as in prompts (see EXPANSION OF PROMPT SEQUENCES 
              in zshmisc(1)). If this flag is given twice, full prompt expansion is done on the resulting words, depending on the 
              setting of the PROMPT_PERCENT, PROMPT_SUBST and PROMPT_BANG options.

       @      In double quotes, array elements are put into separate words.  E.g., '"\${(@)foo}"' is equivalent to '"\${foo[@]}"' and 
              '"\${(@)foo[1,2]}"' is the  same  as '"\${foo}[1]" "\${foo}[2]"'.  This is distinct from field splitting by the f, s or z flags, 
              which still applies within each array element.

       A      Convert  the  substitution  into an array expression, even if it otherwise would be scalar.  This has lower precedence than subscripting, 
              so one level of nested expansion is required in order that subscripts apply to array elements.  Thus \${\${(A)name}[1]} yields the full 
              value of name when name is scalar.

              This assigns an array parameter with '\${...=...}', '\${...:=...}' or '\${...::=...}'.  If this flag is repeated (as in 'AA'), assigns an  
              associative array parameter. Assignment is made before sorting or padding; if field splitting is active, the word part is split before 
              assignment. The name part may be a subscripted range for ordinary arrays; when assigning an associative array,the  word  part  must
              be converted  to  an  array,  for  example  by  using '\${(AA)=name=...}' to activate field splitting.

              Surrounding  context  such  as  additional  nesting  or use of the value in a scalar assignment may cause the array to be joined back 
              into a single string again.

       a      Sort in array index order; when combined with 'O' sort in reverse array index order.  Note that 'a' is therefore equivalent to the  
              default but  'Oa'  is useful for obtaining an array's elements in reverse order.

       b      Quote  with  backslashes only  characters  thatare special to pattern matching. This is useful when the contents of the variable are to 
              be tested using GLOB_SUBST, including the \${~...} switch.  Quoting using one of the q family of flags does not work for this purpose 
              since quotes are not stripped from non-pattern  characters  by  GLOB_SUBST.   In other words,

              pattern=\${(q)str} [[ \${str} = \${~pattern} ]]

              works if \${str} is 'a*b' but not if it is 'a b', whereas

              pattern=\${(b)str} [[ \${str} = \${~pattern} ]]

              is always true for any possible value of \${str}.

       c      With  \${#name},  count the total number of characters in an array, as if the elements were concatenated with spaces between them.  
              This is not a true join of the array, so other expressions used with this flag may have an effect on the elements of the array before 
              it is counted.

       C      Capitalize the resulting words.  'Words' in this case refers to sequences of alphanumeric characters separated by non-alphanumerics,
              not  to  words that result from field splitting.

       D      Assume  the  string  or  array  elements contain directories and attempt to substitute the leading part of these by names. The remainder 
              of the path (the whole of it if the leading part was not substituted) is then quoted so that the whole string can be used as a shell 
              argument.  This is the reverse of  '~' substitution:  see the section FILENAME EXPANSION below.

       e      Perform  parameter  expansion,  command substitution and arithmetic expansion on the result. Such expansions can be nested but too deep
              recursion may have unpredictable effects.

       f      Split the result of the expansion at newlines. This is a shorthand for 'ps:\n:'.

       F      Join the words of arrays together using newline as a separator.  This is a shorthand for 'pj:\n:'.

 g:opts:      Process escape sequences like the echo builtin when no options are given (g::).  With the o option, octal escapes don't take a leading 
              zero.With  the  c option, sequences like '^X' are also processed.  With the e option, processes '\M-t' and similar sequences like the 
              print builtin.  With both of the o and e options, behaves like the print builtin except that in none of these modes is '\c' interpreted.

       i      Sort case-insensitively.May be combined with 'n' or 'O'.

       k      If name refers to an associative array, substitute the keys (element names) rather than the values of the elements. Used with subscripts 
              (including ordinary  arrays), force indices or keys to be substituted even if the subscript form refers to values. However,this flag may 
              not be combined with subscript ranges. With the KSH_ARRAYS option a subscript '[*]' or '[@]' is needed to operate on the whole array, as usual.

       L      Convert all letters in the result to lower case.

       n      Sort decimal integers numerically; if the first differing characters of two test strings are not digits, sorting is lexical. Integers 
              with more  initial zeroes  are  sorted  before those with fewer or none.  Hence the array 'foo1 foo02 foo2 foo3 foo20 foo23' is sorted 
              into the order shown.  May be combined with 'i' or 'O'.

       o      Sort the resulting words in ascending order; if this appears on its own  the  sorting  is  lexical and  case-sensitive  (unless  the  
              locale  renders  it case-insensitive).  Sorting in ascending order is the default for other forms of sorting, so this is ignored if 
              combined with 'a', 'i' or 'n'.

       O      Sort the resulting words in descending order; 'O' without 'a', 'i' or 'n' sorts in reverse lexical order.  May be combined with 
              'a', 'i' or 'n' to reverse the order of sorting.

       P      This forces the value of the parameter name to be interpreted as a further parameter name, whose value will be used where appropriate.   
              Note  that  flags set with one of the typeset family of commands (in particular case transformations) are not applied to the value of 
              name used in this fashion.

              If  used with a nested parameter or command substitution, the result of that will be taken as a parameter name in the same way.  
              For example, if you have 'foo=bar' and 'bar=baz', the strings \${(P)foo}, \${(P)\${foo}}, and \${(P)\$(echo bar)} will be expanded 
              to 'baz'.

              Likewise, if the reference is itself nested, the expression with the flag is treated as if it were directly replaced by theparameter
              name.   It  is  an error  if  this  nested  substitution produces an array with more than one word.  For example, if 'name=assoc' where 
              the parameter assoc is an associative array, then '\${\${(P)name}[elt]}' refers to the element of the associative subscripted 'elt'.

       q      Quote characters that are special to the shell in the resulting words with backslashes; unprintable or invalid characters are  quoted  
              using  the  \$'\NNN' form, with separate quotes for each octet.

              If  thisflag  is  given twice, the resulting words are quoted in single quotes and if it is given three times, the words are quoted in 
              double quotes; in these forms no special handling of unprintable or invalid characters is attempted.  If the flag is given four times, 
              the words are quoted in single quotes preceded  by  a \$.  Note that in all three of these forms quoting is done unconditionally, even 
              if this does not change the way the resulting string would be interpreted by the shell.

              If a q- is given (only a single q may appear), a minimal form of single quoting is used that only quotes the string if needed to protect  
              special  charac‐ ters.Typically this form gives the most readable output.

              If  a  q+ is given, an extended form of minmal quoting is used that causes unprintable characters to be rendered using \$'...'.  This 
              quoting is similar to that used by the output of values by the typeset family of commands.

       Q      Remove one level of quotes from the resulting words.

       t      Use a string describing the type of the parameter where the value of the parameter would usually appear. This string consists  of  keywords  
              separated  by hyphens ('-'). The first keyword in the string describes the main type, it can be one of 'scalar', 'array', 'integer', 'float' 
              or 'association'. The other keywords describe the type in more detail:

              local  for local parameters

              left   for left justified parameters
              
              right_blanks for right justified parameters with leading blanks
              
              right_zeros for right justified parameters with leading zeros
              
              lower  for parameters whose value is converted to all lower case when it is expanded
              
              upper  for parameters whose value is converted to all upper case when it is expanded
              
              readonly for readonly parameters
              
              tag    for tagged parameters
              
              export for exported parameters
              
              unique for arrays which keep only the first occurrence of duplicated values
              
              hide   for parameters with the 'hide' flag
              
              hideval for parameters with the 'hideval' flag
              
              special for special parameters defined by the shell

       u      Expand only the first occurrence of each unique word.

       U      Convert all letters in the result to upper case.

       v      Used with k, substitute (as two consecutive words) both the key and the value of each associative array element.  
              Used with subscripts, force values to be substituted even if the subscript form refers to indices or keys.

       V      Make any special characters in the resulting words visible.

       w      With \${#name}, count words in arrays or strings; the s flag may be used to set a word delimiter.

       W      Similar to w with the difference that empty words between repeated delimiters are also counted.

       X      With  this  flag,  parsing  errors  occurring with the Q, e and # Flags or the pattern matching forms such as '\${name#pattern}' 
              are reported.  Without the flag, errors are silently ignored.

       z      Split the result of the expansion into words using shell parsing to find the words, i.e. taking into account any quoting in the value.  
              Comments  are  not treated  specially  but  as  ordinary strings, similar to interactive shells with the INTERACTIVE_COMMENTS option 
              unset (however, see the Z flag below for related options)

              Note that this is done very late, even later than the '(s)' flag. So to access single words in the result use nested expansions as  
              in  '\${\${(z)foo}[2]}'.  Likewise, to remove the quotes in the resulting words use '\${(Q)\${(z)foo}}'.

       0      Split the result of the expansion on null bytes.This is a shorthand for 'ps:\0:'.

              The  following  flags (except p) are followed by one or more arguments as shown.  Any character, or the matching pairs 
              '(...)', '{...}', '[...]', or '<...>', may be used in place of a colon as delimiters, but note that when a flag takes more than 
              one argument, a matched pair of delimiters must surround each argument.

       p      Recognize the same escape sequences as the print builtin in string arguments to any of the flags described below that follow this argument.

              Alternatively, with this option string arguments may be in the form \${var} in which case the value of the  variable  is  substituted.
              Note  this  form  is strict; the string argument does not undergo general parameter expansion.

              For example,

              sep=: val=a:b:c print \${(ps.\${sep}.)val} splits the variable on a :.

       ~      Strings  inserted into the expansion by any of the flags below are to be treated as patterns.  This applies to the string arguments of 
              flags that follow ~ within the same set of parentheses.  Compare with ~ outside parentheses, which forces the entire substituted string 
              to be treated as  a  pattern. Hence, for example,

              [[ "?" = \${(~j.|.)array} ]] treats  '|'  as  a  pattern  and succeeds if and only if \${array} contains the string '?' as an element.
              The ~ may be repeated to toggle the behaviour; its effect only lasts to the end of the parenthesised group.

j:string:     Join the words of arrays together using string as a separator.  Note that this occurs before field splitting by the s:string: flag  
              or  theSH_WORD_SPLIT option.

l:expr::string1::string2:
              Pad the resulting words on the left.  Each word will be truncated if required and placed in a field expr characters wide.

              The  arguments  :string1:  and  :string2: are optional; neither, the first, or both may be given.  Note that the same pairs of 
              delimiters must be used for each of the three arguments.  The space to the left will be filled with string1 (concatenated as often as 
              needed) or spaces if string1 is not  given.  If both  string1 and string2 are given, string2 is inserted once directly to the left of 
              each word, truncated if necessary, before string1 is used to produce any remaining padding.

              If either of string1 or string2 is present but empty, i.e. there are two delimiters together at that point, the first character of \${IFS} 
              is used instead.

              If the MULTIBYTE option is in effect, the flag m may also be given, in which case widths will be used for the calculation of padding; 
              otherwise individual multibyte characters are treated as occupying one unit of width.

              If the MULTIBYTE option is not in effect, each byte in the string is treated as occupying one unit of width.

              Control characters are always assumed to be one unit wide; this allows the mechanism to be used for generating repetitions of 
              control characters.

       m      Only  useful together with one of the flags l or r or with the # Length operator when the MULTIBYTE option is in effect.  Use the 
              character width reported by the system in calculating how much of the string it occupies or the overall length of the string.  Most 
              printable characters have a width of one  unit, however certain Asian character sets and certain special effects use wider characters; 
              combining characters have zero width.  Non-printable characters are arbitrarily counted as zero width; how they would actually be 
              displayed will vary.

              If the m is repeated, the character either counts zero (if it has zero width), else one.For printable character strings this has the 
              effect ofcounting the  number of glyphs (visibly separate characters), except for the case where combining characters themselves have 
              non-zero width (true in certain alphabets).

r:expr::string1::string2:
              As l, but pad the words on the right and insert string2 immediately to the right of the string to be padded.

              Left and right padding may be used together.  In this case the strategy is to apply left padding to the first half width of each of the  
              resulting  words, and right padding to the second half.  If the string to be padded has odd width the extra padding is applied on the left.

s:string:     Force  field  splitting at the separator string.Note that a string of two or more characters means that all of them must match in sequence; 
              this differs from the treatment of two or more characters in the IFS parameter.  See also the = flag and the SH_WORD_SPLIT option.An empty 
              string may also be  given in which case every character will be a separate element.

              For  historical  reasons,  the  usual behaviour that empty array elements are retained inside double quotes is disabled for arrays 
              generated by splitting; hence the following:

              line="one::three" print -l "\${(s.:.)line}" produces two lines of output for one and three and  elides  the  empty  field.   
              To  override  this behaviour,  supply  the  '(@)'  flag  aswell,  i.e.  "\${(@s.:.)line}".

Z:opts:       As  z  but  takes a combination of option letters between a following pair of delimiter characters.  With no options the effect is 
              identical to z.  (Z+c+) causes comments to be parsed as a string and retained; any field in the resulting array beginning with an 
              unquoted comment character is a comment.  (Z+C+) causes  comments  to  be  parsed and removed.  The rule for comments is standard: 
              anything between a word starting with the third character of \${HISTCHARS}, default #, up to the next newline is a comment.  (Z+n+) 
              causes unquoted newlines to be treated as ordinary whitespace, else they are treated  as  if  they are shell code delimiters and converted 
              to semicolons.  Options are combined within the same set of delimiters, e.g. (Z+Cn+).

_:flags:      The underscore (_) flag is reserved for future use.  As of this revision of zsh, there are no valid flags; anything following an 
              underscore, other than an empty pair of delimiters, is treated as an error, and the flag itself has no effect.

              The following flags are meaningful with the \${...#...} or \${...%...} forms.  The S and I flags may also be used with the \${.../...} forms.

       S      Search substrings as well as beginnings or ends; with # Start from the beginning and with % start from the end  of  the  string.With  
              substitution  via \${.../...} or \${...//...}, specifies non-greedy matching, i.e. that the shortest instead of the longest match should 
              be replaced.

 I:expr:      Search  the  exprth match (where expr evaluates to a number).  This only applies when searching for substrings, either with the S flag, 
              or with \${.../...} (only the exprth match is substituted) or \${...//...} (all matches from the exprth on are substituted).The default 
              is to take the first match.

              The exprth match is counted such that there is either one or zero matches from each starting position in the  string,  although  for  
              global  substitution matches  overlapping  previous  replacements are ignored.  With the \${...%...} and \${...%%...} forms, the starting 
              position for the match moves backwards from the end as the index increases, while with the other forms it moves forward from the start.

              Hence with the string which switch is the right switch for Ipswich?  substitutions of the form \${(SI:N:)string#w*ch} as N increases 
              from 1 will match and remove 'which', 'witch', 'witch' and 'wich'; the form using '##' will match  andremove 'which switch is the right
              switch for Ipswich', 'witch is the right switch for Ipswich', 'witch for Ipswich' and 'wich'. The form using '%' will remove the same 
              matches as for '#', but in reverse order, and the form using '%%' will remove the same matches as for '##' in reverse order.

       B      Include the index of the beginning of the match in the result.

       E      Include the index one character past the end of the match in the result (note this is inconsistent with other uses of parameter index).

       M      Include the matched portion in the result.

       N      Include the length of the match in the result.

       R      Include the unmatched portion in the result (the Rest).

   Rules
       Here is a summary of the rules for substitution; this assumes that braces are present around the substitution,
       i.e. \${...}.  Some particular examples  are  given below.  Note that the Zsh Development Group accepts no
       responsibility for any brain damage which may occur during the reading of the following rules.

       1. Nested substitution
      If multiple nested \${...} forms are present, substitution is performed from the inside outwards.
      At each level, the substitution takes account of whether the current value is a scalar or an array,
      whether the whole substitution is in double quotes, and what flags are supplied to the current level
      of substi‐ tution,  just  as if the nested substitution were the outermost.  The flags are not
      propagated up to enclosing substitutions; the nested substitution will return either a scalar or
      an array as determined by the flags, possibly adjusted for quoting.  All the following steps take
      place where applicable at  all levels of substitution.

      Note  that, unless the '(P)' flag is present, the flags and any subscripts apply directly to the
      value of the nested substitution; for example, the expan‐ sion \${\${foo}} behaves exactly the same
      as \${foo}.  When the '(P)' flag is present in a nested substitution, the other substitution rules
      are  applied  to the value before it is interpreted as a name, so \${\${(P)foo}} may differ from \${(P)foo}.

      At  eachnested level of substitution, the substituted words undergo all forms of single-word
      substitution (i.e. not filename generation), including com‐ mand substitution, arithmetic
      expansion and filename expansion (i.e. leading ~ and =).Thus, for example, \${\${:-=cat}:h} expands
      to the  directory  where the  cat program resides.  (Explanation: the internal substitution has
      no parameter but a default value =cat, which is expanded by filename expansion to a full path;
      the outer substitution then applies the modifier :h and takes the directory part of the path.)

       2. Internal parameter flags
      Any parameter flags set by one of the typeset family of commands, in particular the -L, -R, -Z, -u
      and -l options  for  padding  and  capitalization,  are applied  directly  to the parameter value.
      Note these flags are options to the command, e.g. 'typeset -Z'; they are not the same as the flags
      used within parameter substitutions.

      At the outermost level of substitution, the '(P)' flag (rule 4.)ignores these transformations
      and uses the unmodified value of the parameter as the name to  be replaced.  This is usually the
      desired behavior because padding may make the value syntactically illegal as a parameter name,
      but if capitalization changes are desired, use the \${\${(P)foo}} form (rule 25.).

       3. Parameter subscripting
      If the value is a raw parameter reference with a subscript, such as \${var[3]}, the effect of subscripting
      is applied  directly  tothe  parameter.   Sub‐ scripts are evaluated left to right; subsequent
      subscripts apply to the scalar or array value yielded by the previous subscript.Thus if var is an
      array, \${var[1][2]} is the second character of the first word, but \${var[2,4][2]} is the entire third
      word (the second word of the range  of  words  two  through four of the original array).Any number of
      subscripts may appear.  Flags such as '(k)' and '(v)' which alter the result of subscripting are applied.

       4. Parameter name replacement
      At  the  outermost  level  of  nesting  only,  the '(P)' flag is applied.  This treats the value
      so far as a parameter name (which may include a subscript expression) and replaces that with the
      corresponding value.  This replacement occurs later if the '(P)' flag appears in a nested substitution.

      If the value so far names a parameter that has internal flags (rule 2.), those internal flags are
      applied to the new value after replacement.

       5. Double-quoted joining
      If the value after this process is an array, and the substitution appears in double quotes, and
      neither an '(@)' flag nor a '#' length operator is present at  the  current  level,  then words of
      the value are joined with the first character of the parameter \${IFS}, by default a space, between
      each word (single word arrays are not modified).If the '(j)' flag is present, that is used for
      joining instead of \${IFS}.

       6. Nested subscripting
      Any remaining subscripts (i.e. of a nested substitution) are evaluated at this point, based
      on whether the value is an array or a  scalar.   As  with  3., multiple subscripts can appear.
      Note that \${foo[2,4][2]} is thus equivalent to \${\${foo[2,4]}[2]} and also to "\${\${(@)foo[2,4]}[2]}"
      (the nested substitu‐ tion returns an array in both cases), but not to "\${\${foo[2,4]}[2]}" (the
      nested substitution returns a scalar because of the quotes).

       7. Modifiers
      Any modifiers, as specified by a trailing '#', '%', '/' (possibly doubled) or by a set of modifiers
      of the form ':...' (see the section 'Modifiers' in the section 'History Expansion'), are applied to
      the words of the value at this level.

       8. Character evaluation
      Any '(#)' flag is applied, evaluating the result so far numerically as a character.

       9. Length
      Any initial '#' modifier, i.e. in the form \${#var}, is used to evaluate the length of the expression
      so far.

       10. Forced joining
      If  the  '(j)' flag is present, or no '(j)' flag is present but the string is to be split as given
      by rule 11., and joining did not take place at rule 5., any words in the value are joined together
      using the given string or the first character of \${IFS} if none.  Note that the '(F)' flag implicitly
      suppliesa string for joining in this manner.

       11. Simple word splitting
      If one of the '(s)' or '(f)' flags are present, or the '=' specifier was present (e.g. \${=var}),
      the word is split on occurrences of the specified string, or (for = with neither of the two flags
      present) any of the characters in \${IFS}.

      If no '(s)', '(f)' or '=' was given, but the word is not quoted and the option SH_WORD_SPLIT is set,
      the word is split on occurrences of any of the  char‐ acters in \${IFS}.  Note this step, too, takes
      place at all levels of a nested substitution.

       12. Case modification
      Any case modification from one of the flags '(L)', '(U)' or '(C)' is applied.

       13. Escape sequence replacement
      First any replacements from the '(g)' flag are performed, then any prompt-style formatting from the
      '(%)' family of flags is applied.

       14. Quote application
      Any quoting or unquoting using '(q)' and '(Q)' and related flags is applied.

       15. Directory naming
      Any directory name substitution using '(D)' flag is applied.

       16. Visibility enhancement
      Any modifications to make characters visible using the '(V)' flag are applied.

       17. Lexical word splitting
      If  the  '(z)'  flag  orone of the forms of the '(Z)' flag is present, the word is split as if it
      were a shell command line, so that quotation marks and other metacharacters are used to decide what
      constitutes a word.  Note this form of splitting is entirely distinct from that described  by  rule
      11.:  it does not use \${IFS}, and does not cause forced joining.

       18. Uniqueness
      If the result is an array and the '(u)' flag was present, duplicate elements are removed from the array.

       19. Ordering
      If the result is still an array and one of the '(o)' or '(O)' flags was present, the array is reordered.

       20. RC_EXPAND_PARAM
      At  thispoint  the decision is made whether any resulting array elements are to be combined element
      by element with surrounding text, as given by either the RC_EXPAND_PARAM option or the '^' flag.

       21. Re-evaluation
      Any '(e)' flag is applied to the value, forcing it to be re-examined for new parameter substitutions,
      but also for command and arithmetic substitutions.

       22. Padding
      Any padding of the value by the '(l.fill.)' or '(r.fill.)' flags is applied.

       23. Semantic joining
      In contexts where expansion semantics requires a single word to result, all  words  are  rejoined
      with  the  firstcharacter  of  IFS  between.   So  in '\${(P)\${(f)lines}}' the value of \${lines}
      is split at newlines, but then must be joined again before the '(P)' flag can be applied.

      If a single word is not required, this rule is skipped.

       24. Empty argument removal
      If  the substitution does not appear in double quotes, any resulting zero-length argument, whether from
      a scalar or an element of an array, is elided from the list of arguments inserted into the command line.

      Strictly speaking, the removal happens later as the same happens with other forms of substitution;
      the point to note here is simply that itoccursafter any of the above parameter operations.

       25. Nested parameter name replacement
      If  the  '(P)' flag is present and rule 4. has not applied, the value so far is treated as a parameter
      name (which may include a subscript expression) and replaced with the corresponding value, with
      internal flags (rule 2.) applied to the new value.

${E_WHITE_FG}Parameter Modifiers${E_RESET}
-------------------
       After the optional word designator, you can add a sequence of one or more of the following modifiers, each
       preceded by a ':'.  These modifiers also work  on  the result of filename generation and parameter expansion,
       except where noted.

       a      Turn  a  file  name  into an absolute path:  prepends the current directory, if necessary; remove '.' path segments; 
              and remove '..' path segments and the segments that immediately precede them.

              This transformation is agnostic about what is in the filesystem, i.e. is on the logical, not the physical directory.  
              It takes place in the same manner as when  changingdirectories  when  neither of the options CHASE_DOTS or CHASE_LINKS 
              is set.For example, '/before/here/../after' is always transformed to '/before/after', regardless of whether '/before/here' 
              exists or what kind of object (dir, file, symlink, etc.) it is.

       A      Turn a file name into an absolute path as the 'a' modifier does, and then pass the result through the realpath(3) 
              library function  to  resolve  symbolic links.

              Note: on systems that do not have a realpath(3) library function, symbolic links are not resolved,
              so on those systems 'a' and 'A' are equivalent.

              Note: foo:A and realpath(foo) are different on some inputs.  For realpath(foo) semantics, see the 'P' modifier.

       c      Resolve  a command name into an absolute path by searching the command path given by the PATH variable.
              This does not work for commands containing directory parts.  Note also that this does not usually work as a 
              glob qualifier unless a file of the same name is found in the current directory.

       e      Remove all but the part of the filename extension following the '.'; see the definition of the filename extension 
              in the description  of  the  r  modifier below.  Note that according to that definition the result will be empty 
              if the string ends with a '.'.

       h      Remove a trailing pathname component, leaving the head.  This works like 'dirname'.

       l      Convert the words to all lowercase.

       p      Print the new command but do not execute it.  Only works with history expansion.

       P      Turn  a  file  name  into an absolute path, like realpath(3).  The resulting path will be absolute, have neither '.' 
              nor '..' components, and refer to the same directory entry as the input filename.

              Unlike realpath(3), non-existent trailing components are permitted and preserved.

       q      Quote the substituted words, escaping further substitutions.  Works with history expansion and parameter expansion, 
              though for parameters it is only  useful if the resulting text is to be re-evaluated such as by eval.

       Q      Remove one level of quotes from the substituted words.

       r      Remove  a  filename  extension  leaving the root name.  Strings with no filename extension are not altered.  A filename 
              extension is a '.' followed by any number of characters (including zero) that are neither '.' nor '/' and that continue 
              to the end of the string.  For example, the extension of 'foo.orig.c' is '.c', and 'dir.c/foo' has no extension.

s/l/r[/]      Substitute  r  for l as described below.The substitution is done only for the first string that
              matches l.  For arrays and for filename generation, this applies to each word of the expanded text.
              See below for further notes on substitutions.

              The forms 'gs/l/r' and 's/l/r/:G' perform global substitution, i.e. substitute every occurrence of r for l.
              Note that the g or :G must appear in  exactly the position shown.

              See further notes on this form of substitution below.

       &      Repeat  the previous s substitution.  Like s, may be preceded immediately by a g.  In parameter expansion the & must 
              appear inside braces, and in filename generation it must be quoted with a backslash.

       t      Remove all leading pathname components, leaving the tail.  This works like 'basename'.

       u      Convert the words to all uppercase.

       x      Like q, but break into words at whitespace.  Does not work with parameter expansion.

              The s/l/r/ substitution works as follows.  By default the left-hand side of substitutions are not patterns,
              but character strings.  Any character can be used  as the  delimiter  in  placeof  '/'.   A  backslash
              quotes the delimiter character.The character '&', in the right-hand-side r, is replaced by the text from
              the left-hand-side l.  The '&' can be quoted with a backslash.  A null l uses the previous string either
              from the previous l or from thecontextual  scan  string  s from  '!?s'.   Youcan  omit the rightmost
              delimiter if a newline immediately follows r; the rightmost '?' in a context scan can similarly be omitted.
              Note the same record of the last l and r is maintained across all forms of expansion.
       
              Note that if a '&' is used within glob qualifiers an extra backslash is needed as a & is a special character in this case.

              Also note that the order of expansions affects the interpretation of l and r.  When used in a history expansion,
              which occurs before any other expansions, l  and r are treated as literal strings (except as explained for
              HIST_SUBST_PATTERN below).  When used in parameter expansion, the replacement of r into the parameter's
              value is done first, and then any additional process, parameter, command, arithmetic, or brace references
              are applied, which may evaluate those substitutions and expansions  more  than once if l appears more than
              once in the starting value.  When used in a glob qualifier, any substitutions or expansions are performed
              once at the time the qualifier is parsed, even before the ':s' expression itself is divided into l and r sides.
 
              If the option HIST_SUBST_PATTERN is set, l is treated as a pattern of the usual form described in the
              section FILENAME GENERATION below.  This can be used in all theplaceswhere  modifiers  are  available;
              note,  however,that in globbing qualifiers parameter substitution has already taken place, so parameters
              in the replacement string should be quoted to ensure they are replaced at the correct time.  Note also
              that complicated patterns used in globbing  qualifiers  may  need the  extended glob qualifier notation
              (#q:s/.../.../) in order for the shell to recognize the expression as a glob qualifier.Further, note that
              bad patterns in the substitution are not subject to the NO_BAD_PATTERN option so will cause an error.
 
              When HIST_SUBST_PATTERN is set, l may start with a # To indicate that the pattern must match at the start
              of the string to be substituted, and a % may appear  at the start or after an # To indicate that the pattern
              must match at the end of the string to be substituted.  The % or # May be quoted with two backslashes.
 
              For example, the following piece of filename generation code with the EXTENDED_GLOB option:
 
              print *.c(#q:s/#%(#b)s(*).c/'S\${match[1]}.C'/)

              takes  the expansion of *.c and applies the glob qualifiers in the (#q...) expression, which consists of a
              substitution modifier anchored to the start and end of each word (#%).  This turns on backreferences ((#b)),
              so that the parenthesised subexpression is  available  in  the  replacement  string  as\${match[1]}.
              The replacement string is quoted so that the parameter is not substituted before the start of filename generation.
 
              The  following  f,  F, w and W modifiers work only with parameter expansion and filename generation.
              They are listed here to provide a single point of reference for all modifiers.
 
       f      Repeats the immediately (without a colon) following modifier until the resulting word doesn't change any more.

 F:expr:      Like f, but repeats only n times if the expression expr evaluates to n.  Any character can be used
              instead of the ':'; if '(', '[', or '{' is used as  the opening delimiter, the closing delimiter
              should be ')', ']', or '}', respectively.

       w      Makes the immediately following modifier work on each word in the string.

  W:sep:      Like w but words are considered to be the parts of the string that are separated by sep. Any character
              can be used instead of the ':'; opening parentheses are handled specially, see above.
		  
${E_WHITE_FG}Examples${E_RESET}
--------
       The flag f is useful to split a double-quoted substitution line by line.  For example, \${(f)"\$(<file)"}
       substitutes the contents of file  divided  so  that  each line is an element of the resulting array.
       Compare this with the effect of \$(<file) alone, which divides the file up by words, or the same inside
       double quotes, which makes the entire content of the file a single string.

       The following illustrates the rules for nested parameter expansions.  Suppose that \${foo} contains the array
       (bar baz):

       "\${(@)\${foo}[1]}"
	      This produces the result b.  First, the inner substitution "\${foo}", which has no array (@) flag,
	      produces a single word result "bar baz".	The outer sub‐ stitution "\${(@)...[1]}" detects that
	      this is a scalar, so that (despite the '(@)' flag) the subscript picks the first character.

       "\${\${(@)foo}[1]}"
	      This  produces  the  result  'bar'.   In this case, the inner substitution "\${(@)foo}" produces the
	      array '(bar baz)'.  The outer substitution "\${...[1]}" detects that this is an array and picks the
	      first word.  This is similar to the simple case "\${foo[1]}".

       As an example of the rules for word splitting and joining, suppose \${foo} contains the array '(ax1 bx1)'.	Then

       \${(s/x/)foo}
	      produces the words 'a', '1 b' and '1'.

       \${(j/x/s/x/)foo}
	      produces 'a', '1', 'b' and '1'.

       \${(s/x/)foo%%1*}
	      produces 'a' and ' b' (note the extra space).  As substitution occurs before either joining or
	      splitting, the  operation   first  generates  the  modified array (ax bx), which is joined to give
	      "ax bx", and then split to give 'a', ' b' and ''.  The final empty string will then be elided,
	      as it is not in dou‐ ble quotes.


${E_MAGENTA_FG}ZSH Globbing${E_RESET}
------------
Let's start with a simple problem. Suppose you have a directory hierarchy full of text files with their execute permission bit 
set. How can you recursively turn off the execute permission for files, but leave the execute permissions for the directories 
alone? With the Bourne shell, you might do something like this:

 % find . -type f -print | xargs chmod -x
 
Using zsh and globs (special strings containing wildcard characters like ?, *, etc.) the solution is simpler. zshs 
globbing abilities are good enough to make find unnecessary. We need only run this to get the same result:

 % chmod -x **/*(.)
 
The leading **/ tells zsh to glob recursively. The * following that means to get everything. Finally, the glob ends in a (.), 
which is a glob qualifier, that restricts the matching to files.

Heres another example (with additional glob qualifiers).  Suppose an unwanted visitor compromised the security of your 
machine, and you want to find out if he implanted any trojan horses (trojan horses are programs that disguise themselves as 
regular Linux commands like passwd and then transmit stolen information back to the evildoer) and check the entire filesystem 
to see if any executable files have been modified since yesterday. In zsh, this can be done with:

% print -l /**/*(*.m-1)
 
Notice how glob qualifiers can be chained together. This time, we have * which means executables, . which means plain 
files, and m-1 which limits matches to anything with a modification time of one day or less. The -l option tells print 
to print out each value on a separate line. As you can see, using glob qualifiers together with recursive globbing makes zshs 
globbing system just as powerful as the find program.

For a full list of glob qualifiers, see the Glob Qualifiers section of the zshexpn man page. For more on filename generation 
and pattern matching, see section 5.9 of the Zsh Users Guide (http://zsh.sunsite.dk/Guide/).

${E_WHITE_FG}Data Types and Attributes${E_RESET}
-------------------------

Weve just seen how globbing can generate huge lists of filenames. But once you have a list, the question is how to 
contain it. An array works perfectly for this. In the following command, list will be assigned a list of all the files in 
/usr/bin.

 % list=(/usr/bin/*)
 
This array can then be accessed in a number of ways that programmers (especially Perl programmers) may find familiar. 
However, be careful. In zsh, arrays are indexed from 1 instead of 0. Below are some examples using arrays.

To get the array size, use a \${#} before the array name:

 % print \${#list}
 462

Both positive numbers and negative numbers can be used as indexes into the array. Positive numbers count forward from the start of 
the array; negative numbers count backward from the end of the array:

 % print \${list}[462]
 /usr/bin/zprint

 % print \${list}[-462]
 /usr/bin/a2p
 
To retrieve multiple values as a sub-list (or a slice), we can add a comma between starting and ending index numbers:

 % print -l \${list[23,25]}
 /usr/bin/atq
 /usr/bin/atrm
 /usr/bin/atstatus

To retrieve from element 2 till the end:

 % print -l \${list[@]:2}


The array is just one of zshs five data types. The other four types are: association (a hash table), scalar (a string), float, 
and integer. In general, type is handled automatically (as far as the programmer is concerned). For example, the following code 
assigns a scalar value to theory, a float to pi, and an integer to a without the need for type to be declared explicitly:

 % theory=conspiracy
 % pi=3.14159
 % a=42
 
However, one exception is associations. You must first declare a variable as an associative array before it takes on the behavior 
of one. This is done by using the built-in command typeset -A variable:

 % typeset -A hash
 % hash[brown]=Mmm..  hash browns
 % hash[table]=clever data structure
 % print \${hash[brown]}

 Mmm..  hash browns
 
typeset is actually quite versatile. It can be used to pre-declare variables of specific types (scalar, int, float, 
array), although its not strictly necessary. It can also give special attributes to variables. Lets look at some examples.

The -Z 3 option makes the variable agent at least three characters long, padded with zeros if necessary.

 % typeset -Z 3 agent
 % agent=7
 % print \${agent}
 007
 
The -r option can make a variable read-only.

 % typeset -r agent
 % agent=secret
 zsh: read-only variable: agent
 
The -U option forces an array to have unique contents and duplicate values are ignored.

 % typeset -U unique_set
 % unique_set=(1 2 4 8 16 8 4 2 1)

 print \${unique_set}
 1 2 4 8 16

zsh can also tie scalar variables and array variables together with the -T option, effectively giving you two interfaces to the 
same data. In Figure One, you can see how the variables \${DIR} and \${dir} are tied together.

Figure One: Tying scalars to arrays

 % typeset -T DIR dir
 % dir=(/etc /var/log /usr/local/bin)
 % print \${DIR}
 /etc:/var/log:/usr/local/bin

 % DIR=/tmp:/opt
 % print -l \${dir}
 /tmp
 /opt

This feature is extremely useful for dealing with PATH-like variables. In fact, the \${PATH}, \${FPATH}, and \${MANPATH} environment 
variables already have matching \${path}, \${fpath}, and \${manpath} variables associated with them when zsh starts up. And since 
arrays cant be exported, being able to store the arrays contents into a single string is very useful.

(The reason arrays cant be exported is because the shell environment is a feature of Unix, not a part of zsh. zsh can 
support any the data types it wants, but the environment only understands strings. This prevents collections like arrays or 
associations from being exported. However, float, integer, and scalar variables can be exported without problems.)

For more on typeset, use tab-completion to see a complete list of available special attributes (by typing typeset -[TAB]) or read 
the zshbuiltins man page.

${E_WHITE_FG}Using Flags and Modifiers to Transform Data${E_RESET}
-------------------------------------------

Now that we have data stored in variables, lets learn how to manipulate it. In shell programming, data manipulation has 
traditionally been done by programs like sed and awk which are usually used in a long and contrived series of backticks and 
pipes. However, zsh scripts can often avoid this by using flags and modifiers. Lets look at a simple example:

 % place=santa barbara
 % print -l \${(U)place} \${place:u} \${place}

 SANTA BARBARA
 SANTA BARBARA
 santa barbara
 
Here, we make the entire string upper-case, first using the (U) flag and then using the :u modifier. Then, we print \${place} 
without any modifiers or flags to show that the variable was not actually changed.

(Why a (U) flag and a :u modifier? There isnt much difference between them; you may prefer one or the other depending on your 
coding style.)

Lets initialize an array that well use for some more examples:

% list=(
   /usr/bin/perl
   /var/log/wtmp
   /etc/inetd.conf
 )
 
One feature unique to modifiers is specialized filename transformations. A filename transformation can do the same things 
that basename and dirname can. We can use the -t flag to simulate basename and the -h flag to simulate dirname:

 % print \${list:t}
 perl wtmp inent.conf
 % print \${list:h}
 /usr/bin /var/log /etc

We can also simulate grep -v (inverted grep) using the :# mdodifier to filter out items from list that match the given glob 
pattern.

 % print \${list:#/etc*}
 /usr/bin/perl /var/log/wtmp
 
To simulate a normal grep, the (M) flag is used to reverse the meaning of :#.

 % print \${(M)list:#/etc*}
 /etc/inetd.conf
 
Finally, you can combine and nest flags and modifiers to perform complex data manipulations. Unfortunately, the result often looks 
like line noise. In the next example, we store the complete path names of all entries from /usr/bin in list. Then we print out the 
file names (in upper case) of all entries that have ssh anywhere in the path.

 % list=(/usr/bin/*)
 % print -l \${\${(UM)list:#*ssh*}:t}

SSH
SSH-ADD
SSH-AGENT
SSH-KEYGEN
SSH-KEYSCAN
 
For more on modifiers and parameter expansion flags, see the zshexpn man page.

${E_MAGENTA_FG}Conditional Expressions using [[ ]]${E_RESET}
-----------------------------------

That last example might may make you think that the zsh developers dont care about readability, but thats not 
completely true. Look at the improvements made to conditional expressions for reassurance that zsh code can in fact be readable.

zsh has an alternative method for writing conditionals thats much more expressive than using the traditional test command. 
Its greatest strength is its ability to nest conditionals using a familiar and intuitive notation. In the next example, 
notice how parentheses can be used for grouping, and && and || for logical AND and OR.

 if [[   ((\${x} -lt  8) && (\${y} -ge 32)) || ((\${z} -gt 32) && (\${w} -eq 16))  ]]
 then
     print complex combinations
     print are not a problem.

 fi
 
The [[ ]] notation is also downward compatible with the test command, being able to perform the same file and string tests. 
For example, you can use -e to see if a file exists, -d to see if a name is a directory, or perform string comparisons, in this 
case, inequality:

 [[ -e \${HOME}/.emacs ]]
 [[ -d \${HOME}/.ssh ]]
 [[ foo != bar ]]
 
${E_MAGENTA_FG}Mathematical Expressions Using (( ))${E_RESET}
------------------------------------

zsh also has a double parenthesis notation to evaluate mathematical expressions. The most interesting thing about (( )) 
is that its expression syntax is a radical departure from Bourne shell syntax. Consider the following example.

 % a=5; b=32; c=24; (( a += (++a + b * c)  2 ))
 % print \${a}

 777
 
Everything in the example above, from the mathematical operators to how dollar signs are omitted when referring to variables, 
makes zsh look and feel a lot more like a C program than a shell script. While zshs syntax is definitely an improvement over 
expr and backticks, there are times when zsh can be a bit too much like C.

For example, the shell script below (just a one-liner typed at the command prompt) demonstrates that zshs type system 
doesnt automatically promote integer types to yield the most accurate result. Instead, its necessary to explicitly specify 
one of the two numbers as a floating-point number to get the highest accuracy. Most scripting languages will perform the 
promotion for you, but whoever implemented the (( )) notation apparently liked C a lot.

% print \$(( 5 / 2 ))
 2

 % print \$(( 5.0 / 2 ))
 2.5

Besides being used for mathematical functions, (( )) is often used in statements needing conditional expressions. In these 
cases, expressions that evaluate to 0 are false and everything else is true (like C).

An idiom that youll see a lot in the completion functions is the \$+var technique, which tests to see if \${var} is defined. Here 
are a few examples:

 % (( \$+var )) && print \tvar exists
 % (( \$+var )) || print \tno, it doesnt exist
         no, it doesnt exist

 % var=5
 % (( \$+var )) && print \tnow var exists
         now var exists
 
Notice also how the logical AND and OR act as if-then statements.  This is just like Perl.

=========================
${E_MAGENTA_FG}TYPESET${E_RESET}
=========================
typeset args:

${E_WHITE_FG}-A${E_RESET}  The names refer to associative array parameters; see 'Array Parameters' in zsh- param(1).

${E_WHITE_FG}-L${E_RESET}  Left justify and remove leading blanks from value. If n is nonzero, it defines the width of the field.  If n is zero, the width is 
    determined by the width of the value of the first assignment. In the case of numeric parameters, the length of the complete value 
    assigned to the parameter is used to determine the width, not the value that would be output.

    The width is the count of characters, which may be multibyte characters if the MULTIBYTE option is in effect. Note that the screen width
    of the character is not taken into account; if this is required, use padding with parameter expansion flags \${(ml...)...} as described 
    in 'Parameter Expansion Flags' in zshexpn(1).

    When the parameter is expanded, it is filled on the right with blanks or truncated if necessary to fit the field. Note truncation can 
    lead to unexpected results with numeric parameters. Leading zeros are removed if the -Z flag is also set.

${E_WHITE_FG}-R${E_RESET}  Similar to -L, except that right justification is used; when the parameter is expanded, the field is left filled with blanks or truncated 
    from the end. May not be combined with the -Z flag.

${E_WHITE_FG}-U${E_RESET}  For arrays (but not for associative arrays), keep only the first occurrence of each duplicated value. This may also be set for 
    colon-separated special parameters like PATH or FIGNORE, etc. This flag has a different meaning when used with -f; see below.

${E_WHITE_FG}-Z${E_RESET}  Specially handled if set along with the -L flag. Otherwise, similar to -R, except that leading zeros are used for padding instead of blanks if 
    the first non-blank character is a digit. Numeric parameters are specially handled: they are always eligible for padding with zeroes, and 
    the zeroes are inserted at an appropriate place in the output.

${E_WHITE_FG}-a${E_RESET}  The names refer to array parameters. An array parameter may be created this way, but it may not be assigned to in the typeset statement. 
    When displaying, both normal and associative arrays are shown.


${E_WHITE_FG}-f${E_RESET}  The names refer to functions rather than parameters. No assignments can be made, and the only other valid flags are -t, -T, -k, -u, -U and -z. 
    The flag -t turns on execution tracing for this function; the flag -T does the same, but turns off tracing on any function called from the 
    present one, unless that function also has the -t or -T flag. The -u and -U flags cause the function to be marked for autoloading; -U 
    also causes alias expansion to be suppressed when the function is loaded. The fpath parameter will be searched to find the function definition 
    when the function is first referenced; see the section 'Functions'. The -k and -z flags make the function be loaded using ksh-style or zsh-style 
    autoloading respectively. If neither is given, the setting of the KSH_AUTOLOAD option determines how the function is loaded.

${E_WHITE_FG}-h${E_RESET}  Hide: only useful for special parameters (those marked '<S>' in the table in zsh-param(1)), and for local parameters with the same name as a
    special parameter though harmless for others. A special parameter with this attribute will not retain its special effect when made local. 
    Thus after 'typeset -h PATH', a function containing 'typeset PATH' will create an ordinary local parameter without the usual behaviour of PATH. 
    Alternatively, the local parameter may itself be given this attribute; hence inside a function 'typeset -h PATH' creates an ordinary
    local parameter and the special PATH parameter is not altered in any way. It is also possible to create a local parameter using 
    'typeset +h special', where the local copy of special will retain its special properties regardless of having the -h attribute. 
    Global special parameters loaded from shell modules (currently those in zsh/mapfile and zsh/parameter) are automatically given the -h 
    attribute to avoid name clashes.

${E_WHITE_FG}-H${E_RESET}  Hide value: specifies that typeset will not display the value of the parameter when listing parameters; the display for such parameters is 
    always as if the '+' flag had been given. Use of the parameter is in other respects normal, and the option does not apply if the parameter 
    is specified by name, or by pattern with the -m option. This is on by default for the parameters in the zsh/parameter and zsh/mapfile 
    modules. Note, however, that unlike the -h flag this is also useful for non-special parameters.

${E_WHITE_FG}-i${E_RESET}  Use an internal integer representation. If n is nonzero it defines the output arithmetic base, otherwise it is determined by the first 
    assignment. Bases from 2 to 36 inclusive are allowed.

${E_WHITE_FG}-E${E_RESET}  Use an internal double-precision floating point representation. On output the variable will be converted to scientific notation. If n is 
    nonzero it defines the number of significant figures to display; the default is ten.

${E_WHITE_FG}-F${E_RESET}  Use an internal double-precision floating point representation. On output the variable will be converted to fixed-point decimal notation. 
    If n is nonzero it defines the number of digits to display after the decimal point; the default is ten.

${E_WHITE_FG}-l${E_RESET}  Convert the result to lower case whenever the parameter is expanded. The value is not converted when assigned.

${E_WHITE_FG}-r${E_RESET}  The given names are marked readonly. Note that if name is a special parameter, the readonly attribute can be turned on, but cannot 
    then be turned off.

${E_WHITE_FG}-t${E_RESET}  Tags the named parameters. Tags have no special meaning to the shell. This flag has a different meaning when used with -f; see above.

${E_WHITE_FG}-u${E_RESET}  Convert the result to upper case whenever the parameter is expanded. The value is not converted when assigned. This flag has a different 
    meaning when used with -f; see above.

${E_WHITE_FG}-x${E_RESET}  Mark for automatic export to the environment of subsequently executed commands. If the option GLOBAL_EXPORT is set this implies the 
    option -g, unless +g is also explicitly given; in other words the parameter is not made local to the enclosing function. This is for 
    compatibility with previous versions of zsh.

===================
${E_MAGENTA_FG}REDIRECTION${E_RESET}
===================
If a command is followed by & and job control is not active, then the default standard input for the command is the 
empty file /dev/null. Otherwise, the environment for the execution of a command contains the file descriptors of the 
invoking shell as modified by input/output specifications.

The following may appear anywhere in a simple command or may precede or follow a complex command. Expansion occurs 
before word or digit is used except as noted below. If the result of substitution on word produces more than one 
filename, redirection occurs for each separate filename in turn.

< word 
Open file word for reading as standard input. It is an error to open a file in this fashion if it does not exist.

<> word
Open file word for reading and writing as standard input. If the file does not exist then it is created.

> word 
Open file word for writing as standard output. If the file does not exist then it is created. If the file 
exists, and the CLOBBER option is unset, this causes an error; otherwise, it is truncated to zero length.

>| word
>! word
Same as >, except that the file is truncated to zero length if it exists, regardless of CLOBBER.

>> word
Open file word for writing in append mode as standard output. If the file does not exist, and the CLOBBER and 
APPEND_CREATE options are both unset, this causes an error; otherwise, the file is created.

>>| word
>>! word
Same as >>, except that the file is created if it does not exist, regardless of CLOBBER and APPEND_CREATE.

<<[-] word
The shell input is read up to a line that is the same as word, or to an end-of-file. No parameter expansion, 
command substitution or filename generation is performed on word. The resulting document, called a here-document, 
becomes the standard input.

If any character of word is quoted with single or double quotes or a '\', no interpretation is placed upon the 
characters of the document. Otherwise, parameter and command substitution occurs, '\' followed by a newline is removed, 
and '\' must be used to quote the characters '\', '\$', ''' and the first character of word.

Note that word itself does not undergo shell expansion. Backquotes in word do not have their usual effect; instead they 
behave similarly to double quotes, except that the backquotes themselves are passed through unchanged. (This 
information is given for completeness and it is not recommended that backquotes be used.) Quotes in the form \$'...' 
have their standard effect of expanding backslashed references to special characters.

If <<- is used, then all leading tabs are stripped from word and from the document.

<<< word
Perform shell expansion on word and pass the result to standard input. This is known as a here-string. Compare the use 
of word in here-documents above, where word does not undergo shell expansion. The result will have a trailing newline 
after it.

<& number
>& number
The standard input/output is duplicated from file descriptor number (see dup2(2)).

<& -
>& - Close the standard input/output.

<& p
>& p The input/output from/to the coprocess is moved to the standard input/output.

>& word
&> word
(Except where '>& word' matches one of the above syntaxes; '&>' can always be used to avoid this ambiguity.) 
Redirects both standard output and standard error (file descriptor 2) in the manner of '> word'. Note that this does 
not have the same effect as '> word 2>&1' in the presence of multios (see the section below).

>&| word
>&! word
&>| word
&>! word
Redirects both standard output and standard error (file descriptor 2) in the manner of '>| word'.

>>& word
&>> word
Redirects both standard output and standard error (file descriptor 2) in the manner of '>> word'.

>>&| word
>>&! word
&>>| word
&>>! word
Redirects both standard output and standard error (file descriptor 2) in the manner of '>>| word'.

If one of the above is preceded by a digit, then the file descriptor referred to is that specified by the digit instead 
of the default 0 or 1. The order in which redirections are specified is significant. The shell evaluates each 
redirection in terms of the (file descriptor, file) association at the time of evaluation. For example:

... 1>fname 2>&1

first associates file descriptor 1 with file fname. It then associates file descriptor 2 with the file associated with 
file descriptor 1 (that is, fname). If the order of redirections were reversed, file descriptor 2 would be associated 
with the terminal (assuming file descriptor 1 had been) and then file descriptor 1 would be associated with file fname.

The '|&' command separator described in Simple Commands & Pipelines in zshmisc(1) is a shorthand for '2>&1 |'.

The various forms of process substitution, '<(list)', and '=(list)' for input and '>(list)' for output, are often used 
together with redirection. For example, if word in an output redirection is of the form '>(list)' then the output is 
piped to the command represented by list.  See Process Substitution in zshexpn(1).

OPENING FILE DESCRIPTORS USING PARAMETERS
When the shell is parsing arguments to a command, and the shell option IGNORE_BRACES is not set, a different form of 
redirection is allowed: instead of a digit before the operator there is a valid shell identifier enclosed in braces. 
The shell will open a new file descriptor that is guaranteed to be at least 10 and set the parameter named by the 
identifier to the file descriptor opened. No whitespace is allowed between the closing brace and the redirection 
character. For example:

... {myfd}>&1

This opens a new file descriptor that is a duplicate of file descriptor 1 and sets the parameter myfd to the number of 
the file descriptor, which will be at least 10. The new file descriptor can be written to using the syntax >&\$myfd. 
The file descriptor remains open in subshells and forked external executables.

The syntax {varid}>&-, for example {myfd}>&-, may be used to close a file descriptor opened in this fashion. Note that 
the parameter given by varid must previously be set to a file descriptor in this case.

It is an error to open or close a file descriptor in this fashion when the parameter is readonly. However, it is not an 
error to read or write a file descriptor using <&\$param or >&\$param if param is readonly.

If the option CLOBBER is unset, it is an error to open a file descriptor using a parameter that is already set to an 
open file descriptor previously allocated by this mechanism. Unsetting the parameter before using it for allocating 
a file descriptor avoids the error.

Note that this mechanism merely allocates or closes a file descriptor; it does not perform any redirections from or to 
it. It is usually convenient to allocate a file descriptor prior to use as an argument to exec. The syntax does not in 
any case work when used around complex commands such as parenthesised subshells or loops, where the opening brace is 
interpreted as part of a command list to be executed in the current shell.

The following shows a typical sequence of allocation, use, and closing of a file descriptor:

integer myfd
exec {myfd}>~/logs/mylogfile.txt
print This is a log message. >&\$myfd
exec {myfd}>&-

Note that the expansion of the variable in the expression >&\$myfd occurs at the point the redirection is opened. This 
is after the expansion of command arguments and after any redirections to the left on the command line have been 
processed.

MULTIOS
If the user tries to open a file descriptor for writing more than once, the shell opens the file descriptor as a pipe 
to a process that copies its input to all the specified outputs, similar to tee, provided the MULTIOS option is set, as 
it is by default. Thus:

date >foo >bar

writes the date to two files, named 'foo' and 'bar'. Note that a pipe is an implicit redirection; thus

date >foo | cat

writes the date to the file 'foo', and also pipes it to cat.

Note that the shell opens all the files to be used in the multio process immediately, not at the point they are about 
to be written.

Note also that redirections are always expanded in order. This happens regardless of the setting of the MULTIOS option, 
but with the option in effect there are additional consequences. For example, the meaning of the expression >&1 will 
change after a previous redirection:

date >&1 >output

In the case above, the >&1 refers to the standard output at the start of the line; the result is similar to the tee 
command. However, consider:

date >output >&1

As redirections are evaluated in order, when the >&1 is encountered the standard output is set to the file output and 
another copy of the output is therefore sent to that file. This is unlikely to be what is intended.

If the MULTIOS option is set, the word after a redirection operator is also subjected to filename generation 
(globbing). Thus

: > *

will truncate all files in the current directory, assuming there's at least one. (Without the MULTIOS option, it would 
create an empty file called '*'.) Similarly, you can do

echo exit 0 >> *.sh

If the user tries to open a file descriptor for reading more than once, the shell opens the file descriptor as a pipe 
to a process that copies all the specified inputs to its output in the order specified, provided the MULTIOS option is 
set. It should be noted that each file is opened immediately, not at the point where it is about to be read: this 
behaviour differs from cat, so if strictly standard behaviour is needed, cat should be used instead.

Thus

sort <foo <fubar

or even

sort <f{oo,ubar}

is equivalent to 'cat foo fubar | sort'.

Expansion of the redirection argument occurs at the point the redirection is opened, at the point described above for 
the expansion of the variable in >&\$myfd.

Note that a pipe is an implicit redirection; thus

cat bar | sort <foo

is equivalent to 'cat bar foo | sort' (note the order of the inputs).

If the MULTIOS option is unset, each redirection replaces the previous redirection for that file descriptor. However, 
all files redirected to are actually opened, so

echo Hello > bar > baz

when MULTIOS is unset will truncate 'bar', and write 'Hello' into 'baz'.

There is a problem when an output multio is attached to an external program. A simple example shows this:

cat file >file1 >file2
cat file1 file2

Here, it is possible that the second 'cat' will not display the full contents of file1 and file2 (i.e. the original 
contents of file repeated twice).

The reason for this is that the multios are spawned after the cat process is forked from the parent shell, so the 
parent shell does not wait for the multios to finish writing data. This means the command as shown can exit before 
file1 and file2 are completely written. As a workaround, it is possible to run the cat process as part of a job in 
the current shell:

{ cat file } >file >file2

Here, the {...} job will pause to wait for both files to be written.

REDIRECTIONS WITH NO COMMAND
When a simple command consists of one or more redirection operators and zero or more parameter assignments, but no 
command name, zsh can behave in several ways.

If the parameter NULLCMD is not set or the option CSH_NULLCMD is set, an error is caused. This is the csh behavior and 
CSH_NULLCMD is set by default when emulating csh.

If the option SH_NULLCMD is set, the builtin ':' is inserted as a command with the given redirections. This is the 
default when emulating sh or ksh.

Otherwise, if the parameter NULLCMD is set, its value will be used as a command with the given redirections. If both 
NULLCMD and READNULLCMD are set, then the value of the latter will be used instead of that of the former when the 
redirection is an input. The default for NULLCMD is 'cat' and for READNULLCMD is 'more'.
Thus:

< file

shows the contents of file on standard output, with paging if that is a terminal. NULLCMD and READNULLCMD may refer to 
shell functions.

===================
${E_MAGENTA_FG}READ${E_RESET}
===================
read [ -rszpqAclneE ] [ -t [ num ] ] [ -k [ num ] ] [ -d delim ] [ -u n ] [ name[?prompt] ] [ name ... ]

Read one line and break it into fields using the characters in \${IFS} as separators, except as noted below. The first field is
assigned to the first name, the second field to the second name, etc., with leftover fields assigned to the last name. If name is
omitted then REPLY is used for scalars and reply for arrays.  

${E_WHITE_FG}-r${E_RESET}     Raw mode: a '\' at the end of a line does not signify line continuation and backslashes in the line don't quote the following character and are not removed.
 
${E_WHITE_FG}-s${E_RESET}     Don't echo back characters if reading from the terminal.  Currently does not work with the -q option.
 
${E_WHITE_FG}-q${E_RESET}     Read only one character from the terminal and set name to 'y' if this character was 'y' or 'Y' and to 'n' other- wise. With this flag set the return 
       status is zero only if the character was 'y' or 'Y'. This option may be used with a timeout; if the read times out, or encounters end of file, 
       status 2 is returned.  Input is read from the terminal unless one of -u or -p is present.  This option may also be used within zle widgets.
 
${E_WHITE_FG}-k[n]${E_RESET}  Read only one (or num) characters. All are assigned to the first name, without word splitting. This flag is ignored when -q is present. 
       Input is read from the terminal unless one of -u or -p is present. This option may also be used within zle widgets.
 
       Note that despite the mnemonic 'key' this option does read full characters, which may consist of multiple bytes if the option MULTIBYTE is set.
 
${E_WHITE_FG}-z${E_RESET}     Read one entry from the editor buffer stack and assign it to the first name, without word splitting. Text is pushed onto the stack with 'print -z' 
       or with push-line from the line editor (see zshzle(1)). This flag is ignored when the -k or -q flags are present.
 
${E_WHITE_FG}-e -E${E_RESET}  The input read is printed (echoed) to the standard output. If the -e flag is used, no input is assigned to the parameters.
 
${E_WHITE_FG}-A${E_RESET}     The first name is taken as the name of an array and all words are assigned to it.
 
${E_WHITE_FG}-c -l${E_RESET}  These flags are allowed only if called inside a function used for completion (specified with the -K flag to com- pctl).  If the -c flag is given, 
       the words of the current command are read. If the -l flag is given, the whole line is assigned as a scalar. If both flags are present, -l is used 
       and -c is ignored.
 
${E_WHITE_FG}-n${E_RESET}     Together with -c, the number of the word the cursor is on is read. With -l, the index of the character the cur- sor is on is read. Note that the 
       command name is word number 1, not word 0, and that when the cursor is at the end of the line, its character index is the length of the line plus one.
 
${E_WHITE_FG}-u n${E_RESET}   Input is read from file descriptor n.
 
${E_WHITE_FG}-p${E_RESET}     Input is read from the coprocess.
 
${E_WHITE_FG}-d${E_RESET}     delim Input is terminated by the first character of delim instead of by newline.
 
${E_WHITE_FG}-t[n]${E_RESET}  Test if input is available before attempting to read.  If num is present, it must begin with a digit and will be evaluated to give a number of 
       seconds, which may be a floating point number; in this case the read times out if input is not available within this time. If num is not present, 
       it is taken to be zero, so that read returns immediately if no input is available. If no input is available, return status 1 and do not set 
       any variables.

       This option is not available when reading from the editor buffer with -z, when called from within completion with -c or -l, with -q which clears 
       the input queue before reading, or within zle where other mechanisms should be used to test for input.

       Note that read does not attempt to alter the input processing mode. The default mode is canonical input, in which an entire line is read at a time,
       so usually 'read -t' will not read anything until an entire line has been typed. However, when reading from the terminal with -k input is processed 
       one key at a time; in this case, only availability of the first character is tested, so that e.g.  'read -t -k 2' can still block on the second 
       character.  Use two instances of 'read -t -k' if this is not what is wanted.
 
       If the first argument contains a '?', the remainder of this word is used as a prompt on standard error when the shell is interactive.
 
       The value (exit status) of read is 1 when an end-of-file is encountered, or when -c or -l is present and the command is not called from a compctl 
       function, or as described for -q. Otherwise the value is 0.

       The behavior of some combinations of the -k, -p, -q, -u and -z flags is undefined. Presently -q cancels all the oth- ers, -p cancels -u, 
       -k cancels -z, and otherwise -z cancels both -p and -u.

       The -c or -l flags cancel any and all of -kpquz.

===================
${E_MAGENTA_FG}BUILTINS${E_RESET}
===================
       Some  shell  builtin  commands  take options as described in individual entries; these are often referred to in the list below as 'flags'
       to avoid confusion with shell options, which may also have an effect on the behaviour of builtin commands.  In this introductory section,
       'option' always has the meaning of an option to a command that should be familiar to most command line users.

       Typically,  options are single letters preceded by a hyphen (-).  Options that take an argument accept it either immediately following
       the option letter or after white space, for example 'print -C3 *' or 'print -C 3 *' are equivalent.  Arguments to options are not the same as
       arguments to the  command;  the	documentation indicates which is which.  Options that do not take an argument may be combined in a single word,
       for example 'print -ca *' and 'print -c -a *' are equivalent.  Some shell builtin commands also take options that begin with '+'
       instead of '-'.	The list below makes clear which commands these are.  Options	(together  with  their individual arguments, if any) must
       appear in a group before any non-option arguments; once the first non-option argument has been found, option processing is terminated.

       All builtin commands other than precommand modifiers, even those that have no options, can be given the argument '--' to terminate
       option processing.  This indi‐ cates  that  the  following words are non-option arguments, but is otherwise ignored.  This is
       useful in cases where arguments to the command may begin with '-'.  For historical reasons, most builtin commands also recognize a single
       '-' in a separate word for this purpose; note that this is less standard and use of '--' is recommended.

       - simple command
	      See the section 'Precommand Modifiers' in zshmisc(1).

       . file [ arg ... ]
	      Read commands from file and execute them in the current shell environment.

	      If  file does not contain a slash, or if PATH_DIRS is set, the shell looks in the components of \${path} to find the directory
	      containing file.	Files in the current directory are not read unless '.' appears somewhere in \${path}.  If a file named
	      'file.zwc' is found, is newer than file, and is the  compiled form (created with the zcompile builtin) of file, then commands
	      are read from that file instead of file.

	      If  any  arguments arg are given, they become the positional parameters; the old positional parameters are restored when the
	      file is done executing.  How‐ ever, if no arguments are given, the positional parameters remain those of the calling context,
	      and no restoring is done.

	      If file was not found the return status is 127; if file was found but contained a syntax error the return status is 126; else the
	      return  status  is  the exit status of the last command executed.

       : [ arg ... ]
	      This command does nothing, although normal argument expansions is performed which may have effects on shell parameters.
	      A zero exit status is returned.

       alias [ {+|-}gmrsL ] [ name[=value] ... ]
	      For  each name with a corresponding value, define an alias with that value.	A trailing space in value causes the next
	      word to be checked for alias expan‐ sion.  If the -g flag is present, define a global alias; global aliases are expanded
	      even if they do not occur in command position.

	      If the -s flag is present, define a suffix alias: if the command word on a command line is in the form 'text.name', where text
	      is any non-empty string, it is  replaced	by  the  text 'value text.name'.  Note that name is treated as a literal string,
	      not a pattern.  A trailing space in value is not special in this case.  For example,

		     alias -s ps=gv

	      will cause the command '*.ps' to be expanded to 'gv *.ps'.  As alias expansion is carried out earlier than globbing, the
	      '*.ps'  will  then  be  expanded.  Suffix  aliases  constitute a different name space from other aliases (so in the above example
	      it is still possible to create an alias for the command ps) and the two sets are never listed together.

	      For each name with no value, print the value of name, if any.  With no arguments, print all currently defined aliases other than
	      suffix aliases.	If  the -m  flag  is  given  the arguments are taken as patterns (they should be quoted to preserve them from
	      being interpreted as glob patterns), and the aliases matching these patterns are printed.  When printing aliases and one of the
	      -g, -r or -s flags is present, restrict the printing to global, regular or suf‐ fix aliases, respectively; a regular alias is
	      one which is neither a global nor a suffix alias.   Using '+' instead of '-', or ending the option list with a single '+',
	      prevents the values of the aliases from being printed.

	      If the -L flag is present, then print each alias in a manner suitable for putting in a startup script.  The exit status is
	      nonzero  if  a  name  (with  no value) is given for which no alias has been defined.

	      For more on aliases, include common problems, see the section ALIASING in zshmisc(1).

       autoload [ {+|-}RTUXdkmrtWz ] [ -w ] [ name ... ]
	      See  the	section  'Autoloading  Functions' in zshmisc(1) for full details.  The fpath parameter will be searched to find
	      the function definition when the function is first referenced.

	      If name consists of an absolute path, the function is defined to load from the file given (searching as usual for dump files
	      in the given location).	The name  of  the function is the basename (non-directory part) of the file.  It is normally an
	      error if the function is not found in the given location; how‐ ever, if the option -d is given, searching for the function
	      defaults to \${fpath}.  If a function is loaded by absolute path, any functions  loaded  from  it that are marked for autoload
	      without an absolute path have the load path of the parent function temporarily prepended to \${fpath}.

	      If the option -r or -R is given, the function is searched for immediately and the location is recorded internally for use
	      when the function is executed; a relative path is expanded using the value of \${PWD}.	This protects against a change to
	      \${fpath} after the call to autoload.  With -r, if the function is not found,  it  is silently left unresolved until execution;
	      with -R, an error message is printed and command processing aborted immediately the search fails, i.e. at the autoload
	      command rather than at function execution..

	      The flag -X may be used only inside a shell function.  It causes the calling function to be marked for autoloading and then
	      immediately  loaded  and	exe‐ cuted, with the current array of positional parameters as arguments.  This replaces the previous
	      definition of the function.  If no function definition is found, an error is printed and the function remains undefined and
	      marked for autoloading.  If an argument is given, it is used as  a  directory	(i.e.  it does	not  include the name of
	      the function) in which the function is to be found; this may be combined with the -d option to allow the function search
	      to default to \${fpath} if it is not in the given location.

	      The flag +X attempts to load each name as an autoloaded function, but does not execute it.	The exit status is zero (success) if
	      the function was not pre‐ viously  defined  and a definition for it was found.  This does not replace any existing definition
	      of the function.	The exit status is nonzero (failure) if the function was already defined or when no definition was found.
	      In the latter case the function remains undefined and marked for  autoloading.   If ksh-style	autoloading is enabled,
	      the function created will contain the contents of the file plus a call to the function itself appended to it, thus giv‐
	      ing normal ksh autoloading behaviour on the first call to the function.  If the -m flag is also given each name is treated
	      as a pattern and all  functions already marked for autoload that match the pattern are loaded.

	      With the -t flag, turn on execution tracing; with -T, turn on execution tracing only for the current function, turning
	      it off on entry to any called func‐ tions that do not also have tracing enabled.

	      With the -U flag, alias expansion is suppressed when the function is loaded.

	      With the -w flag, the names are taken as names of files compiled with the zcompile builtin, and all functions defined in them
	      are marked for autoloading.

	      The flags -z and -k mark the function to be autoloaded using the zsh or ksh style, as if the option KSH_AUTOLOAD were unset
	      or  were	set,  respectively.  The flags override the setting of the option at the time the function is loaded.

	      Note  that  the  autoload  command makes no attempt to ensure the shell options set during the loading or execution of the
	      file have any particular value.  For this, the emulate command can be used:

		     emulate zsh -c 'autoload -Uz func'

	      arranges that when func is loaded the shell is in native zsh emulation, and this emulation is also applied when func is run.

	      Some of the functions of autoload are also provided by functions -u or functions -U, but autoload is a more comprehensive
	      interface.

       bg [ job ... ] job ... &
	      Put each specified job in the background, or the current job if none is specified.

       bindkey
	      See the section 'Zle Builtins' in zshzle(1).

       break [ n ]
	      Exit from an enclosing for, while, until, select or repeat loop. If an arithmetic expression n is specified, then break
	      n levels instead of just one.

       builtin name [ args ... ]
	      Executes the builtin name, with the given args.

       bye    Same as exit.

       cap    See the section 'The zsh/cap Module' in zshmodules(1).

       cd [ -qsLP ] [ arg ] cd [ -qsLP ] old new cd [ -qsLP ] {+|-}n Change the current directory.  In the first form, change the
	      current directory to arg, or to the value of \${HOME} if arg is not specified.  If arg  is  '-', change to the previous directory.

	      Otherwise, if arg begins with a slash, attempt to change to the directory given by arg.

	      If  arg  does  not begin with a slash, the behaviour depends on whether the current directory '.' occurs in the list of
	      directories contained in the shell parameter cdpath.  If it does not, first attempt to change to the directory arg under
	      the current directory, and if that fails but cdpath is set and  con‐ tains  at least one element attempt to change
	      to the directory arg under each component of cdpath in turn until successful.  If '.' occurs in cdpath, then cdpath is
	      searched strictly in order so that '.' is only tried at the appropriate point.

	      The order of testing cdpath is modified if the option POSIX_CD is set, as described in the documentation for the option.

	      If no directory is found, the option CDABLE_VARS is set, and a parameter named arg exists whose value begins with a slash,
	      treat its value as  the  direc‐ tory.  In that case, the parameter is added to the named directory hash table.

	      The second form of cd substitutes the string new for the string old in the name of the current directory, and tries to change
	      to this new directory.

	      The  third form of cd extracts an entry from the directory stack, and changes to that directory.  An argument of the form '+n'
	      identifies a stack entry by counting from the left of the list shown by the dirs command, starting with zero.  An argument of
	      the form '-n' counts from the right.  If the PUSHD_MINUS option is set, the meanings of '+' and '-' in this context are swapped.

	      If the -q (quiet) option is specified, the hook function chpwd and the functions in the array chpwd_functions are not called.
	      This is useful for calls to cd that do not change the environment seen by an interactive user.

	      If the -s option is specified, cd refuses to change the current directory if the given pathname contains symlinks.  If the  -P
	      option  is  given  or  the CHASE_LINKS  option is set, symbolic links are resolved to their true values.	If the -L option is
	      given symbolic links are retained in the directory (and not resolved) regardless of the state of the CHASE_LINKS option.

       chdir  Same as cd.

       clone  See the section 'The zsh/clone Module' in zshmodules(1).

       command [ -pvV ] simple command
	      The simple command argument is taken as an external command instead of a function or builtin and  is	executed.  If  the
	      POSIX_BUILTINS  option  is  set, builtins  will also be executed but certain special properties of them are suppressed. The
	      -p flag causes a default path to be searched instead of that in \${path}. With the -v flag, command is similar to whence and
	      with -V, it is equivalent to whence -v.

	      See also the section 'Precommand Modifiers' in zshmisc(1).

       comparguments
	      See the section 'The zsh/computil Module' in zshmodules(1).

       compcall
	      See the section 'The zsh/compctl Module' in zshmodules(1).

       compctl
	      See the section 'The zsh/compctl Module' in zshmodules(1).

       compdescribe
	      See the section 'The zsh/computil Module' in zshmodules(1).

       compfiles
	      See the section 'The zsh/computil Module' in zshmodules(1).

       compgroups
	      See the section 'The zsh/computil Module' in zshmodules(1).

       compquote
	      See the section 'The zsh/computil Module' in zshmodules(1).

       comptags
	      See the section 'The zsh/computil Module' in zshmodules(1).

       comptry
	      See the section 'The zsh/computil Module' in zshmodules(1).

       compvalues
	      See the section 'The zsh/computil Module' in zshmodules(1).

       continue [ n ]
	      Resume the next iteration of the enclosing for, while,
	      until, select or repeat loop. If an arithmetic expression n
	      is specified, break out  of  n-1	loops and resume at the nth
	      enclosing loop.

       declare
	      Same as typeset.

       dirs [ -c ] [ arg ... ] dirs [ -lpv ]
	      With no arguments, print the contents of the directory stack.  Directories are added to this stack with the pushd command,
	      and removed with the cd or popd commands.  If arguments are specified, load them onto the directory stack, replacing
	      anything that was there, and push  the  current  directory onto  the stack.

	      -c     clear the directory stack.

	      -l     print directory names in full instead of using of
	      using ~ expressions (see Dynamic and Static named directories in zshexpn(1)).

	      -p     print directory entries one per line.

	      -v     number the directories in the stack when printing.

       disable [ -afmprs ] name ...
	      Temporarily  disable  the  named hash table elements or patterns.  The default is to disable builtin commands.
	      This allows you to use an external command with the same name as a builtin command.  The -a option causes disable to act
	      on regular or global aliases.  The -s option causes disable to act on suffix aliases.  The -f option causes disable to
	      act on shell functions.  The -r options causes disable to act on reserved words.  Without arguments all disabled hash
	      table elements from the corresponding hash table are printed.  With the -m flag the arguments are taken as patterns (which
	      should be quoted	to  pre‐ vent  them  from undergoing filename expansion), and all hash table elements from the
	      corresponding hash table matching these patterns are disabled.  Dis‐ abled objects can be enabled with the enable command.

	      With the option -p, name ... refer to elements of the shell's pattern syntax as described in the section 'Filename Generation'.
	      Certain elements	can  be disabled separately, as given below.  
	      Note  that  patterns  not allowed by the current settings for the options EXTENDED_GLOB, KSH_GLOB and SH_GLOB are never enabled,
	      regardless of the setting here.  For example, if EXTENDED_GLOB is not active, the pattern ^ is ineffective even if 'disable
	      -p "^"' has not been issued.  The list  below  indicates any  option  settings  that restrict the use of the pattern.
	      It should be noted that setting SH_GLOB has a wider effect than merely disabling patterns as certain expressions, in
	      particular those involving parentheses, are parsed differently.

	      The following patterns may be disabled; all the strings need quoting on the command line to prevent them from being
	      interpreted  immediately	as  patterns and the patterns are shown below in single quotes as a reminder.

	      '?'    The pattern character ? wherever it occurs, including when preceding a parenthesis with KSH_GLOB.

	      '*'    The pattern character * wherever it occurs, including recursive globbing and when preceding a parenthesis with KSH_GLOB.

	      '['    Character classes.

	      '<' (NO_SH_GLOB)
		     Numeric ranges.

	      '|' (NO_SH_GLOB)
		     Alternation in grouped patterns, case statements, or KSH_GLOB parenthesised expressions.

	      '(' (NO_SH_GLOB)
		     Grouping  using  single  parentheses.   Disabling	this does not disable the use of parentheses for KSH_GLOB
		     where they are introduced by a special character, nor for glob qualifiers (use 'setopt NO_BARE_GLOB_QUAL'
		     to disable glob qualifiers that use parentheses only).

	      '~' (EXTENDED_GLOB)
		     Exclusion in the form A~B.

	      '^' (EXTENDED_GLOB)
		     Exclusion in the form A^B.

	      '#' (EXTENDED_GLOB)
		     The pattern character # Wherever it occurs, both for repetition of a previous pattern and for indicating globbing flags.

	      '?(' (KSH_GLOB)
		     The grouping form ?(...).	Note this is also disabled if '?' is disabled.

	      '*(' (KSH_GLOB)
		     The grouping form *(...).	Note this is also disabled if '*' is disabled.

	      '+(' (KSH_GLOB)
		     The grouping form +(...).

	      '!(' (KSH_GLOB)
		     The grouping form !(...).

	      '@(' (KSH_GLOB)
		     The grouping form @(...).

       disown [ job ... ] job ... &| job ... &!
	      Remove the specified jobs from the job table; the shell will no longer report their status, and will not complain if you try
	      to exit an interactive  shell with them running or stopped.  If no job is specified, disown the current job.

	      If  the  jobs  are  currently  stopped and the AUTO_CONTINUE option is not set, a warning is printed containing information
	      about how to make them running after they have been disowned.  If one of the latter two forms is used, the jobs will
	      automatically be made running, independent of  the  setting of  the AUTO_CONTINUE option.

       echo [ -neE ] [ arg ... ]
	      Write  each arg on the standard output, with a space separating each one.  If the -n flag is not present, print a newline at
	      the end.	echo recognizes the following escape sequences:

	      \a     bell character \b	   backspace \c     suppress subsequent characters and final newline \e	  escape \f	form feed \n
	      linefeed (newline) \r	carriage return \t     horizontal tab \v	 vertical tab \\     backslash \0NNN  character code
	      in octal \xNN   character code in hexadecimal \uNNNN unicode character code in hexadecimal \UNNNNNNNN unicode character code in hexadecimal

	      The -E flag, or the BSD_ECHO option, can be used to disable these escape sequences.  In the latter case, -e flag can be
	      used to enable them.

       echotc See the section 'The zsh/termcap Module' in zshmodules(1).

       echoti See the section 'The zsh/terminfo Module' in zshmodules(1).

       emulate [ -lLR ] [ {zsh|sh|ksh|csh} [ flags ... ] ]
	      Without any argument print current emulation mode.

	      With single argument set up zsh options to emulate the specified shell as much as possible.  csh will never be fully emulated.
	      If the argument is not one of the shells listed above, zsh will be used as a default; more precisely, the tests performed
	      on the argument are the same as those used to determine the emulation at startup based on the shell name, see the section
	      COMPATIBILITY in zsh(1) .  In addition to setting shell options, the command  also  restores the pristine state of pattern
	      enables, as if all patterns had been enabled using enable -p.

	      If  the  emulate	command  occurs  inside a function that has been marked for execution tracing with functions -t then the
	      xtrace option will be turned on regardless of emulation mode or other options.  Note that code executed inside the function
	      by the ., source, or eval commands is  not  considered  to be running directly from the function, hence does not provoke
	      this behaviour.

	      If the -R switch is given, all settable options are reset to their default value corresponding to the specified emulation
	      mode, except for certain options describing the interactive environment; otherwise, only those options likely to cause
	      portability problems in scripts and functions are altered.  If  the -L  switch  is  given,  the  options LOCAL_OPTIONS,
	      LOCAL_PATTERNS and LOCAL_TRAPS will be set as well, causing the effects of the emulate command and any setopt, disable -p
	      or enable -p, and trap commands to be local to the immediately surrounding shell function, if any; normally these  options
	      are  turned off in all emulation modes except ksh. The -L switch is mutually exclusive with the use of -c in flags.

	      If  there  is a single argument and the -l switch is given, the options that would be set or unset (the latter indicated
	      with the prefix 'no') are listed.  -l can be combined with -L or -R and the list will be modified in the appropriate way.
	      Note the list does not depend on the current setting  of options, i.e. it includes all options that may in principle
	      change, not just those that would actually change.

	      The  flags  may  be  any	of  the invocation-time flags described in the section INVOCATION in zsh(1), except that '-o EMACS' and
	      '-o VI' may not be used.	Flags such as '+r'/'+o RESTRICTED' may be prohibited in some circumstances.

	      If -c arg appears in flags, arg is evaluated while the requested emulation is temporarily in effect.  In this case the emulation
	      mode and all options  are restored  to  their  previous values before emulate returns.  The -R switch may precede the name
	      of the shell to emulate; note this has a meaning distinct from including -R in flags.

	      Use of -c enables 'sticky' emulation mode for functions defined within the evaluated expression:	the emulation mode
	      is  associated  thereafter  with	the function  so  that whenever	the  function is executed the emulation (respecting
	      the -R switch, if present) and all options are set (and pattern disables cleared) before entry to the function, and the state
	      is restored after exit.  If the function is called when the sticky emulation is  already  in	effect, either	within	an
	      'emulate shell -c' expression or within another function with the same sticky emulation, entry and exit from the function
	      do not cause options to be altered (except due to standard processing such as the LOCAL_OPTIONS option).  This also applies
	      to functions marked for autoload within the sticky emulation; the appropriate set of options will be applied at the point
	      the function is loaded as well as when it is run.

	      For example:

		     emulate sh -c 'fni() { setopt cshnullglob; } fno() {
		     fni; }' fno

	      The  two	functions fni and fno are defined with sticky sh emulation.  fno is then executed, causing options associated
	      with emulations to be set to their values in sh.	fno then calls fni; because fni is also marked for sticky sh emulation,
	      no option changes take place on entry to or exit	from  it.  Hence the  option  cshnullglob,  turned off by sh emulation,
	      will be turned on within fni and remain on return to fno.  On exit from fno, the emulation mode and all options will
	      be restored to the state they were in before entry to the temporary emulation.

	      The documentation above is typically sufficient for the intended purpose of executing code designed for other shells
	      in  a  suitable  environment.   More detailed rules follow.  

		  1.     The sticky emulation environment provided by 'emulate shell -c' is identical to that provided by entry to a function marked 
		  for sticky emulation as a consequence of being defined in such an environment.  Hence, for example, the sticky emulation is inherited 
		  by subfunctions defined within  func‐ tions with sticky emulation.

	      2.     No  change of options takes place on entry to or exit from functions that are not marked for sticky emulation,
	      other than those that would normally take place, even if those functions are called within sticky emulation.

	      3.     No special handling is provided for functions marked for autoload nor for functions present in wordcode created by
	      the zcompile command.  4.     The presence or absence of the -R switch to emulate corresponds to different sticky emulation
	      modes, so for example 'emulate sh -c', 'emulate -R sh -c' and 'emulate csh -c' are treated as three distinct sticky emulations.

	      5.     Difference  in shell options supplied in addition to the basic emulation also mean the sticky emulations are different,
	      so for example 'emulate zsh -c' and 'emulate zsh -o cbases -c' are treated as distinct sticky emulations.

       enable [ -afmprs ] name ...
	      Enable the named hash table elements, presumably disabled earlier with disable.  The default is to enable builtin commands.  The -a
	      option  causes  enable to  act  on regular or global aliases.  The -s option causes enable to act on suffix aliases.  The -f
	      option causes enable to act on shell functions.  The -r option causes enable to act on reserved words.  Without arguments all
	      enabled hash table elements from the corresponding hash table are printed.   With the  -m  flag the arguments are taken as
	      patterns (should be quoted) and all hash table elements from the corresponding hash table matching these patterns are enabled.
	      Enabled objects can be disabled with the disable builtin command.

	      enable -p reenables patterns disabled with disable -p.  Note that it does not override globbing options; for example, 'enable -p
	      "~"' does not  cause  the pattern  character ~ to be active unless the EXTENDED_GLOB option is also set.  To enable all
	      possible patterns (so that they may be individually disabled with disable -p), use 'setopt EXTENDED_GLOB KSH_GLOB NO_SH_GLOB'.

       eval [ arg ... ]
	      Read the arguments as input to the shell and execute the resulting command(s) in the current shell process.  The return
	      status is the same as if the  com‐ mands had been executed directly by the shell; if there are no args or they contain no
	      commands (i.e. are an empty string or whitespace) the return status is zero.

       exec [ -cl ] [ -a argv0 ] [ command [ arg ... ] ]
	      Replace the current shell with command rather than forking.  If command is a shell builtin command or a shell function,
	      the shell executes it, then  imme‐ diately exits.

	      With  -c clear the environment; with -l prepend - to the argv[0] string of the command executed (to simulate a login shell);
	      with -a argv0 set the argv[0] string of the command executed.
	      See the section 'Precommand Modifiers' in zshmisc(1).

	      If the option POSIX_BUILTINS is set, command is never interpreted as a shell builtin command or shell function.
	      This means further  precommand  modifiers such as builtin and noglob are also not interpreted within the shell.  Hence command
	      is always found by searching the command path.

	      If command is omitted but any redirections are specified, then the redirections will take effect in the current shell.

       exit [ n ]
	      Exit the shell with the exit status specified by an arithmetic expression n; if none is specified, use the exit status from
	      the last command executed.  An EOF condition will also cause the shell to exit, unless the IGNORE_EOF option is set.

	      See notes at the end of the section JOBS in zshmisc(1) for some possibly unexpected interactions of the exit command with jobs.

       export [ name[=value] ... ]
	      The specified names are marked for automatic export to the environment of subsequently executed commands.  Equivalent to
	      typeset  -gx.   If  a  parameter specified does not already exist, it is created in the global scope.

       false [ arg ... ]
	      Do nothing and return an exit status of 1.

       fc [ -e ename ] [ -LI ] [ -m match ] [ old=new ... ] [ first [ last ] ] 
	    fc -l [ -LI ] [ -nrdfEiD ] [ -t timefmt ] [ -m match ] [ old=new ... ] [ first [ last ] ]
       fc -p [ -a ] [ filename [ histsize [ savehistsize ] ] ] fc -P fc -ARWI [ filename ]
	      The  fc  command	controls the interactive history mechanism.  Note that reading and writing of history options is only
	      performed if the shell is interac‐ tive.  Usually this is detected automatically, but it can be forced by setting the
	      interactive option when starting the shell.

	      The first two forms of this command select a range of events from first to last from the history list.  The arguments
	      first and last may be specified as a number  or  as  a string.  A negative number is used as an offset to the current history
	      event number.  A string specifies the most recent event beginning with the given string.	All substitutions old=new,
	      if any, are then performed on the text of the events.

	      In addition to the number range, -I     restricts to only internal events (not from \${HISTFILE}) -L	  restricts to
	      only local events (not from other shells, see SHARE_HISTORY in zshoptions(1) -- note that \${HISTFILE} is considered local
	      when  read  at startup) -m     takes the first argument as a pattern (should be quoted)
	      and only the history events matching this pattern are considered

	      If  first  is not specified, it will be set to -1 (the most recent event), or to -16 if the -l flag is given.  If last is
	      not specified, it will be set to first, or to -1 if the -l flag is given.  However, if the current event has added entries to the
	      history with 'print -s' or 'fc -R', then the default last for -l includes all new history entries since the current event began.

	      When  the  -l flag is given, the resulting events are listed on standard output.  Otherwise the editor program ename is
	      invoked on a file containing these history events.  If ename is not given, the value of the parameter FCEDIT is used; if
	      that is not set the value of the parameter EDITOR is used; if  that is not set a builtin default, usually 'vi' is used.
	      If ename is '-', no editor is invoked.  When editing is complete, the edited command is executed.

	      The flag -r reverses the order of the events and the flag -n suppresses event numbers when listing.

		Also when listing, 
		-d prints timestamps for each event -f prints full time-date stamps in the US 'MM/DD/YY hh:mm' format
		-E prints full time-date stamps in the European 'dd.mm.yyyy hh:mm' format 
		-i prints full time-date stamps in ISO8601 'yyyy-mm-dd hh:mm' format 
		-t fmt prints time and date stamps in the given format; fmt is formatted with the strftime function
			with the zsh extensions described for the %D{string} prompt format in the section EXPANSION OF PROMPT SEQUENCES
			in zshmisc(1).  The resulting formatted string must be no more than  256 characters  or will not be printed
		-D prints elapsed times; may be combined with one of the options above

	      'fc  -p'	pushes	the current history list onto a stack and switches to a new history list.  If the -a option is also
	      specified, this history list will be automatically popped when the current function scope is exited, which is a much
	      better solution than creating a trap function to call  'fc  -P' manually.  If  no  arguments  are  specified,  the history list
	      is left empty, \${HISTFILE} is unset, and \${HISTSIZE} & \${SAVEHIST} are set to their default values.	If one argument is given,
	      \${HISTFILE} is set to that filename, \${HISTSIZE} & \${SAVEHIST} are left unchanged, and the history file is read in (if it exists)
	      to initial‐ ize  the  new  list.  If a second argument is specified, \${HISTSIZE} & \${SAVEHIST} are instead set to the single
	      specified numeric value.	Finally, if a third argument is specified, \${SAVEHIST} is set to a separate value from \${HISTSIZE}.
	      You are free to change these environment values for the new history list how‐ ever you desire in order to manipulate
	      the new history list.

	      'fc  -P'	pops  the history list back to an older list saved by 'fc -p'.  The current list is saved to its \${HISTFILE} before
	      it is destroyed (assuming that \${HISTFILE} and \${SAVEHIST} are set appropriately, of course).  The values of \${HISTFILE}, \${HISTSIZE},
	      and \${SAVEHIST} are restored to the values they had when 'fc -p' was  called.   Note that this restoration can conflict with
	      making these variables "local", so your best bet is to avoid local declarations for these variables in functions that use
	      'fc -p'.	The one other guaranteed-safe combination is declaring these variables to be local at the top of  your  function and
	      using the automatic option (-a) with 'fc -p'.  Finally, note that it is legal to manually pop a push marked for automatic
	      popping if you need to do so before the function exits.

	      'fc -R' reads the history from the given file, 'fc -W' writes the history out to the given file, and 'fc -A' appends the history
	      out to  the  given  file.  If  no  filename  is  specified, the  \${HISTFILE} is assumed.  If the -I option is added to -R,
	      only those events that are not already contained within the internal history list are added.	If the -I option is added to
	      -A or -W, only those events that are new since last incremental append/write to the history file are appended/written.  In any
	      case, the created file will have no more than \${SAVEHIST} entries.

       fg [ job ... ] job ...
	      Bring each specified job in turn to the foreground.  If no job is specified, resume the current job.

       float [ {+|-}Hghlprtux ] [ {+|-}EFLRZ [ n ] ] [ name[=value] ... ]
	      Equivalent to typeset -E, except that options irrelevant to floating point numbers are not permitted.

       functions [ {+|-}UkmtTuWz ] [ -x num ] [ name ... ] functions -M [-s] mathfn [ min [ max [ shellfn ] ] ] functions -M [ -m pattern ... ]
       functions +M [ -m ] mathfn ...
	      Equivalent  to  typeset  -f,  with the exception of the -x, -M and -W options.  For functions -u and functions -U, see
	      autoload, which provides additional options.

	      The -x option indicates that any functions output will have each leading tab for indentation, added by the shell to show
	      syntactic structure, expanded  to the given number num of spaces.  num can also be 0 to suppress all indentation.

	      The  -W  option  turns  on the option WARN_NESTED_VAR for the named function or functions only.  The option is turned off at
	      the start of nested functions (apart from anonoymous functions) unless the called function also has the -W attribute.

	      Use of the -M option may not be combined with any of the options handled by typeset -f.

	      functions -M mathfn defines mathfn as the name of a mathematical function recognised in all forms of arithmetical expressions;
	      see the section 'Arithmetic Evaluation'  in  zshmisc(1).  By default mathfn may take any number of comma-separated
	      arguments.  If min is given, it must have exactly min args; if min and max are both given, it must have at least min and
	      at most max args.  max may be -1 to indicate that there is no upper limit.

	      By default the function is implemented by a shell function of the same name; if shellfn is specified it gives the name of
	      the corresponding shell function while mathfn remains the name used in arithmetical expressions.  The name of the function in
	      \${0} is mathfn (not shellfn as would usually be the case), pro‐ vided the option FUNCTION_ARGZERO is in effect.  The positional
	      parameters in the shell function correspond to the arguments of the mathematical  function call.  The result of the last
	      arithmetical expression evaluated inside the shell function (even if it is a form that normally only returns a status)
	      gives the result of the mathematical function.

	      If the additional option -s is given to functions -M, the argument to the function is a single string: anything between
	      the opening and  matching  closing parenthesis  is  passed to the function as a single argument, even if it includes commas
	      or white space.  The minimum and maximum argument specifiers must therefore be 1 if given.  An empty argument list is passed
	      as a zero-length string.

	      functions -M with no arguments lists all such user-defined
	      functions in the same form as a definition.  With the additional option -m and a list of  argu‐ ments, all functions whose
	      mathfn matches one of the pattern arguments are listed.

	      function +M removes the list of mathematical functions; with the additional option -m the arguments are treated as
	      patterns and all functions whose mathfn matches the pattern are removed.  Note that the shell function implementing the
	      behaviour is not removed (regardless of whether its  name
	      coincides  with mathfn).

	      For example, the following prints the cube of 3:

		     zmath_cube() { (( \${1} * \${1} * \${1} )) } functions -M cube
		     1 1 zmath_cube print \$(( cube(3) ))

	      The following string function takes a single argument, including
	      the commas, so prints 11:

		     stringfn() { (( \${#1} )) } functions -Ms stringfn print \$(( stringfn(foo,bar,rod) ))

       getcap See the section 'The zsh/cap Module' in zshmodules(1).

       getln [ -AclneE ] name ...
	      Read the top value from the buffer stack and put it in the shell parameter name.  Equivalent to read -zr.

       getopts optstring name [ arg ... ]
	      Checks the args for legal options.  If the args are omitted, use the positional parameters.  A valid option argument begins
	      with a '+' or a '-'.  An argu‐ ment not beginning with a '+' or a '-', or the argument '--', ends the options.  Note that a
	      single '-' is not considered a valid option  argument.   opt‐ string  contains	the  letters that getopts recognizes.  If a
	      letter is followed by a ':', that option requires an argument.  The options can be separated from the argument by blanks.

	      Each time it is invoked, getopts places the option letter it finds in the shell parameter name, prepended with a '+' when
	      arg  begins  with  a  '+'.   The index of the next arg is stored in OPTIND.  The option argument, if any, is stored in OPTARG.

	      The  first  option to be examined may be changed by explicitly assigning to OPTIND.  OPTIND has an initial value of 1, and is
	      normally set to 1 upon entry to a shell function and restored upon exit (this is disabled by the POSIX_BUILTINS option).
	      OPTARG is not reset and  retains	its  value  from  the  most recent  call to getopts.	If either of OPTIND or OPTARG is
	      explicitly unset, it remains unset, and the index or option argument is not stored.  The option itself is still stored in
	      name in this case.

	      A leading ':' in optstring causes getopts to store the letter of any invalid option in OPTARG, and to set name to '?' for
	      an unknown  option  and  to  ':' when  a	required  argument is  missing.   Otherwise, getopts sets name to '?' and prints
	      an error message when an option is invalid.  The exit status is nonzero when there are no more options.

       hash [ -Ldfmrv ] [ name[=value] ] ...
	      hash can be used to directly modify the contents of the command
	      hash table, and the named directory hash table.  Normally one would modify these tables by modifying  one's  PATH  (for the
	      command hash table) or by creating appropriate shell parameters (for the named directory hash table).  The choice of hash table
	      to work on is determined by the -d option; without the option the command hash table is used, and with the option the named
	      directory hash table  is used.  Given no arguments, and neither the -r or -f options, the
	      selected hash table will be listed in full.

	      The  -r  option  causes  the selected hash table to be emptied.  It will be subsequently rebuilt in the normal fashion.
	      The -f option causes the selected hash table to be fully rebuilt immediately.  For the command hash table this hashes
	      all the absolute directories in the PATH, and for the named directory hash table this adds all users' home directories.
	      These two options cannot be used with any arguments.

	      The  -m  option  causes  the  arguments  to  be  taken as patterns (which should be quoted) and the elements of the hash
	      table matching those patterns are printed.  This is the only way to display a limited selection of hash table elements.

	      For each name with a corresponding value, put 'name' in the selected hash table, associating it with the pathname 'value'.
	      In  the  command	hash  table, this  means  that whenever 'name' is used as a command argument, the shell will try to execute
	      the file given by 'value'.  In the named directory hash ta‐ ble, this means that 'value' may be referred to as '~name'.

	      For each name with no corresponding value, attempt to add name to the hash table, checking what the appropriate value is in
	      the  normal  manner  for	that hash table.  If an appropriate value can't be found, then the hash table will be unchanged.

	      The -v option causes hash table entries to be listed as they are added by explicit specification.  If has no effect if used
	      with -f.

	      If the -L flag is present, then each hash table entry is printed in the form of a call to hash.

       history
	      Same as fc -l.

       integer [ {+|-}Hghlprtux ] [ {+|-}LRZi [ n ] ] [ name[=value] ... ]
	      Equivalent to typeset -i, except that options irrelevant to
	      integers are not permitted.

       jobs [ -dlprs ] [ job ... ] jobs -Z string
	      Lists  information  about  each given job, or all jobs if
	      job is omitted.  The -l flag lists process IDs, and the -p
	      flag lists process groups.  If the -r flag is specified only
	      running jobs will be listed and if the -s flag is given only
	      stopped jobs are shown.  If the -d flag is given, the  directory
	      from which the job was started (which may not be the current
	      directory of the job) will also be shown.

	      The  -Z option replaces the shell's argument and environment
	      space with the given string, truncated if necessary to fit.
	      This will normally be visible in ps (ps(1)) listings.  This
	      feature is typically used by daemons, to indicate their state.

       kill [ -s signal_name | -n signal_number | -sig ] job ...  kill -l [ sig ... ]
	      Sends either SIGTERM or the specified signal to the given jobs or processes.  Signals are given by number or by names,
	      with or without the  'SIG'  prefix.  If the signal being sent is not 'KILL' or 'CONT', then the job will be sent a 'CONT'
	      signal if it is stopped.	The argument job can be the process ID of a job not in the job list.	In the second form, kill -l,
	      if sig is not specified the signal names are listed.  Otherwise, for each sig that is a  name,  the corresponding signal number
	      is listed.  For each sig that is a signal number or a number representing the exit status of a process which was terminated
	      or stopped by a signal the name of the signal is printed.

	      On some systems, alternative signal names are allowed for a few signals.	Typical examples are SIGCHLD and SIGCLD or SIGPOLL and
	      SIGIO, assuming they cor‐ respond to the same signal number.  kill -l will only list the preferred form, however kill -l
	      alt will show if the alternative form corresponds to a sig‐ nal number.  For example, under Linux kill -l IO and kill -l
	      POLL both output 29, hence kill -IO and kill -POLL have the
	      same effect.

	      Many systems will allow process IDs to be negative to kill a
	      process group or zero to kill the current process group.

       let arg ...
	      Evaluate each arg as an arithmetic expression.  See the section 'Arithmetic Evaluation' in zshmisc(1) for a description of
	      arithmetic  expressions.	 The exit status is 0 if the value of the last expression is nonzero, 1 if it is zero, and 2 if
	      an error occurred.

       limit [ -hs ] [ resource [ limit ] ] ...
	      Set  or  display resource limits.  Unless the -s flag is given, the limit applies only the children of the shell.  If -s is given
	      without other arguments, the resource limits of the current shell is set to the previously set resource limits of the children.

	      If limit is not specified, print the current limit placed on resource, otherwise set the limit to the specified value.
	      If the -h flag is given, use  hard limits instead of soft limits.  If no resource is given, print all limits.

	      When  looping  over  multiple  resources, the shell will abort immediately if it detects a badly formed argument.  However,
	      if it fails to set a limit for some other reason it will continue trying to set the remaining limits.

	      resource can be one of:

	      addressspace
		     Maximum amount of address space used.
	      aiomemorylocked
		     Maximum amount of memory locked in RAM for AIO operations.
	      aiooperations
		     Maximum number of AIO operations.
	      cachedthreads
		     Maximum number of cached threads.
	      coredumpsize
		     Maximum size of a core dump.
	      cputime
		     Maximum CPU seconds per process.
	      datasize
		     Maximum data size (including stack) for each process.
	      descriptors
		     Maximum value for a file descriptor.
	      filesize
		     Largest single file allowed.
	      kqueues
		     Maximum number of kqueues allocated.
	      maxproc
		     Maximum number of processes.
	      maxpthreads
		     Maximum number of threads per process.
	      memorylocked
		     Maximum amount of memory locked in RAM.
	      memoryuse
		     Maximum resident set size.
	      msgqueue
		     Maximum number of bytes in POSIX message queues.
	      posixlocks
		     Maximum number of POSIX locks per user.
	      pseudoterminals
		     Maximum number of pseudo-terminals.
	      resident
		     Maximum resident set size.
	      sigpending
		     Maximum number of pending signals.
	      sockbufsize
		     Maximum size of all socket buffers.
	      stacksize
		     Maximum stack size for each process.
	      swapsize
		     Maximum amount of swap used.
	      vmemorysize
		     Maximum amount of virtual memory.

	      Which of these resource limits are available depends on the system.  resource can be abbreviated to any unambiguous prefix.
	      It can also  be  an  integer, which corresponds to the integer defined for the resource by the operating system.

	      If  argument  corresponds  to a number which is out of the range of the resources configured into the shell, the shell
	      will try to read or write the limit anyway, and will report an error if this fails.  As the shell does not store such
	      resources internally, an attempt to set the limit will fail unless  the -s option is present.

	      limit is a number, with an optional scaling factor, as follows:

	      nh     hours nk	  kilobytes (default) nm     megabytes or minutes ng     gigabytes [mm:]ss minutes and seconds

	      The  limit  command  is  not made available by default when the shell starts in a mode emulating another shell.  It can be made
	      available with the command 'zmodload -F zsh/rlimits b:limit'.

       local [ {+|-}AHUahlprtux ] [ {+|-}EFLRZi [ n ] ] [ name[=value] ... ]
	      Same as typeset, except that the options -g, and -f are not permitted.  In this case the -x option does not force the use
	      of -g, i.e.  exported  variables will be local to functions.

       log    List all users currently logged in who are affected by the current setting of the watch parameter.

       logout [ n ]
	      Same as exit, except that it only works in a login shell.

       noglob simple command
	      See the section 'Precommand Modifiers' in zshmisc(1).

       popd [ -q ] [ {+|-}n ]
	      Remove  an entry from the directory stack, and perform a cd to the new top directory.  With no argument, the current top
	      entry is removed.  An argument of the form '+n' identifies a stack entry by counting from the left of the list shown by the
	      dirs command, starting with zero.  An argument of  the  form -n counts from the right.  If the PUSHD_MINUS option is set,
	      the meanings of '+' and '-' in this context are swapped.

	      If the -q (quiet) option is specified, the hook function chpwd and the functions in the array \${chpwd_functions} are not called,
	      and the new directory stack is not printed.  This is useful for calls to popd that do not change the environment seen by
	      an interactive user.

       print [ -abcDilmnNoOpPrsSz ] [ -u n ] [ -f format ] [ -C cols ] [ -v name ] [ -xX tabstop ] [ -R [ -en ]] [ arg ... ]
	      With the '-f' option the arguments are printed as described by printf.  With no flags or with the flag '-', the arguments
	      are printed on the standard out‐ put  as  described  by echo, with the following differences: the escape sequence '\M-x'
	      (or '\Mx') metafies the character x (sets the highest bit), '\C-x' (or '\Cx') produces a control character ('\C-@' and
	      '\C-?' give the characters NULL and delete), a character	code in  octal  is  represented  by  '\NNN' (instead of '\0NNN'),
	      and '\E' is a synonym for '\e'.  Finally, if not in an escape sequence, '' escapes the following character and is not printed.

	      -a     Print arguments with the column incrementing first.  Only useful with the -c and -C options.

	      -b     Recognize all the escape sequences defined for the bindkey command, see the section 'Zle Builtins' in zshzle(1).

	      -c     Print the arguments in columns.  Unless -a is also given, arguments are printed with the row incrementing first.

	      -C cols
		     Print the arguments in cols columns.  Unless -a is also given, arguments are printed with the row incrementing first.

	      -D     Treat the arguments as paths, replacing directory prefixes with ~ expressions corresponding to directory names,
	      as appropriate.

	      -i     If given together with -o or -O, sorting is performed case-independently.

	      -l     Print the arguments separated by newlines instead of spaces.

	      -m     Take  the first argument as a pattern (should be quoted), and remove it from the argument list together with subsequent
	      arguments that do not match this pattern.

	      -n     Do not add a newline to the output.

	      -N     Print the arguments separated and terminated by nulls.

	      -o     Print the arguments sorted in ascending order.

	      -O     Print the arguments sorted in descending order.

	      -p     Print the arguments to the input of the coprocess.

	      -P     Perform prompt expansion (see EXPANSION OF PROMPT SEQUENCES in zshmisc(1)).  In combination with '-f', prompt
	      escape  sequences  are  parsed  only within interpolated arguments, not within the format string.

	      -r     Ignore the escape conventions of echo.

	      -R     Emulate  the  BSD	echo command, which does not process escape sequences unless the -e flag is given.  The -n flag
	      suppresses the trailing newline.  Only the -e and -n flags are recognized after -R; all other arguments and options are printed.

	      -s     Place the results in the history list instead of on the standard output.  Each argument to the print command is
	      treated as a  single  word  in  the history, regardless of its content.

	      -S     Place  the  results  in  the history list instead of on the standard output.  In this case only a single argument
	      is allowed; it will be split into words as if it were a full shell command line.  The effect
		     is similar to reading the line from  a  history  file with  the	HIST_LEX_WORDS	option active.

	      -u n   Print the arguments to file descriptor n.

	      -v name
		     Store the printed arguments as the value of the parameter name.

	      -x tab-stop
		     Expand leading tabs on each line of output in the printed string assuming a tab stop every tab-stop characters.
		     This is appropriate for formatting code that may be indented with tabs.  Note that leading tabs of any
		     argument to print, not just the first, are expanded, even  if  print  is  using spaces to separate arguments
		     (the column count is maintained across arguments but may be incorrect on output owing to previous unexpanded tabs).

		     The  start  of the output of each print command is assumed to be aligned with a tab stop.  Widths of
		     multibyte characters are handled if the option MULTIBYTE is in effect.  This option is ignored if other formatting
		     options are in effect, namely column alignment or printf style, or if output is to a special location such as
		     shell history or the command line editor.

	      -X tab-stop
		     This  is  similar	to  -x, except that all tabs in the printed string are expanded.  This is appropriate if tabs
		     in the arguments are being used to produce a table format.

	      -z     Push the arguments onto the editing buffer stack, separated by spaces.

	      If any of '-m', '-o' or '-O' are used in combination with '-f' and there are no arguments (after the removal process in the
	      case of '-m') then nothing  is printed.

       printf [ -v name ] format [ arg ... ]
	      Print  the  arguments  according to the format specification. Formatting rules are the same as used in
	      C. The same escape sequences as for echo are recog‐ nised in the format. All C conversion specifications ending in one
	      of csdiouxXeEfgGn are handled. In addition to this, '%b' can be used instead of '%s' to cause  escape  sequences
	      in  the  argument to be recognised and '%q' can be used to quote the argument in such a way that allows it to be
	      reused as shell input. With the numeric format specifiers, if the corresponding argument starts with a quote character,
	      the numeric value of the	following  character  is used  as the number to print; otherwise the argument is evaluated as an
	      arithmetic expression. See the section 'Arithmetic Evaluation' in zshmisc(1) for a description of arithmetic expressions. With
	      '%n', the corresponding argument is taken as an identifier which is created as an integer parameter.

	      Normally, conversion specifications are applied to each argument in order but they can explicitly specify the nth
	      argument is to be used by replacing  '%' by  '%n\$'  and '*' by '*n\$'.  It is recommended that you do not mix references
	      of this explicit style with the normal style and the handling of such mixed styles may be subject to future change.

	      If arguments remain unused after formatting, the format string is reused until all arguments have been consumed. With the
	      print builtin, this can be  sup‐ pressed  by using the -r option. If more arguments are required by the format than have
	      been specified, the behaviour is as if zero or an empty string had been specified as the argument.

	      The -v option causes the output to be stored as the value of the parameter name, instead of printed. If name is an array
	      and the format string  is  reused when consuming arguments then one array element will be used for each use of the format string.

       pushd [ -qsLP ] [ arg ] pushd [ -qsLP ] old new pushd [ -qsLP ] {+|-}n
	      Change  the  current  directory, and push the old current directory onto the directory stack.  In the first form, change
	      the current directory to arg.  If arg is not specified, change to the second directory on the stack (that is, exchange the top
	      two entries), or change to \${HOME} if the PUSHD_TO_HOME  option is  set or if there is only one entry on the stack.  Otherwise,
	      arg is interpreted as it would be by cd.	The meaning of old and new in the second form is also the same as for cd.

	      The third form of pushd changes directory by rotating the directory list.  An argument of the form '+n' identifies a
	      stack entry by counting from the left of	the  list  shown  by the dirs command, starting with zero.  An argument of the form
	      '-n' counts from the right.  If the PUSHD_MINUS option is set, the meanings of '+' and '-' in this context are swapped.

	      If the -q (quiet) option is specified, the hook function chpwd and the functions in the array \${chpwd_functions} are not called,
	      and the new directory stack is not printed.  This is useful for calls to pushd that do not change the environment seen by
	      an interactive user.

	      If the option -q is not specified and the shell option PUSHD_SILENT is not set, the directory stack will be printed
	      after a pushd is performed.

	      The options -s, -L and -P have the same meanings as for the cd builtin.

       pushln [ arg ... ]
	      Equivalent to print -nz.

       pwd [ -rLP ]
	      Print  the absolute pathname of the current working directory.  If the -r or the -P flag is specified, or the CHASE_LINKS
	      option is set and the -L flag is not given, the printed path will not contain symbolic links.

       r      Same as fc -e -.

       readonly
	      Same as typeset -r.  With the POSIX_BUILTINS option set,
	      same as typeset -gr.

       rehash Same as hash -r.

       return [ n ]
	      Causes a shell function or '.' script to return to the invoking script with the return status specified by an arithmetic
	      expression n. If	n  is  omitted, the return status is that of the last command executed.

	      If  return  was  executed  from  a trap in a TRAPNAL function, the effect is different for zero and non-zero return status.
	      With zero status (or after an implicit return at the end of the trap), the shell will return to whatever it was
	      previously processing; with a non-zero status, the shell will behave  as interrupted except that the return status of the
	      trap is retained.  Note that the numeric value of the signal which caused the trap is passed as the first argument, so the
	      statement 'return \$((128+\${1}))' will return the same status as if the signal had not been trapped.

       sched  See the section 'The zsh/sched Module' in zshmodules(1).

       set [ {+|-}options | {+|-}o [ option_name ] ] ... [ {+|-}A [ name ] ] [ arg ... ]
	      Set the options for the shell and/or set the positional parameters, or declare and set an array.	If the -s option is
	      given, it causes the specified argu‐ ments  to	be sorted before assigning them to the positional parameters (or to
	      the array name if -A is used).  With +s sort arguments in descending order.  For the meaning of the other flags, see
	      zshoptions(1).  Flags may be specified by name using the -o option. If no option name is  supplied  with  -o,  the current
	      option  states are printed:  see the description of setopt below for more information on the format.  With +o they are
	      printed in a form that can be used as input to the shell.

	      If the -A flag is specified, name is set to an array containing the given args; if no name is specified, all arrays are printed
	      together with  their  val‐ ues.

	      If  +A  is used and name is an array, the given arguments will replace the initial elements of that array; if no name
	      is specified, all arrays are printed without their values.

	      The behaviour of arguments after -A name or +A name depends on whether the option KSH_ARRAYS is set.	If it is not set,
	      all arguments following  name  are treated as values for the array, regardless of their form.  If the option is set,
	      normal option processing continues at that point; only regular arguments are treated as values for the array.  This means that

		     set -A array -x -- foo

	      sets array to '-x -- foo' if KSH_ARRAYS is not set, but sets the array to foo and turns on the option '-x' if it is set.

	      If the -A flag is not present, but there are arguments beyond the options, the positional parameters are set.  If the option
	      list (if any)  is  terminated by '--', and there are no further arguments, the positional parameters will be unset.

	      If  no  arguments and no '--' are given, then the names and values of all parameters are printed on the standard output.
	      If the only argument is '+', the names of all parameters are printed.

	      For historical reasons, 'set -' is treated as 'set +xv' and 'set - args' as 'set +xv -- args' when in any other emulation
	      mode than zsh's native mode.

       setcap See the section 'The zsh/cap Module' in zshmodules(1).

       setopt [ {+|-}options | {+|-}o option_name ] [ -m ] [ name ... ]
	      Set the options for the shell.  All options specified either with flags or by name are set.

	      If no arguments are supplied, the names of all options currently set are printed.	The form is chosen so as to minimize the
	      differences from	the  default options  for the current emulation (the default emulation being native zsh, shown as
	      <Z> in zshoptions(1)).  Options that are on by default for the emula‐ tion are shown with the prefix no only if they are off,
	      while other options are shown without the prefix no and only if they  are  on.   In  addition  to options  changed  from	the
	      default  state by the user, any options activated automatically by the shell (for example, SHIN_STDIN or INTERACTIVE) will be
	      shown in the list.  The format is further modified by the option KSH_OPTION_PRINT, however the rationale for choosing options
	      with or without the no  pre‐ fix remains the same in this case.

	      If  the  -m flag is given the arguments are taken as patterns (which should be quoted to protect them from filename expansion),
	      and all options with names matching these patterns are set.

	      Note that a bad option name does not cause execution of subsequent shell code to be aborted; this is behaviour is
	      different from that of 'set  -o'.   This is because set is regarded as a special builtin by the POSIX standard, but setopt
	      is not.

       shift [ -p ] [ n ] [ name ... ]
	      The  positional  parameters  \${n+1}  ...	are  renamed to \${1} ..., where n is an arithmetic expression that defaults to 1.
	      If any names are given then the arrays with these names are shifted instead of the positional parameters.

	      If the option -p is given arguments are instead removed (popped) from the end rather than the start of the array.

       source file [ arg ... ]
	      Same as '.', except that the current directory is always searched and is always searched first, before directories in \${path}.

       stat   See the section 'The zsh/stat Module' in zshmodules(1).

       suspend [ -f ]
	      Suspend the execution of the shell (send it a SIGTSTP) until it receives a SIGCONT.  Unless the -f option is given, this
	      will refuse to  suspend  a  login shell.

       test [ arg ... ] [ [ arg ... ] ]
	      Like the system version of test.	Added for compatibility; use conditional expressions instead (see the section 'Conditional
	      Expressions').  The main dif‐ ferences between the conditional expression syntax and the test and [ builtins are:  these
	      commands are not handled syntactically, so for example an empty variable	expansion  may	cause  an argument to be omitted;
	      syntax errors cause status 2 to be returned instead of a shell error; and arithmetic operators expect integer arguments rather
	      than arithmetic expressions.

	      The command attempts to implement POSIX and its extensions where these are specified.  Unfortunately there are intrinsic
	      ambiguities  in  the  syntax;  in particular  there  is no  distinction between test operators and strings that
	      resemble them.  The standard attempts to resolve these for small numbers of arguments (up to four); for five or more
	      arguments compatibility cannot be relied on.  Users are urged wherever possible to use the '[[' test syntax which does not
	      have these ambiguities.

       times  Print the accumulated user and system times for the shell and for processes run from the shell.

       trap [ arg ] [ sig ... ]
	      arg  is  a series of commands (usually quoted to protect it from immediate evaluation by the shell) to be read and executed when
	      the shell receives any of the signals specified by one or more sig args.  Each sig can be given as a number, or as the name
	      of a signal either with or without  the  string  SIG  in front (e.g. 1, HUP, and SIGHUP are all the same signal).

	      If arg is '-', then the specified signals are reset to their defaults, or, if no sig args are present, all traps are reset.

	      If arg is an empty string, then the specified signals are ignored by the shell (and by the commands it invokes).

	      If  arg is omitted but one or more sig args are provided (i.e.  the first argument is a valid signal number or name),
	      the effect is the same as if arg had been specified as '-'.

	      The trap command with no arguments prints a list of commands associated with each signal.

	      If sig is ZERR then arg will be executed after each command with a nonzero exit status.  ERR is an alias for ZERR on
	      systems that have  no  SIGERR  signal (this is the usual case).

	      If sig is DEBUG then arg will be executed before each command if the option DEBUG_BEFORE_CMD is set (as it is by default),
	      else after each command.	Here, a 'command' is what is described as a 'sublist' in the shell grammar, see the section SIMPLE
	      COMMANDS & PIPELINES in zshmisc(1).  If  DEBUG_BEFORE_CMD  is set  various additional features are available.  First, it is
	      possible to skip the next command by setting the option ERR_EXIT; see the description of the ERR_EXIT option in zshoptions(1).
	      Also, the shell parameter ZSH_DEBUG_CMD is set to the string corresponding to the command to be executed following  the trap.
	      Note that this string is reconstructed from the internal format and may not be formatted the same way as the original text.
	      The parameter is unset after the trap is executed.

	      If sig is 0 or EXIT and the trap statement is executed inside the body of a function, then the command arg is executed after
	      the function completes.	The value  of  \${?}  at  the  start of execution is the exit status of the shell or the return
	      status of the function exiting.  If sig is 0 or EXIT and the trap statement is not executed inside the body of a function,
	      then the command arg is executed when the shell terminates; the trap runs before any zshexit hook functions.

	      ZERR, DEBUG, and EXIT traps are not executed inside other traps.  ZERR and DEBUG traps are kept within subshells, while other
	      traps are reset.

	      Note  that  traps  defined  with the trap builtin are slightly different from those defined as 'TRAPNAL () { ... }', as the
	      latter have their own function environment (line numbers, local variables, etc.) while the former use the environment
	      of the command in which they were called.  For example,

		     trap 'print \${LINENO}' DEBUG

	      will print the line number of a command executed after it has
	      run, while

		     TRAPDEBUG() { print \${LINENO}; }

	      will always print the number zero.

	      Alternative signal names are allowed as described under kill above.  Defining a trap under either name causes any
	      trap under an  alternative  name	to  be removed.  However, it is recommended that for consistency users stick exclusively
	      to one name or another.

       true [ arg ... ]
	      Do nothing and return an exit status of 0.

       ttyctl [ -fu ]
	      The  -f  option freezes the tty (i.e. terminal or terminal emulator), and -u unfreezes it.  When the tty is frozen, no
	      changes made to the tty settings by external programs will be honored by the shell, except for changes in the size of
	      the screen; the shell will simply reset the settings to  their previous values  as  soon as each command exits or is suspended.
	      Thus, stty and similar programs have no effect when the tty is frozen.  Freezing the tty does not cause the current state
	      to be remembered: instead, it causes future changes to the state to be blocked.

	      Without options it reports whether the terminal is frozen or not.

	      Note that, regardless of whether the tty is frozen or not, the shell needs to change the settings when the line editor
	      starts, so unfreezing the tty  does not  guarantee settings made on the command line are preserved.  Strings of commands
	      run between editing the command line will see a consistent tty state.  See also the shell variable STTY for a means of
	      initialising the tty before running external commands.

       type [ -wfpamsS ] name ...
	      Equivalent to whence -v.

       ulimit [ -HSa ] [ { -bcdfiklmnpqrsTtvwx | -N resource } [ limit ] ... ]
	      Set or display resource limits of the shell and the processes started by the shell.  The value of limit can be a number in
	      the unit specified below or one of the values 'unlimited', which removes the limit on the resource, or 'hard', which uses
	      the current value of the hard limit on the resource.

	      By  default,  only soft limits are manipulated. If the -H flag is given use hard limits instead of soft limits.	If the -S flag
	      is given together with the -H flag set both hard and soft limits.

	      If no options are used, the file size limit (-f) is assumed.

	      If limit is omitted the current value of the specified resources are printed.  When more than one resource value is printed,
	      the limit name  and  unit  is printed before each value.

	      When  looping  over  multiple  resources, the shell will abort immediately if it detects a badly formed argument.  However,
	      if it fails to set a limit for some other reason it will continue trying to set the remaining limits.

	      Not all the following resources are supported on all systems.
	      Running ulimit -a will show which are supported.

	      -a     Lists all of the current resource limits.	
		  -b     Socket buffer size in bytes (N.B. not kilobytes) 
		  -c     512-byte blocks on the size of core dumps.  
		  -d	Kilobytes on the size of the data segment.  
		  -f	512-byte blocks on the size of files written.  
		  -i	The number of pending signals.
	      -k     The number of kqueues allocated.  
		  -l     Kilobytes on the size of locked-in memory.	
		  -m     Kilobytes on the size of physical memory.	
		  -n     open file descriptors.
	      -p     The number of pseudo-terminals.  
		  -q     Bytes in POSIX message queues.  
		  -r     Maximum real time priority.  On some systems where this is not available, such as NetBSD, this has the same effect 
		         as -T for compatibility with sh.
	      -s     Kilobytes on the size of the stack.  
		  -T	 The number of simultaneous threads available to the user.  
		  -t     CPU seconds to be used.  
		  -u	 The number of processes available to the user.  
		  -v	 Kilobytes on the size of virtual memory.  On some systems this refers to the limit called 'address space'.
	      -w     Kilobytes on the size of swapped out memory.  
		  -x	  The number of locks on files.

	      A resource may also be specified by integer in the form '-N resource', where resource corresponds to the integer defined
	      for the resource by the operating system.  This may be used to set the limits for resources known to the shell which do
	      not correspond to option letters.  Such limits will be shown by num‐ ber in the output of 'ulimit -a'.

	      The number may alternatively be out of the range of limits compiled into the shell.	The shell will try to read or write
	      the limit anyway, and will report an error if this fails.

       umask [ -S ] [ mask ]
	      The  umask  is  set  to  mask.  mask can be either an octal number or a symbolic value as described in chmod(1).  If mask
	      is omitted, the current value is printed.  The -S option causes the mask to be printed as a symbolic value.  Otherwise, the mask
	      is printed as an octal number.  Note that in the	symbolic form the permissions you specify are those which are to be allowed
	      (not denied) to the users specified.

       unalias [ -ams ] name ...
	      Removes  aliases.   This	command  works	the  same  as  unhash -a, except that the -a option removes all regular or global
	      aliases, or with -s all suffix aliases: in this case no name arguments may appear.  The options -m (remove by pattern)
	      and -s without -a (remove listed suffix  aliases)  behave as  for unhash -a.  Note that the meaning of -a is different
	      between unalias and unhash.

       unfunction
	      Same as unhash -f.

       unhash [ -adfms ] name ...
	      Remove  the  element  named name from an internal hash table.  The default is remove elements from the command hash table.
	      The -a option causes unhash to remove regular or global aliases; note when removing a global aliases that the argument must be
	      quoted to prevent it  from  being  expanded  before  being passed  to  the  command.   The  -s option causes unhash to
	      remove suffix aliases.  The -f option causes unhash to remove shell functions.	The -d options causes unhash to remove
	      named directories.  If the -m flag is given the arguments are taken as patterns (should be quoted) and all elements of the
	      corre‐ sponding hash table with matching names will be removed.

       unlimit [ -hs ] resource ...
	      The  resource limit for each resource is set to the hard limit.  If the -h flag is given and the shell has appropriate
	      privileges, the hard resource limit for each resource is removed.  The resources of the shell process are only changed if the -s
	      flag is given.

	      The unlimit command is not made available by default when the shell starts in a mode emulating another shell.  It can be made
	      available with  the  command 'zmodload -F zsh/rlimits b:unlimit'.

       unset [ -fmv ] name ...
	      Each  named  parameter  is unset.  Local parameters remain local even if unset; they appear unset within scope, but the
	      previous value will still reappear when the scope ends.

	      Individual elements of associative array parameters may be unset by using subscript syntax on name, which should be quoted
	      (or the entire command prefixed with noglob) to protect the subscript from filename generation.

	      If  the -m flag is specified the arguments are taken as patterns (should be quoted) and all parameters with matching names
	      are unset.  Note that this can‐ not be used when unsetting associative array elements, as the subscript will be treated
	      as part of the pattern.

	      The -v flag specifies that name refers to parameters. This is the default behaviour.

	      unset -f is equivalent to unfunction.

       unsetopt [ {+|-}options | {+|-}o option_name ] [ name ... ]
	      Unset the options for the shell.	All options specified either with flags or by name are unset.	If no arguments are supplied,
	      the names  of  all  options currently  unset are printed.  If the -m flag is given the arguments are taken as patterns
	      (which should be quoted to preserve them from being interpreted as glob patterns), and all options with names matching these
	      patterns are unset.

       vared  See the section 'Zle Builtins' in zshzle(1).

       wait [ job ... ]
	      Wait for the specified jobs or processes.  If job is not given then all currently active child processes are waited for.
	      Each job can  be	either	a  job specification or the process ID of a job in the job table.  The exit status from this command
	      is that of the job waited for.

	      It  is  possible	to  wait  for recent processes (specified by process ID, not by job) that were running in the background even
	      if the process has exited.  Typically the process ID will be recorded by capturing the value of the variable \$! immediately
	      after the process has been started.  There is a  limit  on the number  of  process  IDs	remembered  by	the  shell; this
	      is given by the value of the system configuration parameter CHILD_MAX.  When this limit is reached, older process IDs are
	      discarded, least recently started processes first.

	      Note there is no protection against the process ID wrapping, i.e. if the wait is not executed soon enough there is a chance
	      the process waited for is  the wrong  one.   A  conflict implies both process IDs have been generated by the shell, as other
	      processes are not recorded, and that the user is potentially interested in both, so this problem is intrinsic to process IDs.

       whence [ -vcwfpamsS ] [ -x num ] name ...
	      For each name, indicate how it would be interpreted if used as a command name.

	      whence is most useful when name is only the last path component of a command, i.e. does not include a '/'; in particular,
	      pattern matching	only  succeeds if just the non-directory component of the command is passed.

	      -v     Produce a more verbose report.

	      -c     Print the results in a csh-like format.  This takes precedence over -v.

	      -w     For  each	name, print 'name: word' where word is one of alias, builtin, command, function, hashed, reserved or none,
	             according as name corresponds to an alias, a built-in command, an external command, a shell function, a command defined 
				 with the hash builtin, a reserved word, or is not  recog‐ nised.  This takes precedence over -v and -c.

	      -f     Causes the contents of a shell function to be displayed, which would otherwise not happen unless the -c flag were used.

	      -p     Do a path search for name even if it is an alias, reserved word, shell function or builtin.

	      -a     Do a search for all occurrences of name throughout the command path.  Normally only the first occurrence is printed.

	      -m     The  arguments are taken as patterns (pattern characters should be quoted), and the information is displayed for each command 
		         matching one of these patterns.

	      -s     If a pathname contains symlinks, print the symlink-free pathname as well.

	      -S     As -s, but if the pathname had to be resolved by following multiple symlinks, the intermediate steps are printed, too.
	             The  symlink  resolved  at each step might be anywhere in the path.

	      -x num Expand tabs when outputting shell functions using the -c option.  This has the same effect as the -x option to the
	      functions builtin.

       where [ -wpmsS ] [ -x num ] name ...
	      Equivalent to whence -ca.

       which [ -wpamsS ] [ -x num ] name ...
	      Equivalent to whence -c.

       zcompile [ -U ] [ -z | -k ] [ -R | -M ] file [ name ... ] zcompile -ca [ -m ] [ -R | -M ] file [ name ... ] zcompile -t file [ name ... ]
	      This  builtin command can be used to compile functions or scripts, storing the compiled form in a file, and to examine
	      files containing the compiled form.  This allows faster autoloading of functions and sourcing of scripts by avoiding
	      parsing of the text when the files are read.

	      The first form (without the -c, -a or -t options) creates a compiled file.  If only the file argument is given, the output
	      file has	the  name  'file.zwc' and  will  be  placed  in  the same directory as the file.  The shell will load the compiled
	      file instead of the normal function file when the function is autoloaded; see the section 'Autoloading Functions' in zshmisc(1)
	      for a description of how autoloaded functions are searched.  The extension  .zwc  stands for 'zsh word code'.

	      If  there is at least one name argument, all the named files are compiled into the output file given as the first argument.
	      If file does not end in .zwc, this extension is automatically appended.  Files containing multiple compiled functions are
	      called 'digest' files, and are intended to be used as elements of the FPATH/fpath special array.

	      The  second  form,  with the -c or -a options, writes the compiled definitions for all the named functions into file.
	      For -c, the names must be functions currently defined in the shell, not those marked for autoloading.	Undefined functions
	      that are marked for autoloading may be  written  by  using the  -a option,  in  which  case the fpath is searched and
	      the contents of the definition files for those functions, if found, are compiled into file.  If both -c and -a are given,
	      names of both defined functions and functions marked for autoloading may be given.  In either case, the functions in
	      files written  with the -c or -a option will be autoloaded as if the KSH_AUTOLOAD option were unset.

	      The  reason  for	handling  loaded and not-yet-loaded functions with different options is that some definition files for
	      autoloading define multiple func‐ tions, including the function with the same name as the file, and, at the end, call
	      that function.  In such cases the output of  'zcompile  -c' does  not include  the additional functions defined in the
	      file, and any other initialization code in the file is lost.  Using 'zcompile -a' captures all this extra information.

	      If the -m option is combined with -c or -a, the names are used as patterns and all functions whose names match one of
	      these patterns will be  written.	If no name is given, the definitions of all functions currently defined or marked as
	      autoloaded will be written.

	      Note  the  second form cannot be used for compiling functions that include redirections as part of the definition rather
	      than within the body of the func‐ tion; for example

		     fn1() { { ... } >~/logfile }

	      can be compiled but

		     fn1() { ... } >~/logfile

	      cannot.  It is possible to use the first form of zcompile to compile autoloadable functions that include the full function
	      definition instead of just  the body of the function.

	      The  third  form, with the -t option, examines an existing compiled file.  Without further arguments, the names of the
	      original files compiled into it are listed.  The first line of output shows the version of the shell which compiled the file
	      and how the file will be used (i.e. by reading it directly or  by mapping  it  into memory).  With arguments, nothing is
	      output and the return status is set to zero if definitions for all names were found in the compiled file, and non-zero
	      if the definition for at least one name was not found.

	      Other options:

	      -U     Aliases are not expanded when compiling the named files.

	      -R     When the compiled file is read, its contents are copied
	      into the shell's memory, rather than memory-mapped (see -M).  This happens automatically on systems that do not support memory mapping.

		  When compiling scripts instead of autoloadable functions, it is often desirable to use this option; otherwise
		  the whole file, including the code to define functions which have already been defined, will remain mapped,
		  consequently wasting memory.

	      -M     The compiled file is mapped into the shell's memory when read. This is done in such a way that multiple instances
	             of the shell running on the  same host will share this mapped file.	If neither -R nor -M is given, the zcompile builtin 
				 decides what to do based on the size of the compiled file.

	      -k -z	These  options are used when the compiled file contains functions which are to be autoloaded. If -z is given,
	      the function will be autoloaded as if the KSH_AUTOLOAD option is not set, even if it is set at
		     the time the compiled file is read, while if the -k is given, the function will be  loaded as  if  KSH_AUTOLOAD
		     is  set.  These options also take precedence over any -k or -z options specified to the autoload builtin. If
		     neither of these options is given, the function will be loaded as determined by the setting of the KSH_AUTOLOAD
		     option at the time the compiled file is read.

		     These options may also appear as many times as necessary between the listed names to specify the loading style
		     of all following  functions,  up  to the next -k or -z.

		     The created file always contains two versions of the compiled format, one for big-endian machines and one for
		     small-endian machines.  The upshot of this is that the compiled file is machine independent and if it is read
		     or mapped, only one half of the file is actually used (and mapped).

       zformat
	      See the section 'The zsh/zutil Module' in zshmodules(1).

       zftp   See the section 'The zsh/zftp Module' in zshmodules(1).

       zle    See the section 'Zle Builtins' in zshzle(1).

       zmodload [ -dL ] [ -s ] [ ... ] zmodload -F [ -alLme -P param ] module
       [ [+-]feature ... ] zmodload -e [ -A ] [ ... ] zmodload [ -a [ -bcpf
       [ -I ] ] ] [ -iL ] ...  zmodload -u [ -abcdpf [ -I ] ] [ -iL ] ...
       zmodload -A [ -L ] [ modalias[=module] ... ] zmodload -R modalias ...
	      Performs operations relating to zsh's loadable modules.  Loading of modules while the shell is running ('dynamical
	      loading') is not available on all oper‐ ating  systems, or  on  all  installations  on a particular operating system,
	      although the zmodload command itself is always available and can be used to manipulate modules built into versions of the
	      shell executable without dynamical loading.

	      Without arguments the names of all currently loaded binary modules are printed.  The -L option causes this list to be
	      in the form of a series of  zmodload commands.  Forms with arguments are:

	      zmodload [ -is ] name ...  zmodload -u [ -i ] name ...
		     In  the  simplest	case,  zmodload  loads a binary module.  The module must be in a file with a name consisting
		     of the specified name followed by a standard suffix, usually '.so' ('.sl' on HPUX).  If the module to be
		     loaded is already loaded the duplicate module is ignored.  If zmodload detects an inconsistency, such as an invalid
		     module name or circular dependency list, the current code block is aborted.  If it is available, the module
		     is loaded if necessary, while if it is not available, non-zero status is silently returned.  The option -i
		     is accepted for compatibility  but  has  no effect.

		     The  named  module  is  searched for in the same way a command is, using \${module_path} instead of \${path}.
		     However, the path search is performed even when the module name contains a '/', which it usually does.
		     There is no way to prevent the path search.

		     If the module supports features (see below), zmodload tries to enable all features when loading a module.
		     If the module  was  successfully  loaded but not all features could be enabled, zmodload returns status 2.

		     If  the  option  -s  is  given,  no  error is printed if the module was not available (though other errors
		     indicating a problem with the module are printed).  The return status indicates if the module was loaded.
		     This is appropriate if the caller considers the module optional.

		     With -u, zmodload unloads modules.  The same name must be given that was given when the module was loaded,
		     but it is not necessary for  the  module to exist in the file system.  The -i option suppresses the error
		     if the module is already unloaded (or was never loaded).

		     Each  module has a boot and a cleanup function.  The module will not be loaded if its boot function fails.
		     Similarly a module can only be unloaded if its cleanup function runs successfully.

	      zmodload -F [ -almLe -P param ] module [ [+-]feature ... ]
		     zmodload -F allows more selective control over the features provided by modules.  With no options apart
		     from -F, the module named module is loaded, if it was not already loaded, and the list of features is set
		     to the required state.  If no features are specified, the module is loaded, if it was not already loaded,
		     but the state of features is unchanged.  Each feature may be preceded by a + to turn the feature on, or - to
		     turn it off; the + is  assumed  if  neither character is present.  Any feature not explicitly mentioned is left
		     in its current state; if the module was not previously loaded this means any such features will remain disabled.
		     The return status is zero if all features were set, 1 if the module failed to load,  and 2  if  some features
		     could not be set (for example, a parameter couldn't be added because there was a different parameter of the
		     same name) but the module was loaded.

		     The standard features are builtins, conditions, parameters and math functions; these are indicated by
		     the prefix 'b:', 'c:' ('C:' for an infix con‐ dition), 'p:' and 'f:', respectively, followed by the name that
		     the corresponding feature would have in the shell.  For example, 'b:strftime' indi‐ cates a builtin named
		     strftime and p:EPOCHSECONDS indicates a parameter named EPOCHSECONDS.  The module may provide other ('abstract')
		     features  of its own as indicated by its documentation; these have no prefix.

		     With  -l or -L, features provided by the module are listed.  With -l alone, a list of features together
		     with their states is shown, one feature per line.  With -L alone, a zmodload -F command that would cause
		     enabled features of the module to be turned on is shown.  With -lL, a zmodload -F com‐ mand  that	would cause all
		     the features to be set to their current state is shown.  If one of these combinations is given with the option
		     -P param then the parameter param is set to an array of features, either features together with their state or
		     (if -L alone is given) enabled features.

		     With the option -L the module name may be omitted; then a list of all enabled features for all modules
		     providing features is printed in the form of zmodload -F commands.  If -l is also given, the state of both
		     enabled and disabled features is output in that form.

		     A set of features may be provided together with -l or -L and a module name; in that case only the state of
		     those features is considered.  Each fea‐ ture may be preceded by + or - but the character has no effect.  If no
		     set of features is provided, all features are considered.

		     With -e, the command first tests that the module is loaded; if it is not, status 1 is returned.  If the
		     module is	loaded,  the  list  of	features given	as an  argument  is examined.  Any feature given with no
		     prefix is simply tested to see if the module provides it; any feature given with a prefix + or - is tested to see
		     if is provided and in the given state.  If the tests on all features in the list succeed, status 0 is returned,
		     else status 1.

		     With -m, each entry in the given list of features is taken as a pattern to be matched against the list of
		     features provided by the module.  An ini‐ tial + or - must be given explicitly.	This may not be combined with
		     the -a option as autoloads must be specified explicitly.

		     With -a, the given list of features is marked for autoload from the specified module, which may not yet be loaded.
		     An optional + may appear before the  feature  name.  If  the  feature  is prefixed with -, any existing
		     autoload is removed.  The options -l and -L may be used to list autoloads.  Autoloading is specific to
		     individual features; when the module is loaded only the requested feature is enabled.  Autoload requests  are
		     preserved if the module is subsequently unloaded until an explicit 'zmodload -Fa module -feature' is issued.
		     It is not an error to request an autoload for a feature of a module that is already loaded.

		     When the module is loaded each autoload is checked against the features actually provided by the  module;
		     if  the  feature  is  not	provided  the autoload request is deleted.  A warning message is output; if the
		     module is being loaded to provide a different feature, and that autoload is suc‐ cessful, there is no effect
		     on the status of the current command.  If the module is already loaded at the time when zmodload -Fa is run,
		     an  error message is printed and status 1 returned.

		     zmodload  -Fa  can  be  used with the -l, -L, -e and -P options for listing and testing the existence of
		     autoloadable features.  In this case -l is ignored if -L is specified.  zmodload -FaL with no module name
		     lists autoloads for all modules.

		     Note that only standard features as described above can be autoloaded; other features require the module
		     to be loaded before enabling.

	      zmodload -d [ -L ] [ name ] zmodload -d name dep ...
	      zmodload -ud name [ dep ... ]
		     The -d option can be used to specify module dependencies.  The modules named in the second and subsequent arguments
		     will be loaded before the	mod‐ ule named in the first argument.

		     With -d and one argument, all dependencies for that module are listed.  With -d and no arguments, all module
		     dependencies are listed.  This listing is by default in a Makefile-like format.  The -L option changes this
		     format to a list of zmodload -d commands.

		     If -d and -u are both used, dependencies are removed.  If only one argument is given, all dependencies for
		     that module are removed.

	      zmodload -ab [ -L ] zmodload -ab [ -i ] name [ builtin ... ]
	      zmodload -ub [ -i ] builtin ...
		     The -ab option defines autoloaded builtins.  It defines the specified builtins.  When any of those builtins is
		     called, the module specified in  the first argument is loaded and all its features are enabled (for
		     selective control of features use 'zmodload -F -a' as described above).  If only the name is given, one
		     builtin is defined, with the same name as the module.  -i suppresses the error if the builtin is already defined
		     or  autoloaded, but not if another builtin of the same name is already defined.

		     With  -ab	and  no  arguments, all autoloaded builtins are listed, with the module name (if different) shown
		     in parentheses after the builtin name.  The -L option changes this format to a list of zmodload -a commands.

		     If -b is used together with the -u option, it removes builtins previously defined with -ab.  This is only
		     possible  if  the	builtin  is  not  yet loaded.  -i suppresses the error if the builtin is already removed
		     (or never existed).

		     Autoload requests are retained if the module is subsequently unloaded until an explicit 'zmodload -ub
		     builtin' is issued.

	      zmodload -ac [ -IL ] zmodload -ac [ -iI ] name [ cond ... ]
	      zmodload -uc [ -iI ] cond ...
		     The  -ac option is used to define autoloaded condition codes. The cond strings give the names of the conditions
		     defined by the module. The optional -I option is used to define infix condition names. Without this option
		     prefix condition names are defined.

		     If given no condition names, all defined names are listed (as a series of zmodload commands if the -L
		     option is given).

		     The -uc option removes definitions for autoloaded conditions.

	      zmodload -ap [ -L ] zmodload -ap [ -i ] name [ parameter ... ]
	      zmodload -up [ -i ] parameter ...
		     The -p option is like the -b and -c options, but makes zmodload work on autoloaded parameters instead.

	      zmodload -af [ -L ] zmodload -af [ -i ] name [ function ... ]
	      zmodload -uf [ -i ] function ...
		     The -f option is like the -b, -p, and -c options, but makes zmodload work on autoloaded math functions instead.

	      zmodload -a [ -L ] zmodload -a [ -i ] name [ builtin ... ]
	      zmodload -ua [ -i ] builtin ...
		     Equivalent to -ab and -ub.

	      zmodload -e [ -A ] [ string ... ]
		     The -e option without arguments lists all loaded modules; if the -A option is also given, module aliases
		     corresponding to loaded modules  are  also shown.  If arguments are provided, nothing is printed; the
		     return status is set to zero if all strings given as arguments are names of loaded mod‐ ules and to one if
		     at least on string is not the name of a loaded module.  This can be used to test for the availability of things
		     implemented  by modules.  In this case, any aliases are automatically resolved and the -A flag is not used.

	      zmodload -A [ -L ] [ modalias[=module] ... ]
		     For  each	argument,  if  both modalias and module are given, define modalias to be an alias for the module
		     module.  If the module modalias is ever subsequently requested, either via a call to zmodload or implicitly,
		     the shell will attempt to load module instead.  If module is not  given,  show the  definition  of  modalias.
		     If no arguments are given, list all defined module aliases.  When listing, if the -L flag was also given,
		     list the definition as a zmodload command to recreate
		     the alias.

		     The existence of aliases for modules is completely independent of whether the name resolved is actually
		     loaded as a module: while the alias exists, loading and unloading the module under any alias has exactly
		     the same effect as using the resolved name, and does not affect the connection between the alias and the
		     resolved name which can be removed either by zmodload -R or by redefining the alias.  Chains of aliases	(i.e.
		     where  the  first resolved  name  is  itself  an  alias) are valid so long as these are not circular.  As the
		     aliases take the same format as module names, they may include path separators:  in this case, there is no
		     requirement for any part of the path named to exist as the alias will be resolved  first.   For example,
		     'any/old/alias' is always a valid alias.

		     Dependencies  added  to  aliased modules are actually added to the resolved module; these remain if the alias
		     is removed.  It is valid to create an alias whose name is one of the standard shell modules and which
		     resolves to a different module.  However, if a module has dependencies, it will not be possible to use the
		     module name as an alias as the module will already be marked as a loadable module in its own right.

		     Apart  from the above, aliases can be used in the zmodload command anywhere module names are required.
		     However, aliases will not be shown in lists of loaded modules with a bare 'zmodload'.

	      zmodload -R modalias ...
		     For each modalias argument that was previously defined as a module alias via zmodload -A, delete the alias.
		     If any was not defined,  an  error  is caused and the remainder of the line is ignored.

	      Note  that  zsh  makes  no distinction between modules that were linked into the shell and modules that are loaded dynamically. In
	      both cases this builtin command has to be used to make available the builtins and other things defined by modules (unless the
	      module is autoloaded on these definitions). This	is true even for systems that don't support dynamic loading of modules.

       zparseopts
	      See the section 'The zsh/zutil Module' in zshmodules(1).

       zprof  See the section 'The zsh/zprof Module' in zshmodules(1).

       zpty   See the section 'The zsh/zpty Module' in zshmodules(1).

       zregexparse
	      See the section 'The zsh/zutil Module' in zshmodules(1).

       zsocket
	      See the section 'The zsh/net/socket Module' in zshmodules(1).

       zstyle See the section 'The zsh/zutil Module' in zshmodules(1).

       ztcp   See the section 'The zsh/net/tcp Module' in zshmodules(1).

${E_MAGENTA_FG}VI Keys${E_RESET}
===================
Key Action                                                  Followed by
-----------------------------------------------------------------------
a enter insertion mode after current character              text, ESC
b back word
c change command                                            cursor motion command
d delete command                                            cursor motion command
e end of word
f find character after cursor in current line               character to find
h move left one character
i enter insertion mode before current character             text, ESC
j move down one line
k move up one line
l move right one character
o open line below and enter insertion mode                  text, ESC
p put buffer after cursor
r replace single character at cursor                        replacement character expected
s substitute single character with new text                 text, ESC
u undo
w move foreward one word
x delete single character
y yank command                                              cursor motion command
z position current line                                     CR = top; "." = center; "-"=bottom
A enter insertion mode after end of line                    text, ESC
B move back one Word
C change to end of line                                     text, ESC
D delete to end of line
E move to end of Word
F backwards version of "f"                                  character to find
G goto line number prefixed, or goto end if none
H home cursor - goto first line on screen
I insertion before first non-whitespace character           text, ESC
J join current line with next line
L goto last line on screen
M goto middle line on screen
O open line above and enter insertion mode                  text, ESC
P put buffer before cursor
Q leave visual mode (go into "ex" mode)
R replace through end of current line,then insert           text, ESC
S substitute line - delete line, insert                     text, ESC
W forward Word
X delete backwards single character
0 move to column zero
1-9 any numeric precursor to other command                  command
  (SPACE) move right one character
\$ move to end of line
% match nearest [],(),{} 
^ move to first non-whitespace character of line
( move to previous sentence
) move to next sentence
| move to column zero
- move to first non-whitespace of previous line
_ similar to "^" but uses numeric prefix oddly
+ move to first non-whitespace of next line
[ move to previous "{...}" section                         "["
] move to next "{...}" section                             "]"
{ move to previous blank-line separated section            "{"
} move to next blank-line separated section                "}"
' move to marked line, memorized column                    character tag (a-z)
: ex-submode                                               ex command
" access numbered buffer; load or access lettered buffer   1-9,a-z
~ reverse case of current character and cursor forward
. repeat last text-changing command
< unindent command                                         cursor motion command
> indent command                                           cursor motion command

${E_MAGENTA_FG}SNAP Commands${E_RESET}
sudo snap find    : To list the available packages
sudo snap install <package name>   : To install a package
sudo snap list   : To view all the installed snap packages
sudo snap changes   : To view a list of logged actions
sudo snap refresh <package name>   : To upgrade a package to its latest available version
sudo snap remove   : To uninstall a package

${E_MAGENTA_FG}SET Commands${E_RESET}
'set' single char options
-0 CORRECT
-1 PRINT_EXIT_VALUE
-2 NO_BAD_PATTERN
-3 NO_NOMATCH
-4 GLOB_DOTS
-5 NOTIFY
-6 BG_NICE
-7 IGNORE_EOF
-8 MARK_DIRS
-9 AUTO_LIST
-B NO_BEEP
-C NO_CLOBBER
-D PUSHD_TO_HOME
-E PUSHD_SILENT
-F NO_GLOB
-G NULL_GLOB
-H RM_STAR_SILENT
-I IGNORE_BRACES
-J AUTO_CD
-K NO_BANG_HIST
-L SUN_KEYBOARD_HACK
-M SINGLE_LINE_ZLE
-N AUTO_PUSHD
-O CORRECT_ALL
-P RC_EXPAND_PARAM
-Q PATH_DIRS
-R LONG_LIST_JOBS
-S REC_EXACT
-T CDABLE_VARS
-U MAIL_WARNING
-V NO_PROMPT_CR
-W AUTO_RESUME
-X LIST_TYPES
-Y MENU_COMPLETE
-Z ZLE
-a ALL_EXPORT
-e ERR_EXIT
-f NO_RCS
-g HIST_IGNORE_SPACE
-h HIST_IGNORE_DUPS
-i INTERACTIVE
-k INTERACTIVE_COMMENTS
-l LOGIN
-m MONITOR
-n NO_EXEC
-p PRIVILEGED
-r RESTRICTED
-s SHIN_STDIN
-t SINGLE_COMMAND
-u NO_UNSET
-v VERBOSE
-w CHASE_LINKS
-x XTRACE
-y SH_WORD_SPLIT

# Sh/ksh emulation set
-C NO_CLOBBER
-T TRAPS_ASYNC
-X MARK_DIRS
-a ALL_EXPORT
-b NOTIFY
-e ERR_EXIT
-f NO_GLOB
-i INTERACTIVE
-l LOGIN
-m MONITOR
-n NO_EXEC
-p PRIVILEGED
-r RESTRICTED
-s SHIN_STDIN
-t SINGLE_COMMAND
-u NO_UNSET
-v VERBOSE
-x XTRACE

#16.4.3 Also note
-A Used by set for setting arrays
-b Used on the command line to specify end of option processing
-c Used on the command line to specify a single command
-m Used by setopt for pattern-matching option setting
-o Used in all places to allow use of long option names
-s Used by set to sort positional parameters
tip_zsh_EOF_2
) | mypager
