#!/usr/bin/env zsh
 
# Declarations
typeset -A _APP
typeset -a _APP_DIRS
typeset -a _LOOP_LIST
typeset -a _RAWLIST
typeset -aU _LOCAL_LIST
typeset -a _GNOME_EXT

# Imports
_LIB_DIR=${ZSH_LIB_DIR:=/usr/local/lib}
source ${_LIB_DIR}/LIB_INIT.zsh
source ${_LIB_DIR}/LIST.zsh
source ${_LIB_DIR}/LIB_DEPS.zsh

# Constants
_HOME=${HOME}
_GNOME_EXT=(/usr/share/gnome-shell/extensions ${_HOME}/.local/share/gnome-shell/extensions)
_CFGDIRS=(
${_HOME} \
/etc \
/opt \
/usr/share/applications \
/var/lib/snapd/desktop/applications\
)

# Declarations
typeset -a DIR_MATCHES=()
typeset -aU FN_MATCHES=()
typeset -a LOCAL_LIST=()

# Functions
action_do () {
	local -a MARKED=(${@})
	local M
	local APP
	local ARGS

	APP=/usr/bin/vim
	ARGS=$(echo "${APP} $(list_quote_marked_elements ${MARKED})")
	eval "sudo ${ARGS}"
	[[ ${?} -ne 0 ]] && msg_box -p -PK "<B><I>${0}: ${APP} returned an error<N>"

	for M in ${MARKED};do
		[[ ${M} -eq 0 ]] && continue
		MARKED[${M}]=0
		list_set_selected ${M} ${_STALE_ROW}
	done
}

action_warn () {
	local MARKED=(${@})
	local CNT=$(list_get_selected_count ${MARKED})
	local M
	local INFO_MSG
	
	[[ ${_SELECT_ALL} == 'true' ]] && INFO_MSG="|(<w><I>current page only<N>)" || INFO_MSG=''
	msg_box -H1 -p -PP "<w><I>Please respond<N>|<Z>|$(str_pluralize item $CNT true) queued for editing${INFO_MSG}"
	if [[ ${_MSG_KEY} == 'n' ]];then
		for M in ${MARKED};do
			list_clear_selected ${M}
		done
	fi
}

item_decorate () {
	local NDX=$1

	case ${_LIST_SELECTED[${NDX}]} in
		2) echo -n "${E_STRIKE}${E_RED_FG}${_LIST[${NDX}]}${E_RESET} ${E_ITALIC}viewed${E_RESET}";;
		*)	tput el;echo -n ${_LIST[${NDX}]};;
	esac
}

# Execution
[[ ${#} -eq 0 ]] && exit_leave $(err_msg_exit "Missing argument:<SEARCHTERM>") || SEARCHTERM=${1}

for L in ${_CFGDIRS};do
	DIR_MATCHES+=("${(f)$(eval "sudo find ${L} -type d -name '*${SEARCHTERM}*'" 2>/dev/null)}")
	FN_MATCHES+=("${(f)$(eval "sudo find ${L} -type f -name '*${SEARCHTERM}*'" 2>/dev/null)}")
done

for L in ${DIR_MATCHES};do
	FN_MATCHES+=("${(f)$(eval "sudo find ${L} -maxdepth 1 -type f" 2>/dev/null)}")
done

for L in ${(o)FN_MATCHES};do
	grep -qw ${SEARCHTERM} <<<${L}
	[[ ${?} -ne 0 ]] && continue
	[[ ! $(file -b ${L}) =~ 'text' ]] && continue
	[[ ${L} =~ 'bak' ]] && continue
	[[ ${L} =~ 'cache' ]] && continue
	_LOCAL_LIST+=${L}
done

if ! arr_is_populated "${_LOCAL_LIST}";then
	exit_leave $(msg_exit W "No editable cfg file(s) found for:${SEARCHTERM}")
fi

[[ ${_DEBUG} -gt 0 ]] && dbg "${0}:${LINENO} _LOCAL_LIST:${#_LOCAL_LIST} ${=_LOCAL_LIST[1,20]} ...truncated"

# Set headings
list_set_header 'printf "Found:${WHITE_FG}%-d${RESET} configuration $(str_pluralize file ${#_LIST}) for:${WHITE_FG}%s${RESET}  ${_PG}" ${#_LIST} ${SEARCHTERM}'
list_add_header_break

# Set line item
list_set_line_item ' 
printf "${BOLD}${WHITE_FG}%4s${RESET}${_MARKER} ${SHADE}${BAR}%s${RESET}\n" ${_LIST_NDX} "$(item_decorate ${_LIST_NDX})"
'
list_set_select_action "edit"
list_set_action_msgs edit config
list_set_reuse_stale true
list_set_searchable true
list_set_restore_pos true

while true;do
	list_select ${_LOCAL_LIST}
	[[ ${?} -eq 0 ]] && break

	MARKED=($(list_get_selected))

	if [[ $(list_get_selected_count) -gt 1 ]];then
		action_warn ${MARKED}
	fi

	if [[ ${_MSG_KEY} == "y" || $(list_get_selected_count) -eq 1 ]];then
		action_do ${MARKED}
	fi
done

exit_leave
