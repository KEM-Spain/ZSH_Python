#!/usr/bin/zsh
 
# Inline ansi
BOLD="\033[1m"
ITALIC="\033[3m"
RESET="\033[m"
REVERSE="\033[7m"
STRIKE="\033[9m"
UNDER="\033[4m"
BLACK_BG="\033[40m"
BLUE_FG="\033[34m"
CYAN_FG="\033[36m"
GREEN_FG="\033[32m"
MAGENTA_FG="\033[35m"
RED_FG="\033[31m"
WHITE_FG="\033[37m"
YELLOW_FG="\033[33m"
WHITE_ON_GREY="\033[0m\033[0;1;37;100m"
RED_ON_GREY="\033[0m\033[0;1;31;100m"

# Imports
[[ -z ${ZSH_LIB_DIR} ]] && _LIB_DIR=/usr/local/lib || _LIB_DIR=${ZSH_LIB_DIR}
source ${_LIB_DIR}/LIB_INIT.zsh
source ${_LIB_DIR}/VALIDATE.zsh
source ${_LIB_DIR}/PATH.zsh
source ${_LIB_DIR}/DATE.zsh
source ${_LIB_DIR}/UTILS.zsh
source ${_LIB_DIR}/SELECT.zsh
source ${_LIB_DIR}/LIST.zsh
source ${_LIB_DIR}/LIB_DEPS.zsh

# Declarations
typeset -A _ALERT_COORDS=()
typeset -A _CONT_COORDS=()
typeset -A _DOWNLOADS=()
typeset -A _CANCELLED=()
typeset -A _FAILED=()
typeset -A _FAV_LIST=()
typeset -A _FIELD_LEN=()
typeset -A _FUTURE=()
typeset -A _INFO_COORDS=()
typeset -A _MSG_DELAY=(SHORT .5 MED 2 LONG 5)
typeset -A _PARTIALS=()
typeset -A _RUMBLE_QTYPES=(l live g general u user c channel)
typeset -A _QUERY_OPTS=()
typeset -A _REJECTS=()
typeset -A _RUMBLE_ROWS=()
typeset -A _SEEN=()
typeset -A _SORT_TABLE=()
typeset -A _STATUS_MSGS=()
typeset -a _ACRONYMS=()
typeset -a _RUMBLE_QRY_OPTS=(l c u g)
typeset -a _RUMBLE_PAGE=()
typeset -aU _LOCAL_LIST=()
typeset -A _ENG_CODES=(youtube Y rumble R)
typeset -A _MENU_TYPES=(1 Custom 2 Rumble 3 YouTube)

# Display Constants
_CONT_COORDS=(X 10 Y $(center -h86) H 10 W 86) # Continuous box coords
_ALERT_COORDS=(X $(( _CONT_COORDS[X] + 5 )) Y $(( _CONT_COORDS[Y] + _CONT_COORDS[W] - 25 ))) # Alert display coords
_INFO_COORDS=(X $((_CONT_COORDS[X] + 4 )) Y $((_CONT_COORDS[Y] + 3 )) W $((_CONT_COORDS[W] - 6 ))) # Info display coords

# Constants
_CFG_DIR=~/.local/share/yts
_DOWNLOAD_DIR=~/Downloads/Torrents/Library/web
_ACTION=download
_TM_ERR_LIMIT=3
_FIELD_LEN[age]=30
_FIELD_LEN[agetime]=40
_FIELD_LEN[author]=26
_FIELD_LEN[title]=80
_JS_SCRIPT="/usr/local/etc/yts.js"
_MAX_FLEN=85
_MAX_HDR=$(( _CONT_COORDS[W] - 15 ))
_MAX_TITLE=74
_MSG_BOX_DISPLAY_AREA=60 # Limit continuous box clearing on Y axis to preserve alert space
_OBJECT="video"
_SORT_DEFAULT=(youtube 1:a rumble 1:a)
_YTS_ACRONYMS=${_CFG_DIR}/yts.acronyms
_YTS_DOWNLOAD_LOG=${_CFG_DIR}/yts.downloads
_YTS_ERROR_LOG=${_CFG_DIR}/yts.err.log
_YTS_FAVORITES=${_CFG_DIR}/yts.favorites
_YTS_FAV_NEW=${_CFG_DIR}/yts.favorites.new
_YTS_UPD_MARKER=${_CFG_DIR}/yts-upd.lastrun
_YTS_URL_LOG=${_CFG_DIR}/yts.url.log
_YT_DBG_LOG=${_CFG_DIR}/yt.dbg.log

# Globals
g_CMDLINE_ARGS=false
g_INDICATOR_FLIP=false
g_LAST_CODE_UPD=?
g_LAST_FAV_TYPE=y
g_LAST_SPEED=0
g_LAST_STYPE=0
g_MASK_NDX=1
g_PID=?
g_PREFER_LIVE=''
g_PROXY_CMD=''
g_WHEN=''
g_YTS_LOG=''

# Functions
acronym_load () {
	local LINE

	# Load acronyms
	if [[ -e ${_YTS_ACRONYMS} ]];then
		while read LINE;do
			_ACRONYMS+=${LINE}
		done < ${_YTS_ACRONYMS}
	fi

	[[ ${#_ACRONYMS} ]] && return 0 || return 1
}

action_do () {
	local AUTHOR=''
	local DEST=''
	local DEST_1=''
	local DEST_2=''
	local DEST_LINE=''
	local DUP_LINE=''
	local DL_CNT=0
	local ETA=''
	local FRAME_PAD=8
	local HDR1_TXT=0
	local HDR2_TXT=0
	local HDRS_OUT=false
	local HDR_LEN=0
	local HRZ_CTR=0
	local INFO_TAG=''
	local INT_KEY=''
	local LAST_MSG=''
	local LINE_COLOR=''
	local LOG_LINE=''
	local MSG=''
	local NDX=0
	local RETRIES=0
	local SPEED=0
	local TITLE=''
	local TM_ERR=0
	local LAST_TM_ERR=0
	local TM_ERRS=0
	local URL=''
	local M

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	for M in ${_MARKED};do
		((DL_CNT++))
		_CANCELLED[${DL_CNT}]=false
		_DOWNLOADS[${DL_CNT}]=false
		_FAILED[${DL_CNT}]=false
		_FUTURE[${DL_CNT}]=false
		AUTHOR=$(get_field author ${M})
		TITLE=$(get_field title ${M})
		URL=$(get_field url ${M})
		RETRIES=0
		HDRS_OUT=false

		logit ${_YTS_URL_LOG} "${AUTHOR}:${TITLE}:${URL}"

		unsetopt localtraps # Initialize CTRL-C trap
		trap job_kill INT

		job_start ${URL}
		msg_box -P"<N>Use key:(<w>k<N>) to <B><r><I>cancel<N> download" -x${_CONT_COORDS[X]} -y${_CONT_COORDS[Y]} -h${_CONT_COORDS[H]} -w${_CONT_COORDS[W]} "Download requested..."
		sleep 3

		while true;do
			((NDX++))

			# Handle job reset
			INT_KEY=''
			read -s -t0.1 -k1 INT_KEY
			if [[ ${INT_KEY} == 'k' || ${INT_KEY} == 'r' ]];then 
				job_reset
				logit ${_YT_DBG_LOG} "${0}: JOB CANCELLED"
				MSG="Cancelling download..."
				msg_box -z -t ${_MSG_DELAY[MED]} -x${_INFO_COORDS[X]} -y${_INFO_COORDS[Y]} "<w>${MSG}<N>"
				_CANCELLED[${M}]=true
				break
			fi

			LOG_LINE=$(tail -1 ${g_YTS_LOG}) # Get last log line
			if grep -Eq '' <<<${LOG_LINE};then # Progress delimited by linefeeds
				LOG_LINE=$(sed "s//\n/g" <<<${LOG_LINE} | tail -1 | str_trim) 2>/dev/null # Convert linefeeds to newlines - get last trimmed
			fi

			if [[ ${HDRS_OUT} == 'false' ]];then 
				if [[ ${LOG_LINE:l} =~ 'sleeping|hlsnative|^\[info\]|already been|100%|error' ]];then # Pre-processing triggers
					if [[ ${LOG_LINE:l} =~ 'already been|100%' ]];then
						DUP_LINE=$(grep -Ei 'already been' ${g_YTS_LOG}) # Capture duplicate msg - whole file grep
						if [[ ${?} -eq 0 ]];then
							logit ${_YT_DBG_LOG} "${0}: ALREADY DOWNLOADED"
							MSG=$(sed -E "s#^(.*/)(.*)( has.*)#\2#" <<<${DUP_LINE})
							msg_box -z -t ${_MSG_DELAY[MED]} -x${_INFO_COORDS[X]} -y${_INFO_COORDS[Y]} "<w>${MSG}<N>|<B>Has already been downloaded<N>"
							_DOWNLOADS[${M}]=true
							break
						fi
					elif [[ ${LOG_LINE:l} =~ 'sleeping|hlsnative|^\[info\]' ]];then # Pre-processing messages
						MSG="Pre-Processing: ${LOG_LINE[1,60]}"
						if [[ ${MSG} != ${LAST_MSG} ]];then
							logit ${_YT_DBG_LOG} "${0}: PRE-PROCESSING"
							msg_box -z -t ${_MSG_DELAY[MED]} -x${_INFO_COORDS[X]} -y${_INFO_COORDS[Y]} "<c>${MSG}<N>"
						fi
						LAST_MSG=${MSG}
						continue
					else
						MSG=$(grep -Ei -m1 'will begin|premieres|upcoming' ${g_YTS_LOG}) # Capture future msgs (technically an error) - whole file grep
						if [[ ${?} -eq 0 ]];then
							logit ${_YT_DBG_LOG} "${0}: FUTURE"
							[[ ! ${MSG} =~ 'minute*|hour*|day*' ]] && g_WHEN='soon' || g_WHEN=$(perl -pe 's/^(.*) in (\d+\s+\w+)(.*)$/\2/g' <<<${MSG})
							MSG="<w>${TITLE[1,65]}<N>|<r><B>Not yet available<N> - Airing time:<w>${g_WHEN}<N>"
							[[ ${MSG} != ${LAST_LOG_LINE} ]] && msg_box -z -t ${_MSG_DELAY[MED]} -z -x ${_INFO_COORDS[X]} -y ${_INFO_COORDS[Y]} -w ${_INFO_COORDS[W]} "${MSG}"
							_FUTURE[${M}]=true
							_DOWNLOADS[${M}]=false
							break
						elif [[ ${LOG_LINE:l} =~ 'error' ]];then # Detect pre-download errors
							MSG=$(grep -Ei -m1 'error' ${g_YTS_LOG}) # Capture msg - whole file grep
							if [[ ${?} -eq 0 ]];then
								msg_box -z -t ${_MSG_DELAY[MED]} -x${_INFO_COORDS[X]} -y${_INFO_COORDS[Y]} "<r>${MSG[1,70]}<N>"
								logit ${_YT_DBG_LOG} "${0}: ERROR"
								logit ${_YTS_ERROR_LOG} "${0}: ${MSG}"
								_FAILED[${M}]=true
								_DOWNLOADS[${M}]=false
								break
							fi
						fi
					fi
				else
					DEST_LINE=$(grep -Ei 'destination' ${g_YTS_LOG}) # Capture destination - whole file grep
					if [[ ${?} -eq 0 ]];then
						logit ${_YT_DBG_LOG} "${0}: HEADER"
						DEST=("${(f)$(sed -e "s#${_DOWNLOAD_DIR}/#${_DOWNLOAD_DIR}|#g" -e 's/ \[.*//g' <<<${DEST_LINE})}") # Strip path
						DEST_1=$(cut -d'|' -f1 <<<${DEST})
						DEST_1=$(cut -d']' -f2- <<<${DEST_1} | sed -e "s/^[[:space:]]/<w>/" -e "s/:/<N>:<m>/")
						HDR1_TXT=$(cut -d'|' -f2 <<<${DEST:r} | sed 's/_/ /g') # Clear space fillers and file extension
						HDR1_TXT="<w>Downloading<N>:<m> <c>$(clean_title ${HDR1_TXT} ${_MAX_HDR})<N>"
						HDR2_TXT="$(str_trim ${DEST_1})<N> - <w>${DL_CNT} <N>of <w>${#_MARKED}<N>${INFO_TAG}"
						HDR_LEN=$(( ${#$(msg_nomarkup ${HDR2_TXT})} ))
						HDR_LEN=$(( HDR_LEN + FRAME_PAD ))
						HRZ_CTR=$(center -h${HDR_LEN}) # Horiz center
						[[ ${HDR_LEN} -gt ${_CONT_COORDS[W]} ]] && _CONT_COORDS[W]=${HDR_LEN} && _CONT_COORDS[Y]=${HRZ_CTR} # Adjust frame width/center
						msg_box -c -C -I -H3 -jl -x${_CONT_COORDS[X]} -y${_CONT_COORDS[Y]} -h${_CONT_COORDS[H]} -w${_CONT_COORDS[W]} ${HDR1_TXT}
						msg_box -C -jl ${HDR2_TXT}
						msg_box -C -jl "<c>$(str_unicode_line $(( _CONT_COORDS[W] - 2 )))<N>" # Divider line
						HDRS_OUT=true
						continue
					fi
				fi
			else # HDRS_OUT == true
				if [[ ${LOG_LINE} =~ 'ETA' ]];then
					SPEED=$(get_speed ${LOG_LINE}) && download_indicator ${SPEED}
					ETA=${LOG_LINE}
					case ${LOG_LINE:l} in
						*100*%) LINE_COLOR='<B><g>';;
						*mib/s*) LINE_COLOR='<w>';;
						*kib/s*) LINE_COLOR='<B><y>';;
					esac
					msg_box -C -jl "${LINE_COLOR}${ETA[1,59]}<N>"
					continue
				elif [[ ${LOG_LINE:l} =~ '100%|fixing mpeg-ts|fixupm3u8|videoremuxer' ]];then # Post-processing
					logit ${_YT_DBG_LOG} "${0}: COMPLETED"
					msg_box -C -jl "<B><g>Download is complete<N>" # Show completed message
					_DOWNLOADS[${M}]=true
					logit ${_YT_DBG_LOG} "${0}: POST-PROCESSING"
					post_process
					log_add ${M}
					break
				else
					MSG=$(grep -Ein 'error' ${g_YTS_LOG} | tail -1) # Capture error and line
					if [[ ${?} -eq 0 ]];then
						TM_ERR=$(cut -d: -f1 <<<${MSG})
						if [[ ${TM_ERR} -ne ${LAST_TM_ERR} ]];then
							((TM_ERRS++))
							msg_box -z -x${_INFO_COORDS[X]} -y${_INFO_COORDS[Y]} "<w>${TM_ERRS}<N>:<r>${MSG[1,70]}<N>"
							logit ${_YT_DBG_LOG} "${0}: TRANSMISSION ERROR ${TM_ERRS} of ${_TM_ERR_LIMIT}"
							logit ${_YTS_ERROR_LOG} "${0}: ERROR:${TM_ERRS}: ${MSG}"
							LAST_TM_ERR=${TM_ERR}
							if [[ ${TM_ERRS} -ge ${_TM_ERR_LIMIT} ]];then
								_FAILED[${M}]=true
								_DOWNLOADS[${M}]=false
								break
							else
								continue
							fi
						fi
					fi
				fi
			fi
			sleep .3 # Log fetch delay
		done
		NDX=0
		log_clear "action_do"
		sleep 1 # Job request delay
	done # List complete

	for M in ${_MARKED};do
		[[ ${_DOWNLOADS[${M}]} == 'true' ]] && list_set_selected ${M} ${_STALE_ROW} || list_set_selected ${M} ${_AVAIL_ROW}
	done

	_MARKED=()
	trap - INT # Downloads are finished; cancel trap
	return 0
}

action_warn () {
	local M
	
	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	msg_box -x$(( _CONT_COORDS[X] )) -H1 -p -PG "<w><I>Please respond<N>|<Z>|${#_MARKED} $(str_pluralize ${_OBJECT} ${#_MARKED}) selected"

	if [[ ${_MSG_KEY} == 'n' ]];then
		for M in ${_MARKED};do
			_MARKED[${M}]=0
			list_set_selected ${M} ${_AVAIL_ROW}
		done
	fi
}

box_center () {
	local TXT=${@} # Text to center
	local BOX=-4 # Compensate for box border
	local BOX_CTR=0
	local BOX_LEFT=${_CONT_COORDS[Y]} # Left coord
	local BOX_WIDTH=${_CONT_COORDS[W]} # Width coord
	local CTR=0
	local REM=0
	local TXT_CTR=0
	local TXT_LEN=$(( ${#TXT} + BOX )) # Text length

	echo $(center -y${BOX} -t${BOX_WIDTH} ${TXT})
}

cfg_init () {
	local CFG_STATE=0
	local -A CFG_MSGS=(1 "Missing configuration directory:${_CFG_DIR}" 2 "Missing favorites file:${_YTS_FAVORITES}")

	[[ -e ${_YT_DBG_LOG} ]] && /bin/rm -f ${_YT_DBG_LOG}

	[[ -d ${_CFG_DIR} ]] && CFG_STATE=0 || CFG_STATE=1
	[[ -f ${_YTS_FAVORITES} ]] && CFG_STATE=0 || CFG_STATE=2

	echo ${CFG_MSGS[${CFG_STATE}]}

	return ${CFG_STATE}
}

clean_title () {
	local TITLE=${1}
	local STR=''
	local -a KEYWORDS=("judge napolitano - " "official" "^the " " show" "have it out with galloway \- " "youtube channel")
	local -A SEEN=()
	local -a UCASE_WORDS=()
	local UCASE_LIMIT=4
	local W U

	logit ${_YT_DBG_LOG} "${0}: TITLE  IN:${TITLE}"

	TITLE=$(recode UTF8..ISO-8859-15 <<<${TITLE}) # Convert UTF-8
	TITLE=$(html2text -width ${_MAX_COLS} -ascii <<<${TITLE}) # Convert any HTML 

	STR=$(sed "s/${_QUERY_OPTS[QKEY]:l}/${_QUERY_OPTS[DKEY]:gs/_/ /}/I" <<<${TITLE})
	STR=$(tr '\n' ' ' <<<${STR}) # Newlines to space
	STR=$(sed -e 's/[ _]\(d\|l\|s\|t\|re\|ve\)[ _]/\o047\1 /Ig' -e 's/[ _][Ww][ _]/ with /g' <<<${STR}) # Fix any contraction gaps
	 
	UCASE_WORDS=("${(f)$(tr -dc '[:alnum:][ \-]' <<<${STR} | grep -E -o -- '\b([[:upper:]]|[0-9])+\b')}") # Allow alpha,digits, and hyphen
	for U in ${UCASE_WORDS};do
		[[ ${U%%[!0-9]*} ]] && UCASE_WORDS=("${(@)UCASE_WORDS:#${U}}") # Dump numbers
	done

	STR=$(perl -pe  's/\o{47}(?![rstv].?\b)//g' <<<${STR}) # Remove any sentence quotes, leave contractions
	STR=$(sed -E -e 's/^[[:blank:]]*//' -e 's/[[:blank:]]*$//' -e 's/(\S)([-])(\S)/\1 \3/g' <<<${STR}) # Trim
	STR=${(C)STR} # Proper case
	STR=$(sed 's/\(\o047\)\([A-Z]\)/\1\L\2/g' <<<${STR}) # Fix proper case anonmaly: UC letter following apostrophe

	for W in ${=STR};do
		W=$(tr -dc '[:alnum:][\047]' <<<${W}) # Strip other than alpha,digits,single quotes, and hyphen
		[[ ${SEEN[${W}]} -eq 1 ]] && continue # Skip seen
		if [[ ${_ACRONYMS[(i)${W:u}]} -le ${#_ACRONYMS} ]];then
			#logit ${_YT_DBG_LOG} "${0}: Found acronym:${W:u}"
			STR=$(sed "s/\b${W}\b/${W:u}/Ig" <<<${STR}) # Preserve acromyns
			SEEN[${W}]=1
		elif [[ -n ${UCASE_WORDS} && ${#UCASE_WORDS} -le ${UCASE_LIMIT} ]];then # Retain orginal uppercased if not excessive
			if [[ ${UCASE_WORDS[(i)${W:u}]} -le ${#UCASE_WORDS} ]];then
				#logit ${_YT_DBG_LOG} "${0}: Found uppercase:${W:u}"
				STR=$(sed "s/\b${W}\b/${W:u}/Ig" <<<${STR}) 
				SEEN[${W}]=1
			fi
		fi
	done

	for W in ${KEYWORDS};do # Scrub keywords
		STR=$(sed "s/${W}//I" <<<${STR})
	done

	TITLE=$(str_word_clip ${STR} ${_MAX_TITLE}) # Limit length at word boundary

	logit ${_YT_DBG_LOG} "${0}: TITLE OUT:${TITLE}"

	echo ${TITLE}
}

dashed_line () {
	local CNT=10
	local LEN=5
	local X=0
	local STR=''

	for ((X=0; X<=CNT; X++));do
		STR+="$(str_unicode_line ${LEN}) "
	done
	
	echo "${STR}"
}

download_indicator () {
	local SPEED=$(cut -d'|' -f1 <<<${1} | cut -d. -f1)
	local STYPE=$(cut -d'|' -f2 <<<${1})
	local L_OBJ="\\u23FA"
	local M_OBJ="\\u25CF"
	local R_OBJ="\\u2B24"
	local -A OBJS=()
	local -A OBJS_1=(1 ${L_OBJ} 2 ${M_OBJ} 3 ${R_OBJ})
	local -A OBJS_2=(1 ${R_OBJ} 2 ${M_OBJ} 3 ${L_OBJ})
	local BORDER_COLOR=''
	local DELAY=.3
	local IND_X=$(( _ALERT_COORDS[X] + 1 ))
	local IND_Y=$(( _ALERT_COORDS[Y] + 7 ))
	local L_SIDE="\\u2770"
	local R_SIDE="\\u2771"
	local MASK=""
	local OBJ_COLOR="${BOLD}${WHITE_FG}" # Default
	local SP_DIR=I

	[[ -z ${SPEED} ]] && SPEED=0
	[[ -z ${g_LAST_SPEED} ]] && g_LAST_SPEED=0

	if [[ ( ${STYPE} == 'M' && ${g_LAST_STYPE} == 'K' ) || ${SPEED} -ge ${g_LAST_SPEED} ]];then 
		SP_DIR=I # Stable or Increasing
	elif [[ ( ${STYPE} == 'K' && ${g_LAST_STYPE} == 'M' ) || ${SPEED} -lt ${g_LAST_SPEED} ]];then 
		SP_DIR=D # Decreasing
	fi

	#logit ${_YT_DBG_LOG} "${0}: SPEED:${SPEED}"

	case ${SPEED} in
		<1-2>) OBJ_COLOR="${BOLD}${RED_FG}";; # YouTube
		<3-4>) OBJ_COLOR="${BOLD}${MAGENTA_FG}";;
		<5-6>) OBJ_COLOR="${BOLD}${CYAN_FG}";;
		<7-10>) OBJ_COLOR="${BOLD}${GREEN_FG}";;
		<11-20>) OBJ_COLOR="${BOLD}${WHITE_FG}";;
		<21-30>) OBJ_COLOR="${BOLD}${CYAN_FG}";;
		<31-40>) OBJ_COLOR="${BOLD}${WHITE_FG}";;
		*) OBJ_COLOR="${BOLD}${GREEN_FG}";;
	esac

	case ${SP_DIR} in
		I) BORDER_COLOR="${BOLD}${GREEN_FG}";;
		D) BORDER_COLOR="${BOLD}${RED_FG}";;
	esac

	OBJS=(${(kv)OBJS_1}) # Init

	if [[ ${g_INDICATOR_FLIP} == 'true' ]];then
		OBJS=(${(kv)OBJS_2})
	fi

	case ${g_MASK_NDX} in
		1) MASK="${BORDER_COLOR}${L_SIDE}${RESET}${OBJ_COLOR}${OBJS[1]}    ${RESET}${BORDER_COLOR}${R_SIDE}${RESET}";;
		2) MASK="${BORDER_COLOR}${L_SIDE}${RESET}${OBJ_COLOR}  ${OBJS[2]}  ${RESET}${BORDER_COLOR}${R_SIDE}${RESET}";;
		3) MASK="${BORDER_COLOR}${L_SIDE}${RESET}${OBJ_COLOR}    ${OBJS[3]}${RESET}${BORDER_COLOR}${R_SIDE}${RESET}";;
	esac

	if [[ ${g_MASK_NDX} -eq 3 ]];then
		[[ ${g_INDICATOR_FLIP} == 'true' ]] && g_INDICATOR_FLIP=false || g_INDICATOR_FLIP=true
	fi

	(( g_MASK_NDX++))
	[[ ${g_MASK_NDX} -gt 3 ]] && g_MASK_NDX=1

 	tcup ${IND_X} ${IND_Y} && echo -n "${MASK}" && sleep ${DELAY}

	g_LAST_SPEED=${SPEED}
	g_LAST_STYPE=${STYPE}
}

download_select () {
	local SEARCHTERM=${1}
	local SEARCHTYPE=''
	local L F
	local TITLE
	local FLST
	local STR

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"
	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} ${GREEN_FG}LOCAL_LIST COUNT${RESET}:${#_LOCAL_LIST}"

	SEARCHTYPE=Videos

	_SORT_TABLE=(1 1 2 2 3 3) # Age, author, title

	if [[ ${_QUERY_OPTS[ENGINE]:l} == 'youtube' ]];then
		[[ ${_QUERY_OPTS[STRICT]} == 'true' ]] && SEARCHTYPE="Strict (${_QUERY_OPTS[SMSG]} rejected)"
	fi

	# Set headings
	list_set_header_init
	list_set_header 'printf "Found:${WHITE_FG}%-d${RESET} $(str_pluralize video ${#_LIST})\tPlatform:${WHITE_FG}%s${RESET}\tQuery Key:${WHITE_FG}%s${RESET}\tQuery Type:${WHITE_FG}%s${RESET}\tSelected:${WHITE_FG}%s${RESET}\t${_PG}" ${#_LIST} ${(C)_QUERY_OPTS[ENGINE]} ${(C)SEARCHTERM} ${(C)_QUERY_OPTS[TYPE]} $(list_get_selected_count)'
	list_set_header 'printf " "'
	list_set_header 'printf "%*s %-*s %-*s %-*s" 5 "" ${_FIELD_LEN[age]} "Age" ${_FIELD_LEN[author]} "Author" ${_FIELD_LEN[title]} "Title"'
	list_set_header 'printf "%*s ${SCOL1_CLR}%-*s${RESET} ${SCOL2_CLR}%*s${RESET} ${SCOL3_CLR}%*s${RESET}" 5 "" ${_FIELD_LEN[age]} "$(str_unicode_line ${_FIELD_LEN[age]})" ${_FIELD_LEN[author]} "$(str_unicode_line ${_FIELD_LEN[author]})" ${_FIELD_LEN[title]} "$(str_unicode_line ${_FIELD_LEN[title]})"'

	# Set line item
	list_set_line_item ' 
	local ITEM_COLOR=$(set_item_color $(item_decorate ${_LIST_NDX}));
	printf "${BOLD}${WHITE_FG}%4s${RESET}${_MARKER} ${SHADE}${BAR}${ITEM_COLOR}%-${_FIELD_LEN[age]}s${RESET}${SHADE}${BAR} %-${_FIELD_LEN[author]}s %-${_FIELD_LEN[title]}s${RESET}\n" ${_LIST_NDX} "$(item_decorate ${_LIST_NDX})"  "$(get_field author ${_LIST_NDX})"  "$(get_field title ${_LIST_NDX})" 
	'

	list_set_select_action ${_ACTION}
	list_set_action_msgs video download
	list_set_sortable true
	list_set_searchable false
	list_set_barlines true
	list_set_page_callback log_find 
	list_set_sort_defaults ARRAY "_LIST" COL 1 ORDER "a" DELIM ${_LIST_DELIM} TYPE "flat" TABLE "${(kv)_SORT_TABLE}" MAXCOL 3

	while true;do
		# Generate list for selected title
		list_select ${_LOCAL_LIST}
		[[ ${?} -eq 0 ]] && break

		_MARKED=($(list_get_selected))
		
		if [[ $(list_get_selected_count) -ne 0 ]];then
			action_warn
			if [[ ${_MSG_KEY} == "y" ]];then
				action_do
			fi
			_LIST_SELECTED=()
		fi
	done

	_CANCELLED=()
	_DOWNLOADS=()
	_FAILED=()
	_FUTURE=()
}

fav_add () {
	local -a EXISTING_KEYS=()
	local -aU HISTORY
	local CNT=0
	local FAV=''
	local LNUM=''
	local MENU_KEY=''
	local MENU_SEL=''
	local MK=''
	local NEW_KEY=''
	local UPD_KEY=false
	local KEY_MATCH=''
	local DK=''
	local K

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"
	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} FKEY:${_QUERY_OPTS[QKEY]} DKEY:${_QUERY_OPTS[DKEY]} _QUERY_OPTS[ENGINE]:${_QUERY_OPTS[ENGINE]}"

	clear

	msg_box -H1 -p -PC "<w><I>Please respond<N>|<Z>|Add \"${_QUERY_OPTS[QKEY]}\" to favorites?"
	[[ ${_MSG_KEY} != 'y' ]] && return

	while true;do
		msg_box -c -H1 -p -PS -jl "<w>Select Favorites List<N>|$(msg_list_number ${(ov)_MENU_TYPES})"
		[[ ${_MSG_KEY} -eq 0 ]] && break
		MENU_SEL=${_MENU_TYPES[${_MSG_KEY}]}
		[[ -z ${MENU_SEL} ]] && msg_box -p -PK "Invalid option" && continue
		MENU_SEL=${MENU_SEL[1]:u} 
		break
	done
	[[ -z ${MENU_SEL} ]] && return 1

	EXISTING_KEYS=("${(f)$(grep -Ei "${_QUERY_OPTS[QKEY]}|${_QUERY_OPTS[DKEY]:gs/ /_/}" ${_YTS_FAVORITES})}")

	for K in ${EXISTING_KEYS};do
		DK=$(cut -d'|' -f1 <<<${K})
		MK=$(cut -d'|' -f3 <<<${K})
		MENU_KEY=${MK[1]}
		if [[ ${MENU_KEY} == ${MENU_SEL} ]];then
			UPD_KEY=true
			_QUERY_OPTS[DKEY]=$(cut -d'|' -f1 <<<${K}) # Use existing display key
			KEY_MATCH=${K} # Key for selected menu exists
		fi
	done

	[[ -n ${DK} ]] && _QUERY_OPTS[DKEY]=${DK} # Retain display key if match was QKEY

	case ${MENU_SEL} in
		C) if [[ ${_QUERY_OPTS[ENGINE]} == 'youtube' ]];then # Custom requires ECODE
				NEW_KEY="${_QUERY_OPTS[DKEY]:gs/ /_/}|${_QUERY_OPTS[QKEY]}|${MENU_SEL}${_QUERY_OPTS[ECODE]}${_QUERY_OPTS[STRICT]}"
			elif [[ ${_QUERY_OPTS[ENGINE]} == 'rumble' ]];then
				NEW_KEY="${_QUERY_OPTS[DKEY]:gs/ /_/}|${_QUERY_OPTS[QKEY]}|${MENU_SEL}${_QUERY_OPTS[ECODE]}${_QUERY_OPTS[RQT]}"
			fi;;
		R) NEW_KEY="${_QUERY_OPTS[DKEY]:gs/ /_/}|${_QUERY_OPTS[QKEY]}|${MENU_SEL}${_QUERY_OPTS[RQT]}";;
		Y) NEW_KEY="${_QUERY_OPTS[DKEY]:gs/ /_/}|${_QUERY_OPTS[QKEY]}|${MENU_SEL}${_QUERY_OPTS[STRICT]}";;
	esac

	msg_box -c -t ${_MSG_DELAY[MED]} "<w>Adding<N>: \"${_QUERY_OPTS[DKEY]}\"|<w>to<N> ${MENU_TYPES[${_MSG_KEY}]} <w>list<N>"

	if [[ ${UPD_KEY} == 'true' ]];then
		if [[ ${KEY_MATCH} == ${NEW_KEY} ]];then
			msg_box -c -t ${_MSG_DELAY[LONG]} -s# "Key:<w>${KEY_MATCH}<N>#<r>Matching key already exists<N>#Nothing to do!"
			return 2
		fi
		msg_box -c -p -PK -H1 -s# "<r>Duplicate Menu Key<N>#${KEY_MATCH}#<r>already exists<N>#<Z>#Replace with:#${NEW_KEY}#(Y/N)"
		[[ ${_MSG_KEY} != 'y' ]] && return 1
		LNUM=$(cut -d: -f1 <<<$(grep -ni ${KEY_MATCH} ${_YTS_FAVORITES})) # Get line number of existing key
		if [[ -n ${LNUM} ]];then
			sed -i "${LNUM}d" ${_YTS_FAVORITES} # Delete line number
			sed -i "${LNUM}i ${NEW_KEY}" ${_YTS_FAVORITES} # Insert replacement
		else
			msg_box "${0}: grep error - unable to locate line for key"
		fi
	else
		echo ${NEW_KEY} >> ${_YTS_FAVORITES} # Append new key to file
	fi
	return 0
}

fav_delete () {
	local DKEY=${1:gs/ /_/}
	local MKEY=${2:u}
	local -a FAV_KEYS=()
	local F3=''
	local MK=''
	local KEY_MATCH=''
	local K

	FAV_KEYS=("${(f)$(grep -Ei ${DKEY} ${_YTS_FAVORITES})}") # Locate via display key

	for K in ${FAV_KEYS};do
		F3=$(cut -d'|' -f3 <<<${K}) # 3rd field
		MK=${F3[1]} # First char
		[[ ${MK} == ${MKEY} ]] && KEY_MATCH=${K} # Ensure corresponding menu matches
	done

	if [[ -n ${KEY_MATCH} ]];then
		msg_box -c -p -PD -H1 "<B><r>Deleting Menu Key<N>|${KEY_MATCH:gs/|/#/}"
		if [[ ${_MSG_KEY} == 'y' ]];then
			cp ${_YTS_FAVORITES} ${_YTS_FAVORITES}.bak
			sed -i "/${KEY_MATCH}/d" ${_YTS_FAVORITES}
			return ${?}
		fi
	else
		return 1
	fi
}

fav_get () {
	local -a C_LIST=()
	local -a R_LIST=()
	local -a Y_LIST=()
	local LIST=''
	local OPTS=''
	local MENU_TYPE=''
	local HDR_TAG=" <I>(Custom List)<N> "
	local ENGINE=''
	local MAP="(<w>r<N>)umble list, (<w>y<N>)outube list, (<w>c<N>)ustom list, (<w>d<N>)elete favorite"
	local TAG=''
	local HDR=''
	local FTR=''
	local O_COLOR=''
	local L

	for L in ${(k)_FAV_LIST};do
		OPTS=$(cut -d: -f2 <<<${_FAV_LIST[${L}]})
		MENU_TYPE=${OPTS[1]:l}
		case ${MENU_TYPE} in
			c) C_LIST+="${L:gs/_/ /}";;
			r) R_LIST+="${L:gs/_/ /}";;
			y) Y_LIST+="${L:gs/_/ /}";;
		esac
	done

	while true;do
		case ${g_LAST_FAV_TYPE} in
			c) LIST=(${C_LIST})
				ENGINE='custom'
				HDR_TAG=${CUSTOM_MSG}
				O_COLOR=${RED_FG}
				;;
			r) LIST=(${R_LIST})
				ENGINE='rumble'
				HDR_TAG=''
				O_COLOR=${MAGENTA_FG}
				;;
			y) LIST=(${Y_LIST})
				ENGINE='youtube'
				HDR_TAG=''
				O_COLOR=${CYAN_FG}
				;;
		esac

		clear

		TAG="${ENGINE}.${g_LAST_FAV_TYPE}.query"
		HDR="<B>${(C)ENGINE}${HDR_TAG} <B>Query<N>"
		FTR="<w>Run ${(C)ENGINE} query from history or <h>(q)uit<N>"

		sel_set_app_keys d r y c
		sel_set_list ${LIST}
		list_set_pos_reset # Fresh list - position at top

		msg_line_weight heavy
		sel_list -R -S -T${TAG} -O${O_COLOR} -H${HDR} -M${MAP} -F${FTR}
		msg_line_weight light

		if [[ ${_SEL_KEY} == 'd' ]];then
			fav_delete ${_SEL_VAL} ${g_LAST_FAV_TYPE} # Call key delete
			[[ ${?} -eq 0 ]] && fav_load && return 1 # Reload favorites & return
		fi

		[[ ${_SEL_KEY} =~ 'y|r|c' ]] && g_LAST_FAV_TYPE=${_SEL_KEY}
		if [[ ${_SEL_KEY} == '?' ]];then
			_QUERY_OPTS[FKEY]=${_SEL_VAL:gs/ /_}
			_QUERY_OPTS[DKEY]=${_SEL_VAL}
			break
		fi
	done
	return 0
}

fav_load () {
	local LINE
	local DISPLAY_LABEL
	local Q_KEY
	local Q_OPTS

	_FAV_LIST=()

	[[ ! -f ${_YTS_FAVORITES} ]] && return 1

	while read LINE;do
		DISPLAY_LABEL=$(cut -d'|' -f1 <<<${LINE})
		Q_KEY=$(cut -d'|' -f2 <<<${LINE})
		Q_OPTS=$(cut -d'|' -f3 <<<${LINE})
		_FAV_LIST[${DISPLAY_LABEL}]="${Q_KEY}:${Q_OPTS}"
	done < ${_YTS_FAVORITES}

	[[ -n ${_FAV_LIST} ]] && return 0 || return 1
}

get_field () {
	local FIELD=${1}
	local NDX=${2}
	local -A FIELD_MAP=("age" 1 "author" 2 "title" 3 "url" 4 "time" 5 "agetime" 6)
	local STR=''
	local TSTR=''

	[[ ${_DEBUG} -ge ${_MID_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@} ARGS:FIELD:${FIELD}, NDX:${NDX}"
	[[ ${_DEBUG} -ge ${_MID_DBG} ]] && dbg "${0}:${LINENO} _LIST[NDX]:${_LIST[${NDX}]}"

	case ${FIELD} in
		age) STR=$(cut -d'|' -f${FIELD_MAP[age]} <<<${_LIST[${NDX}]});;
		agetime) STR=$(cut -d'|' -f${FIELD_MAP[agetime]} <<<${_LIST[${NDX}]} | sed 's/( */(/');;
		author) STR=$(cut -d'|' -f${FIELD_MAP[author]} <<<${_LIST[${NDX}]});;
		time) STR=$(cut -d'|' -f${FIELD_MAP[time]} <<<${_LIST[${NDX}]});;
		title) STR=$(cut -d'|' -f${FIELD_MAP[title]} <<<${_LIST[${NDX}]});;
		url) STR=$(cut -d'|' -f${FIELD_MAP[url]} <<<${_LIST[${NDX}]});;
	esac

	logit ${_YT_DBG_LOG} "${0}: MAPPED VALUE ${FIELD}:${STR}"

	[[ ${_DEBUG} -ge ${_MID_DBG} ]] && dbg "${0}: Parsed FIELD:${FIELD} STR:${STR}"

	if [[ ${FIELD} == 'agetime' ]];then
		[[ ${STR:l} =~ 'views' ]] && STR=$(sed -E 's/^(.*views )(.*ago)(.*)/(\2)/' <<<${STR})
		[[ ${STR:l} =~ 'live' ]] && STR=$(sed -E 's/(.*ago)( live)(.*)/\1)/I' <<<${STR})
	fi

	if [[ ${FIELD} == 'author' ]];then
		if [[ ${_QUERY_OPTS[QKEY]} =~ ' ' ]];then # Query key contains a space - assume multiple authors are displayed
			STR=$(str_trim <<<${STR})
			[[ -z ${STR} ]] && STR=${_QUERY_OPTS[DKEY]} # Ensure not blank
		else
			STR=${_QUERY_OPTS[DKEY]}
		fi
	fi

	if [[ -n ${_FIELD_LEN[${FIELD}]} ]];then
		STR=${STR[1,${_FIELD_LEN[${FIELD}]}]}
	fi

	logit ${_YT_DBG_LOG} "${0}:  FINAL VALUE ${FIELD}:${STR}"

	echo -n ${STR}
}

get_speed () {
	local SPEED=${@}
	local TYPE=''

	SPEED=$(sed -E 's/^.*at\s+//' <<<${SPEED:l} | cut -d' ' -f1 | sed 's/[/]s//')
	[[ ${SPEED} =~ 'mib' ]] && TYPE=M || TYPE=K
	SPEED=$(sed 's/.ib//' <<<${SPEED})

	[[ ${SPEED} == '100%' ]] && SPEED=0 # Completed

	if validate_is_number ${SPEED};then
		echo "${SPEED}|${TYPE}"
	else
		echo "0|${TYPE}"
	fi
}

item_decorate () {
	local NDX=${1}
	local STR

	[[ ${_DEBUG} -ge ${_MID_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: NDX:${NDX}"

	if [[ ${_DOWNLOADS[${NDX}]} == 'true' ]];then
		STR="Downloaded..."
	elif [[ ${_CANCELLED[${NDX}]} == 'true' ]];then
		STR="Cancelled..."
	elif [[ ${_FAILED[${NDX}]} == 'true' ]];then
		STR="Failed..."
	elif [[ ${_FUTURE[${NDX}]} == 'true' ]];then
		STR="Future: ${g_WHEN:s/minutes/mins/}"
	elif [[ ${_PARTIALS[${NDX}]} == 'true' ]];then
		STR="Partial..."
	else
		STR=${$(get_field agetime ${NDX})[1,${_FIELD_LEN[agetime]}]}
	fi

	[[ ${_DEBUG} -ge ${_MID_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: STR:${STR}"

	echo -n ${STR}
}

job_kill () {
	local -a PIDS=()
	local PID
	local P

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	PIDS=("${(f)$(pgrep -n "yt-dlp")}")
	if [[ ${?} -eq 0 ]];then
		for P in ${PIDS};do
			kill -9 ${P} >/dev/null 2>&1
			find ${_DOWNLOAD_DIR} -maxdepth 1 \( -name '*part' -or -name '*ytdl' \) -exec rm -rf {} \;
			logit ${_YT_DBG_LOG} "${0}: Killed ${P}"
		done
	else
		logit ${_YT_DBG_LOG} "${0}: No processes found"
	fi

	if [[ ! ${functrace[1]} =~ "job_reset" ]];then # Exit unless called by reset
		trap - INT # Disable trap
		log_clear "job_kill"
		exit_leave "${_SCRIPT}:${WHITE_FG}Download Job:${RED_FG}killed${RESET}"
	fi
}

job_reset () {
	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	job_kill
	logit ${_YT_DBG_LOG} "${0}: Job was reset"
}

job_start () {
	local URL=${@}
	local CMD=''

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	g_YTS_LOG=$(mktemp ${_CFG_DIR}/yt.log.XXXXXX)

	CMD="nohup yt -N2 -Rinfinite -i -o '%(channel)s - %(title).200s.%(ext)s' ${(qqq)URL}" # Routine download - limit title len

	echo "${0} CMD:${CMD}" >> ${g_YTS_LOG} 2>/dev/null # Log command
	[[ ${?} -ne 0 ]] && exit_leave $(err_msg_exit "Unable to access log file:${g_YTS_LOG}")

	eval "${CMD} >> ${g_YTS_LOG} >/dev/null 2>&1" & # Start background job
	g_PID=$!

	logit ${_YT_DBG_LOG} "${0}: QUERY KEY:${_QUERY_OPTS[QKEY]}"
	logit ${_YT_DBG_LOG} "${0}: CMD:${CMD} PID:${g_PID}"

	echo "${0}: PID:${g_PID}" >> ${g_YTS_LOG} # Log pid

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: CMD:${CMD}"
}

last_code_update () {
	local MARKER_ARG=${1}
	local LAST_UPD=0
	local LAST_TIME=0

	[[ -z ${MARKER_ARG} ]] && exit_leave "${_SCRIPT_TAG}} ${RED_FG}Missing argument${RESET}:<MARKER>"

	if [[ -e ${MARKER_ARG} ]];then
		LAST_UPD=$(stat -c "%y" ${MARKER_ARG} | cut -d' ' -f1)
		[[ -e ${MARKER_ARG} ]] && LAST_TIME=$(stat -c"%x" ${MARKER_ARG} | cut -d. -f1 | cut -d' ' -f2 | cut -d: -f1,2) 
		echo "$(date_since_today ${_TODAY} ${LAST_UPD}) at ${LAST_TIME}"
	fi
}

last_file_downloaded () {
	local ST=''
	local FN=''
	local IN=''

	ST=$(stat -c"%W|%i|%n" ${_DOWNLOAD_DIR}/* | sort -t'|' -k1 -r | head -1) # Sort by birth date; grab most recent
	FN=$(cut -d'|' -f3 <<<${ST}) # Filename
	IN=$(cut -d'|' -f2 <<<${ST}) # Inode

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: FN:${FN} INODE:${IN}"

	if [[ -e ${FN} ]];then
		echo "${FN}|${IN}"
		return 0
	else
		return 1
	fi
}

list_reset () {
	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	_LIST_SELECTED=()
	_MARKED=()
	_SELECTION_LIST=()
}

log_add () {
	local NDX=${1}
	local LF=$(last_file_downloaded) # Filename|Inode
	local FN=$(cut -d'|' -f1 <<<${LF}) # Filename
	local IN=$(cut -d'|' -f2 <<<${LF}) # Inode
	local TL=$(get_field title ${NDX}) # Title
	local AT=$(get_field agetime ${NDX}) # Age
	local AU=$(get_field author ${NDX}) # Author
	local TM=$(sed -E 's/^.*ago\s+(.*)\)/\1/' <<<${AT}) # Video length

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: FN:${FN} INODE:${IN}"

	[[ ${FN:e} == 'part' || ${FN:e} == 'temp' ]] && return # No partials in log

	echo "${IN}|${TL}|${FN:t}|${TM}|${AU}" >> ${_YTS_DOWNLOAD_LOG}
}

log_clear () {
	local FROM=${1}

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	if [[ ${_DEBUG} -eq 0 && ${_EXIT_SCRUB} == 'true' && -e ${g_YTS_LOG} ]];then
		rm -f ${g_YTS_LOG}
		logit ${_YT_DBG_LOG} "${0}: Temp log file:${g_YTS_LOG} was cleared for:${_QUERY_OPTS[QKEY]} from:${FROM}"
	else
		logit ${_YT_DBG_LOG} "${0}: DEBUG TRIGGERED - log ${g_YTS_LOG} was retained for:${_QUERY_OPTS[QKEY]}"
	fi
}

log_find () { 
	local TOP=${1} # Page top row supplied by LIST.zsh line 108
	local BOT=${2} # Page bot row supplied by LIST.zsh line 108
	local LINE_NUM=''
	local LIST_AU=''
	local LIST_TITLE=''
	local LIST_TM=''
	local LOG_AU=''
	local LOG_FN=''
	local LOG_LINE=''
	local LOG_TITLE=''
	local LOG_TM=''
	local R=0
	local DBG=false

	[[ ${_DEBUG} -ge ${_LOW_DETAIL_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	# Page callback - scan list to find downloaded items
	 
	_DOWNLOADS=()
	_PARTIALS=()

	[[ ${DBG} == 'true' ]] && /bin/rm -f ${0}.dbg

	for ((R=${TOP}; R <= ${BOT}; R++));do
		LINE_NUM=''

		LIST_TITLE=$(get_field title ${R}) # Title from list
		LIST_AU=$(get_field author ${R}) # Author from list
		LIST_TM=$(sed -E 's/^.*ago\s+(.*)\)/\1/' <<<$(get_field agetime ${R}) | tr -d '[()]' | sed 's/undefined//') # Video length from list

		[[ ${DBG} == 'true' ]] && echo "\nLIST_NDX:${R}" >>${0}.dbg
		[[ ${DBG} == 'true' ]] && echo "LIST_TITLE:${LIST_TITLE}" >>${0}.dbg
		[[ ${DBG} == 'true' ]] && echo "LIST_AU:${LIST_AU}" >>${0}.dbg
		[[ ${DBG} == 'true' ]] && echo "LIST_TM:${LIST_TM}" >>${0}.dbg
		[[ ${DBG} == 'true' ]] && echo "\nAttempting TITLE match on:${LIST_TITLE[1,50]}" >>${0}.dbg 

		if [[ -n ${LIST_TITLE[1,50]} ]];then
			LOG_TITLE=$(grep -F -n -m1 -i -- ${LIST_TITLE[1,50]} ${_YTS_DOWNLOAD_LOG}) # grep -F option needed to ignore any special chars
			if [[ ${?} -eq 0 ]];then
				LINE_NUM=$(cut -d: -f1 <<<${LOG_TITLE}) # Fetch line number
				LOG_LINE=$(sed -n "${LINE_NUM}p" ${_YTS_DOWNLOAD_LOG}) # Fetch log line
				LOG_AU=$(grep -i -o -m1 "${LIST_AU}$" <<<${LOG_LINE}) # Match author in log line
				LOG_TM=$(grep -o ${LIST_TM} <<<${LOG_LINE}) # Match time in log line

				[[ ${DBG} == 'true' ]] && echo "Matched:TITLE:${LOG_TITLE}" >>${0}.dbg
				[[ ${DBG} == 'true' ]] && echo "Log line:${LOG_LINE}" >>${0}.dbg
				[[ ${DBG} == 'true' ]] && echo "Author:${LIST_AU} Time:${LIST_TM}" >>${0}.dbg

				if [[ -n ${LOG_TM} && -n ${LOG_AU} ]];then
					LOG_FN=$(cut -d '|' -f3 <<<${LOG_LINE}) # Fetch filename
					_DOWNLOADS[${R}]=true

					[[ ${DBG} == 'true' ]] && echo "Confirmed match: Marking NDX:${R} as downloaded for file:${LOG_FN}\n" >>${0}.dbg
					[[ ${DBG} == 'true' ]] && echo "LOG_AU:${LOG_AU}" >>${0}.dbg
					[[ ${DBG} == 'true' ]] && echo "LOG_TM:${LOG_TM}" >>${0}.dbg
				else
					[[ ${DBG} == 'true' ]] && echo "Failed to confirm download" >>${0}.dbg
				fi
			fi
		else
			logit ${_YT_DBG_LOG} "${0}: Skipped title search - blank title"
		fi
	done
}

log_scrub () {
	# TODO: This may duplicate log_update - investigate
	local -A DIR_INODES=()
	local -A LOG_LINES=()
	local -a ERR_INODES=()
	local -a LIST=()
	local ERR_CNT=0
	local LINE=''
	local LOG_FN=''
	local NEW_LOG=/tmp/${_YTS_DOWNLOAD_LOG:r}.new

	LIST=("${(f)$(ls -Ai ${_DOWNLOAD_DIR})}")
	if [[ -z ${LIST} ]];then
		rm -f ${_YTS_DOWNLOAD_LOG} >/dev/null 2>&1  # Ensure no downloads are logged
		touch ${_YTS_DOWNLOAD_LOG}
		return
	fi

	for L in ${(on)LIST};do
		DIR_INODE=$(cut -d' ' -f1 <<<${L})
		DIR_FN=$(cut -d' ' -f2- <<<${L})
		[[ ${DIR_FN:e} == 'part' ]] && continue
		DIR_INODES[${DIR_INODE}]=${DIR_FN}
	done

	[[ -e ${NEW_LOG} ]] && /bin/rm -f ${NEW_LOG}
	for K in ${(onk)DIR_INODES};do
		LOG_LINE=$(grep ${K} ${_YTS_DOWNLOAD_LOG})
		if [[ ${?} -eq 0 ]];then
			LOG_LINES[${K}]=${LOG_LINE}
		fi
	done

	ERR_CNT=0
	while read LINE;do
		LOG_INODE=$(cut -d'|' -f1 <<<${LINE})
		LOG_FN=$(cut -d'|' -f3 <<<${LINE})
		if [[ -z "${DIR_INODES[${LOG_INODE}]}" ]];then
			((ERR_CNT++))
			ERR_INODES+=${LOG_INODE}
		else
			if [[ "${DIR_INODES[${LOG_INODE}]}" != "${LOG_FN}" ]];then
				((ERR_CNT++))
				ERR_INODES+=${LOG_INODE}
			else
				echo ${LOG_LINES[${LOG_INODE}]} >> ${NEW_LOG}
			fi
		fi
	done < <(sort -n <${_YTS_DOWNLOAD_LOG})

	if [[ ${ERR_CNT} -ne 0 ]];then
		cp ${_YTS_DOWNLOAD_LOG} ${_YTS_DOWNLOAD_LOG}.$(date +"%s")
		mv -f ${NEW_LOG} ${_YTS_DOWNLOAD_LOG}
	fi
}

log_to_file () { 
	local TOP=${1} # Page top row
	local BOT=${2} # Page bot row
	local FN=''
	local LINE=''
	local LIST_AU=''
	local LIST_TM=''
	local R=0

	# Page callback - pre-process list to populate download status
	 
	_DOWNLOADS=()
	_PARTIALS=()

	for ((R=${TOP}; R <= ${BOT}; R++));do
		LIST_AU=$(get_field author ${R}) # Author from list
		LIST_TM=$(sed -E 's/^.*ago\s+(.*)\)/\1/' <<<$(get_field agetime ${R}) | tr -d '[()]' | sed 's/undefined//') # Video length from list
		LINE=$(grep -i ${LIST_AU} ${_YTS_DOWNLOAD_LOG} 2>/dev/null | grep ${LIST_TM} 2>/dev/null) # Match on author/time
		if [[ -n ${LINE} ]];then 
			FN=$(cut -d '|' -f3 <<<${LINE})
			if [[ -e ${_DOWNLOAD_DIR}/${FN} ]];then
				break
			fi
		fi
	done

	echo ${FN}
}

log_update () {
	local -A SEEN=()
	local FN_HIT=''
	local HAS_NEW_LOG=false
	local INODE=''
	local LINE=''
	local LOG_LINE=''
	local NEW_LOG=${_CFG_DIR}/log.new
	local L

	{
		[[ -e ${_CFG_DIR}/log.new ]] && /bin/rm -f ${NEW_LOG}
		logit ${_YT_DBG_LOG} "${0}: LOG lines BEFORE update:$(wc -l ${_YTS_DOWNLOAD_LOG})"

		HAS_NEW_LOG=false
		while read -u3 LINE;do
			INODE=$(cut -d'|' -f1 <<<${LINE})
			if [[ ${SEEN[${INODE}]} -eq 1 ]];then
				logit ${_YT_DBG_LOG} "${0}: ERROR Got duplicate inode:${INODE} - skipping duplicates"
				continue
			fi
			SEEN[${INODE}]=1
			FN_HIT=$(find ${_DOWNLOAD_DIR} -maxdepth 1 -inum ${INODE})
			if [[ -n ${FN_HIT} ]];then
				HAS_NEW_LOG=true
				LOG_LINE=$(grep -m1 ${INODE} ${_YTS_DOWNLOAD_LOG} 2>/dev/null)
				[[ ${?} -eq 0 ]] && echo ${LOG_LINE} >> ${NEW_LOG} || logit ${_YT_DBG_LOG} "${0}: ERROR Log line for:${INODE} not found"
			else
				logit ${_YT_DBG_LOG} "${0}: Skipping expired inode:${INODE}"
				SEEN[${INODE}]=1
				continue
			fi
		done 3< ${_YTS_DOWNLOAD_LOG}

		if [[ ${HAS_NEW_LOG} == 'true' ]];then
			cp ${_YTS_DOWNLOAD_LOG} ${_YTS_DOWNLOAD_LOG}.bak
			mv -f ${NEW_LOG} ${_YTS_DOWNLOAD_LOG}
			logit ${_YT_DBG_LOG} "${0}: LOG lines AFTER update:$(wc -l ${_YTS_DOWNLOAD_LOG})"
		else
			/bin/rm -f ${_YTS_DOWNLOAD_LOG} && touch ${_YTS_DOWNLOAD_LOG} # No files present - initialize new log
			logit ${_YT_DBG_LOG} "${0}: Empty log - initializing new log"
		fi
	} 2>/dev/null
}

post_process () {
	local -a LIST=()
	local -a PIDS=()
	local -a TEMP_FILES=()
	local FN=''
	local LF=''
	local MSG="Post Processing"
	local NEW_FN=''
	local NDX=0
	local F K

	msg_box -x$(( _CONT_COORDS[X] + 4 )) -y$(box_center ${MSG}) ${MSG}

	NDX=0
	while true;do
		((NDX++))
		PIDS=("${(f)$(pgrep -n "yt-dlp")}")
		if [[ ${?} -ne 0 ]];then
			sleep 2 && break
		fi
		msg_box -x14 "(<w>${NDX}<N>) Waiting for <c>yt-dlp<N> to finish post-processing..."
		sleep 1
	done

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: Removing any temp.mp4 files"

	TEMP_FILES=("${(f)$(find ${_DOWNLOAD_DIR} -name '*temp.mp4')}")
	for F in ${TEMP_FILES};do
		/bin/rm -f ${F} >/dev/null 2>&1
		[[ ${?} -eq 0 ]] && logit ${_YT_DBG_LOG} "${0}: Deleted ${F}"
	done

	LF=$(last_file_downloaded) # Filename and Inode
	FN=$(cut -d'|' -f1 <<<${LF}) # Filename
	logit ${_YT_DBG_LOG} "${0}: Last file downloaded:${FN}"

	set_final_fn ${FN}
}

parse_rumble () {
	local PARSE_TYPE=${1}
	local -A GENERAL=()
	local -A NON_GENERAL=()
	local -a HTML=()
	local DATA=''
	local LAST_ROW=0
	local LINE=''
	local NDX=0
	local OMIT_NDX=0
	local ROW=0
	local TAB=''
	local TAG=''
	local TAGLINE=''
	local TAG_ARRAY=''
	local AGE AUTHOR TITLE URL TIME AGETIME
	local K

	NON_GENERAL[TITLES]='thumbnail__title attr{title}'
	NON_GENERAL[LINKS]='title__link attr{href}'
	NON_GENERAL[AGES]='videostream__time text{}'
	NON_GENERAL[DURATIONS]='videostream__badge text{}'

	GENERAL[AUTHORS]='ellipsis-1 text{}'
	GENERAL[TITLES]='video-item--title text{}'
	GENERAL[LINKS]='video-item--a attr{href}'
	GENERAL[AGES]='video-item--time text{}'
	GENERAL[DURATIONS]='video-item--duration attr{data-value}'

	logit ${_YT_DBG_LOG} "${0}: Parsing list for QKEY:${_QUERY_OPTS[QKEY]}"

	if [[ ${PARSE_TYPE} == 'g' ]];then
		TAG_ARRAY="GENERAL"
		TAGLINE="\"video-item--img\""
	else
		TAG_ARRAY="NON_GENERAL"
		TAGLINE="thumbnail__grid--item"
	fi

	ROW=-1
	while read LINE;do
		HTML+=${LINE}
		if [[ ${LINE} =~ ${TAGLINE} ]];then
			((ROW++))
			[[ ${ROW} -eq 0 ]] && continue
			for K in ${(k)${(P)TAG_ARRAY}};do
				TAG=${${(P)TAG_ARRAY}[${K}]}
				DATA=$(pup --charset utf8 ".${TAG}" <<<${HTML} | strip_unwanted)
				_RUMBLE_ROWS[${ROW}_${K}]=${DATA}
			done
			HTML=()
		fi
	done <<<${_RUMBLE_PAGE}

	LAST_ROW=0
	NDX=0
	_LOCAL_LIST=()
	for K in ${(onk)_RUMBLE_ROWS};do
		ROW=$(cut -d'_' -f1 <<<${K})
		TAB=$(cut -d'_' -f2 <<<${K})
		case ${TAB} in
			AGES) AGE=${_RUMBLE_ROWS[${K}]};;
			AUTHORS) AUTHOR=${_RUMBLE_ROWS[${K}]};;
			DURATIONS) TIME=${_RUMBLE_ROWS[${K}]};;
			LINKS) URL="https://rumble.com${_RUMBLE_ROWS[${K}]}";;
			TITLES) TITLE=${_RUMBLE_ROWS[${K}]};;
		esac
		if [[ -n ${AGE} && -n ${TITLE} && -n ${URL} && ${TIME} ]];then # All fields populated
			if [[ ${ROW} != ${LAST_ROW} ]];then
				# TODO: src_v1_mfp may need omission - investigate
				[[ ${URL} =~ 'ucp_f' ]] && OMIT_NDX=${ROW} && logit ${_YT_DBG_LOG} "${0}: Omitting NDX:${ROW} - URL - ucp_f"
				[[ ! ${TIME} =~ ':' ]] && OMIT_NDX=${ROW} && logit ${_YT_DBG_LOG} "${0}: Omitting NDX:${ROW} - TIME no colon"
				AGETIME="(${AGE} ${TIME})"
				[[ -z ${AUTHOR} ]] && AUTHOR=${_QUERY_OPTS[DKEY]}
				if [[ ${ROW} -ne ${OMIT_NDX} ]];then
					((NDX++))
					_LOCAL_LIST[${NDX}]="${AGE}|${AUTHOR}|${TITLE}|${URL}|${TIME}|${AGETIME}"
					OMIT_NDX=0
				fi
				AGE='' && AUTHOR='' && TIME='' && URL='' && TITLE='' && AGETIME='' 
			fi
			LAST_ROW=${ROW}
		fi
	done

	if ! arr_is_populated "${_LOCAL_LIST}";then
		return 1
	fi

	return 0
}

query_rumble () {
	local GEN_SEARCH=''
	local QRY=''
	local QRY_TYPE=''

	QRY_TYPE=${_RUMBLE_QTYPES[${_QUERY_OPTS[RQT]:l}]}
	[[ -z ${QRY_TYPE} ]] && msg_box -p -PK "${0}:Invalid query type:${_QUERY_OPTS[RQT]}" && return 1
	_QUERY_OPTS[TYPE]=${QRY_TYPE}

	ping -w1 www.rumble.com >/dev/null
	[[ ${?} -ne 0 ]] && msg_box -p -PK "Rumble is down" && return 1

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	logit ${_YT_DBG_LOG} "${0}: Creating listing for QKEY:${_QUERY_OPTS[QKEY]} TYPE:${QRY_TYPE}"

	# Queries
	if [[ ${QRY_TYPE} == 'live' ]];then
		msg_box -c "Requesting <c><I>livestream channel<N> search..."
		QRY="https://rumble.com/c/${_QUERY_OPTS[QKEY]}/livestreams"
		_RUMBLE_PAGE=$(wget -q -O - ${QRY})
	elif [[ ${QRY_TYPE} == 'channel' ]];then
		msg_box -c "Requesting <c><I>channel<N> search..."
		QRY="https://rumble.com/c/${_QUERY_OPTS[QKEY]}?page=1"
		_RUMBLE_PAGE=$(wget -q -O - ${QRY})
	elif [[ ${QRY_TYPE} == 'general' ]];then
		msg_box -c "Requesting <c><I>general<N> search..."
		GEN_SEARCH=$(sed 's/ /%20/g' <<<${_QUERY_OPTS[QKEY]})
		QRY="https://rumble.com/search/all?q=${GEN_SEARCH}&sort=date&section=sort"
		_RUMBLE_PAGE=$(wget -q -O - ${QRY})
	elif [[ ${QRY_TYPE} == 'user' ]];then
		msg_box -c "Requesting <c><I>livestream user<N> search..."
		QRY="https://rumble.com/user/${_QUERY_OPTS[QKEY]}/livestreams"
		_RUMBLE_PAGE=$(wget -q -O - ${QRY})
	fi

	[[ -n ${GEN_SEARCH} ]] && GEN_SEARCH='g'
	parse_rumble ${GEN_SEARCH}

	if [[ ${?} -ne 0 ]];then
		logit ${_YT_DBG_LOG} "${0}: Search returned no rows - QKEY:${_QUERY_OPTS[QKEY]}"
		return 1
	else
		return 0
	fi
}

query_youtube () {
	local -a WORK_LIST=()
	local -A YOUTUBE_MAP=("age" 1 "author" 2 "title" 3 "url" 4 "time" 5 "agetime" "1,5")
	local AGE AUTHOR TITLE URL TIME AGETIME
	local DATA=false
	local HIT=false
	local LINE=''
	local NDX=0
	local PROXY_CMD=''
	local STR=''
	local F

	ping -w1 www.youtube.com >/dev/null
	[[ ${?} -ne 0 ]] && msg_box -p -PK "YouTube is down" && return 1

	logit ${_YT_DBG_LOG} "${0}: Creating listing for QKEY:${_QUERY_OPTS[QKEY]} STRICT:${_QUERY_OPTS[STRICT]}"

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@} ARGV:${@}"

	if [[ ${_QUERY_OPTS[STRICT]} == 'true' ]];then # Strict requested
		[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} ${CYAN_FG}STRICT FILTER ACTIVE${RESET}"
		g_PROXY_CMD="node ${_JS_SCRIPT} -s ${(qqq)_QUERY_OPTS[QKEY]}"
	else
		[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} ${CYAN_FG}NON-STRICT FILTER ACTIVE${RESET}"
		g_PROXY_CMD="node ${_JS_SCRIPT} -a recent ${(qqq)_QUERY_OPTS[QKEY]}"
	fi

	if [[ ${_DEBUG} -ge ${_LOW_DBG} ]];then
		dbg "${0}:${LINENO} ${CYAN_FG}_QUERY_OPTS[QKEY]${RESET}:${_QUERY_OPTS[QKEY]}, {CYAN_FG}g_PROXY_CMD${RESET}:${g_PROXY_CMD}"
	fi

	logit ${_YT_DBG_LOG} "${0}: QKEY:${_QUERY_OPTS[QKEY]}, g_PROXY_CMD:${g_PROXY_CMD}"

	_LOCAL_LIST=()

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} ${CYAN_FG}GENERAL SEARCH${RESET}"

	NDX=0
	while read LINE;do
		[[ ${LINE:l} =~ 'matched' ]] && DATA=true && continue

		[[ ${LINE:l} =~ 'usage' && ${DATA} != 'true' ]] && exit_leave
		[[ ${LINE:l} =~ 'error' && ${DATA} != 'true' ]] && exit_leave $(err_msg_exit E "${PROXY_CMD} returned an error")

		((NDX++))
		[[ ${LINE:l} =~ 'rejected' ]] && _REJECTS[${NDX}]=true || _REJECTS[${NDX}]=false

		STR=$(str_to_ascii <<<${LINE}) # Scrub non ascii
		STR=${STR:s/Streamed //} # Strip age of excess text

		if [[ ${_QUERY_OPTS[STRICT]} == 'false' ]];then # Apply filtering to non strict results
			HIT=false
			AUTHOR=$(cut -d'|' -f2 <<<${LINE}) && AUTHOR=$(str_to_ascii ${AUTHOR})
			TITLE=$(cut -d'|' -f3 <<<${LINE}) && TITLE=$(str_to_ascii ${TITLE})
			[[ ${TITLE:l} =~ ${_QUERY_OPTS[DKEY]:l} ]] && HIT=true
			[[ ${AUTHOR:l} =~ ${_QUERY_OPTS[DKEY]:l} ]] && HIT=true
			[[ ${AUTHOR:l} =~ ${_QUERY_OPTS[QKEY]:l} ]] && HIT=true
			[[ ${AUTHOR:gs/ //:l} =~ ${_QUERY_OPTS[QKEY]:l} ]] && HIT=true
			if [[ ${_DEBUG} -ge ${_MID_DBG} ]];then
				dbg "${0}:${LINENO} NON STRICT FILTERING, HIT:${HIT}"
				dbg "${0}:AUTHOR:${AUTHOR}, TITLE:${TITLE}_QUERY_OPTS[DKEY]:${_QUERY_OPTS[DKEY]}, _QUERY_OPTS[QKEY]:${_QUERY_OPTS[QKEY]}"
			fi
			[[ ${HIT} == 'false' ]] && continue
		fi
		 
		[[ ${_REJECTS[${NDX}]} == 'false' && ${DATA} == 'true' ]] && _LOCAL_LIST+=${STR}
	done< <(eval ${g_PROXY_CMD} 2>/dev/null)

	[[ ${_QUERY_OPTS[STRICT]} == 'true' ]] && _QUERY_OPTS[SMSG]="$(total_rejects ${NDX})" || _QUERY_OPTS[SMSG]=''

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} _LOCAL_LIST count: ${#_LOCAL_LIST}"
	[[ ${_DEBUG} -ge ${_MID_DBG} ]] && dbg "${0}:${LINENO} _LOCAL_LIST content:\n $(for L in ${_LOCAL_LIST};do echo ${L};done)"

	[[ ${_SMCUP} == 'false' ]] && do_smcup

	# Search failed
	if ! arr_is_populated "${_LOCAL_LIST}";then
		g_PROXY_CMD=$(str_trim ${(Q)g_PROXY_CMD})
		if [[ ${_QUERY_OPTS[STRICT]} == 'true' ]];then
			msg_box -H2 -p -PK "<r>Query returned no rows<N>|<I>Strict filter is active<N>|<w>g_PROXY_CMD<N>:${g_PROXY_CMD}"
		else
			msg_box -H2 -p -PK "<r>Query returned no rows<N>|<w>g_PROXY_CMD<N>:${g_PROXY_CMD}"
		fi
		logit ${_YT_DBG_LOG} "${0}: Search returned no rows - QKEY:${_QUERY_OPTS[QKEY]}, STRICT:${_QUERY_OPTS[STRICT]}"
		return 1
	fi

	for F in ${_LOCAL_LIST};do
		AGE=$(cut -d'|' -f${YOUTUBE_MAP[age]} <<<${F})
		AUTHOR=$(cut -d'|' -f${YOUTUBE_MAP[author]} <<<${F})
		TITLE=$(cut -d'|' -f${YOUTUBE_MAP[title]} <<<${F}); TITLE=$(clean_title ${TITLE})
		if [[ ${AUTHOR} == 'blancolirio' ]];then # Weird problem workaraound - spanish titles on blancolirio
			if perl -wln -e "if (/\b.*[ae]ntes\b|\bll.*\b|\bel\b|\bya\b|\by\b|\bla\b|\bal\b|\bde\b|\bdel\b|\bque\b|\bpara\b|\bpor\b/) { exit 0 } else { exit 1 }" <<<${TITLE:l};then
				TITLE=$(echo ${TITLE} | trans -brief -no-pager -no-ansi -no-theme es:en 2>/dev/null)
				logit ${_YT_DBG_LOG} "${0}: Translated TITLE:${TITLE}"
			fi
		fi
		URL=$(cut -d'|' -f${YOUTUBE_MAP[url]} <<<${F})
		TIME=$(cut -d'|' -f${YOUTUBE_MAP[time]} <<<${F})
		AGETIME=$(cut -d'|' -f${YOUTUBE_MAP[agetime]} <<<${F});	AGETIME="(${AGETIME:s/|/ /})"
		WORK_LIST+="${AGE}|${AUTHOR}|${TITLE}|${URL}|${TIME}|${AGETIME}"
	done

	_LOCAL_LIST=(${WORK_LIST})

	return 0
}

set_final_fn () {
	local FN=${1}
	local NEW_FN=''

	logit ${_YT_DBG_LOG} "${0}: FN  IN:${FN}"

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: FN:${FN:t}"
	[[ -e ${_YTS_ERROR_LOG} ]] && /bin/rm -f ${_YTS_ERROR_LOG}

	NEW_FN=${FN:t:r:gs/_/ /} # Tail, no extension, swap underscore
	NEW_FN=$(clean_title ${NEW_FN}) # Strip problematic chars
	NEW_FN=$(str_word_clip ${NEW_FN} ${_MAX_FLEN}) # Limit length at word boundary
	NEW_FN=$(sed "s/${_QUERY_OPTS[QKEY]:l}/${_QUERY_OPTS[DKEY]}/I" <<<${NEW_FN}) # Add creator
	NEW_FN=$(perl -pe 's/\.$//g' <<<${NEW_FN}) # Kill any trailing dots
	NEW_FN="$(str_trim ${FN:h}/${NEW_FN}).${FN:e}" # Restore path and extension

	if [[ ${FN} != ${NEW_FN} ]];then
		[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: Saving changes:${FN:t} -> ${NEW_FN:t}"
		logit ${_YT_DBG_LOG} "${0}: Overwriting file:${FN:t} with:${NEW_FN:t}"
		mv -f "${FN}" "${NEW_FN}" 2>> ${_YTS_ERROR_LOG} # Write any changes
		[[ ${?} -ne 0 ]] && echo "${0}: Move failed ${FN} to ${NEW_FN}" >> ${_YTS_ERROR_LOG}
	fi

	logit ${_YT_DBG_LOG} "${0}: FN OUT:${NEW_FN}"

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: Cleaned:${FN:t}"
}

set_item_color () {
	local ITEM=${1}

	[[ ${_DEBUG} -ge ${_MID_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	case ${ITEM:l} in
		downloaded*) echo ${BOLD}${GREEN_FG};;
		cancelled*) echo ${BOLD}${ITALIC}${RED_FG};;
		failed*) echo ${BOLD}${RED_FG};;
		future*) echo ${BOLD}${CYAN_FG};;
		partial*) echo ${WHITE_ON_GREY};;
		*) echo '';;
	esac
}

set_query_opts () {
	local ENGINE=''
	local ENG_OPT=''
	local KEY=''
	local MENU_CODE=''
	local OPTS=''
	local TYPE=''
	local VAL=''

	VAL=${_FAV_LIST[${_QUERY_OPTS[FKEY]}]}
	[[ -z ${VAL} ]] && msg_box -p -PK "<r>${0} Error<N>|Unable to locate:${_QUERY_OPTS[FKEY]} in favorites" && return 1

	KEY=$(cut -d: -f1 <<<${VAL})
	OPTS=$(cut -d: -f2 <<<${VAL})
	MENU_CODE=${OPTS[1]:l}

	TYPE=standard
	if [[ ${MENU_CODE} == 'c' ]];then
		TYPE=custom
		ENGINE=${OPTS[2]}
		ENG_OPT=${OPTS[3]}
	else
		ENGINE=${OPTS[1]}
		ENG_OPT=${OPTS[2]}
	fi

	case ${ENGINE:l} in
		y) ENGINE=youtube;;
		r) ENGINE=rumble;TYPE=standard;;
	esac

	_QUERY_OPTS[QKEY]=${KEY}
	_QUERY_OPTS[TYPE]=${TYPE}
	_QUERY_OPTS[ENGINE]=${ENGINE}
	_QUERY_OPTS[RQT]=${ENG_OPT:l}
}

strip_unwanted () {
	local LINE
	while read -r LINE;do
		[[ -z ${LINE} ]] && continue
		[[ ${LINE} =~ '^[Vv]erified$' ]] && continue
		[[ ${LINE} =~ '^LIVE$' ]] && continue
		LINE=$(tr -d '\011' <<< ${LINE})
		LINE=$(tr -d '\012' <<< ${LINE})
		LINE=$(sed 's/|/#/g' <<< ${LINE})
		LINE=$(iconv -c -f UTF-8 -t ASCII <<<${LINE} 2>/dev/null) # Convert UTF-8
		LINE=$(html2text -width 500 -ascii <<<${LINE} 2>/dev/null) # Convert any HTML 
		str_trim <<< ${LINE}
	done
}

total_rejects () {
	local TL_VIDS=${1}
	local TL_RJ=0
	local -F1 RJ_PCT=0
	local K

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	for K in ${(k)_REJECTS};do
		[[ ${_REJECTS[${K}]} == 'true' ]] && ((TL_RJ++))
	done

	TL_VIDS=${TL_VIDS}.00
	TL_RJ=${TL_RJ}.00

	[[ ${TL_RJ} -ne 0 ]] && RJ_PCT=$(( (TL_RJ/TL_VIDS) * 100 ))

	echo "${RJ_PCT}%"
}

website () {
	case ${1} in
		y) firefox "https://www.youtube.com/feed/subscriptions" >/dev/null 2>&1 &;;
		r) firefox "https://www.rumble.com/subscriptions" >/dev/null 2>&1 &;;
		*) exit_leave $(err_msg_exit E "Enter y for YouTube, r for Rumble")
	esac
}

#--Begin GetOpts--
read -r -d '' DESC<<EOF
Query either Youtube or Rumble for videos.
\tChoose from a list of matching videos. 
\tHidden key: 'r(eset) or k(ill)' during download will cancel the download.
EOF

opt_type () {
	local OPT=${1}
	case ${OPT} in
		a) echo "<AGE_FILTER> [all,recent,min,hour,day,week,month,year]";;
		s) echo "<SEARCHTERM>";;
		w) echo "<y:youtube, r:rumble>";;
		u) echo "<URL>";;
	esac
}

parse_opts () {
	local OPTS=${@}
	local -a OPTSTR
	local O

	for O in {1..${#OPTS}};do
		[[ ${O} -eq 1 && ${OPTS[${O}]} == ":" ]] && continue
		[[ ${O} -gt 1 && ${OPTS[${O}]} == ":" ]] && OPTSTR+="<PARAM>" && continue
		OPTSTR+="-${OPTS[${O}]}"
	done
	echo ${OPTSTR}
}

usage () {
	local OPTS=$(parse_opts ${OPTSTR})
	local -a PENDING_MSGS=(${@})

	tabs 5
	[[ ${_SMCUP} == 'true' ]] && do_rmcup

	(
	echo -e "\n${WHITE_FG}Usage${RESET}: ${_SCRIPT} ${OPTS} [$(opt_type s)]\n"
	echo -e "${WHITE_FG}-H${RESET} help"
	echo -e "${WHITE_FG}-D${RESET} debug"
	echo -e "${WHITE_FG}-R${RESET} ${MAGENTA_FG}Rumble${RESET} query [${WHITE_FG}default ${MAGENTA_FG}YouTube${RESET}]"
	echo -e "${WHITE_FG}-T${RESET} query type (l)ive, (c)hannel, (u)ser livestream, (g)eneral [${WHITE_FG}default${RESET}]  (${MAGENTA_FG}Rumble${RESET} only)"
	echo -e "${WHITE_FG}-V${RESET} yt-search version (${MAGENTA_FG}YouTube${RESET} only)"
	echo -e "${WHITE_FG}-a${RESET} $(opt_type a) (${MAGENTA_FG}YouTube${RESET} only)"
	echo -e "${WHITE_FG}-s${RESET} enable strict filter [author must match query] (${MAGENTA_FG}YouTube${RESET} only)"
	echo -e "${WHITE_FG}-u${RESET} export the video URL"
	echo -e "${WHITE_FG}-w${RESET} $(opt_type w) Goto website (y/r)"
	echo -e "\n${WHITE_FG}DESC${RESET}:${DESC}"
	) >&2

	exit_leave ${PENDING_MSGS}
}

OPTSTR=":HDRT:Va:sw:"
OPTIND=0

HELP_OPT=false
VERSION_OPT=false
WEB=''
RUMBLE_QTYPE=''
_QUERY_OPTS[STRICT]=false
_QUERY_OPTS[ENGINE]=youtube
_QUERY_OPTS[RQT]=''

while getopts ${OPTSTR} OPTION;do
	case $OPTION in
     H) HELP_OPT=true;;
     D) dbg_set_level;;
     R) _QUERY_OPTS[ENGINE]=rumble;;
     T) RUMBLE_QTYPE=${OPTARG:u};;
     V) VERSION_OPT=true;;
     a) AGE=${OPTARG};;
     s) _QUERY_OPTS[STRICT]=true;;
     w) WEB=${OPTARG};;
    \?) exit_leave "${RED_FG}Error${RESET}: ${BOLD}${RED_FG}Unknown option${RESET} -${OPTARG}";;
	  :) exit_leave "${RED_FG}Error${RESET}: option -${OPTARG} requires an argument${RESET}";;
	esac
	[[ ${OPTION} != 'D' ]] && OPTIONS+=${OPTION}
done
shift $(( OPTIND  - 1 ))
#--End GetOpts--

# Execution
CFG_MSG=$(cfg_init)
if [[ ${?} -ne 0 ]];then
	exit_leave "Configuration failed:${CFG_MSG}"
fi

[[ -n ${WEB} ]] && website ${WEB} && exit_leave

[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "ARGS IN:${@}, _QUERY_OPTS[ENGINE]:${_QUERY_OPTS[ENGINE]}"

RAWPATH=$(path_get_raw)
FPATH=$(cut -d'|' -f1 <<<${RAWPATH})
FGLOB=$(cut -d'|' -f2 <<<${RAWPATH})
PATHLBL=$(path_get_label 40)

SEARCHTERM=''
typeset -a STERMS=()

# Remove options 
RCL=$(path_get_raw_cmdline | sed "s/${_SCRIPT}//")
for X in ${=RCL};do
	[[ ${X} =~ '[-]' ]] && continue
	STERMS+=${X}
done
SEARCHTERM=$(str_trim ${STERMS})
_QUERY_OPTS[QKEY]=${SEARCHTERM} # Searchterm

# Validate/marshall options per engine
if [[ ${_QUERY_OPTS[ENGINE]} == 'youtube' ]];then
   if [[ ${HELP_OPT} == 'true' ]];then
		echo "${MAGENTA_FG}$(str_unicode_line 70)${RESET}"
		echo "YouTube backend:${WHITE_ON_GREY}${_JS_SCRIPT}${RESET}\n"
		eval "node ${_JS_SCRIPT} -h" >&2
		echo "\n${MAGENTA_FG}$(str_unicode_line 70)${RESET}"
		echo -n "YouTube frontend:${WHITE_ON_GREY}${_SCRIPT}${RESET}\n"
		usage
		exit_leave
	elif [[ ${VERSION_OPT} == 'true'  ]];then
		echo -n "yt-search version:${WHITE_FG}"
		node ${_JS_SCRIPT} --version
		echo ${RESET}
		exit_leave
		[[ ${?} -ne 0 ]] && exit_leave "${RED_FG}Invalid argument${RESET} - valid age arguments: ${WHITE_FG}all,min,day,week,month,year${RESET}"
	elif [[ ${_QUERY_OPTS[STRICT]} == 'true' ]];then
		SEARCHTERM="-s ${(qqq)SEARCHTERM}"
	elif [[ -n ${RUMBLE_QTYPE} ]];then
		exit_leave $(err_msg_exit E "Option:-T is a Rumble only option")
	fi
	g_PROXY_CMD="node ${_JS_SCRIPT} ${(qqq)SEARCHTERM}"
else
	if [[ -n ${RUMBLE_QTYPE} ]];then
		${_RUMBLE_QRY_OPTS[(i)${RUMBLE_QTYPE:l}]} -gt ${#_RUMBLE_QRY_OPTS} ]] && exit_leave "Invalid query type:${RUMBLE_QTYPE}"
	else
		RUMBLE_QTYPE='g' # Default
	fi
	if [[ ${VERSION_OPT} == 'true'  ]];then
		exit_leave $(err_msg_exit E "Option:-V is a YouTube only option")
	elif [[ -n ${AGE} ]];then
		exit_leave $(err_msg_exit E "Option:-a is a YouTube only option")
	elif [[ ${_QUERY_OPTS[STRICT]} == 'true' ]];then
		exit_leave $(err_msg_exit E "Option:-s is a YouTube only option")
	fi
fi

# Check for updates
g_LAST_CODE_UPD=$(last_code_update ${_YTS_UPD_MARKER})
if [[ (! -f ${_YTS_UPD_MARKER}) || (-f ${_YTS_UPD_MARKER} && (! ${g_LAST_CODE_UPD:l} =~ 'today')) ]];then
	clear
	msg_box "Checking for yt-dlp updates..."
	{
		CUR_VER=$(yt-dlp --version)
		yt-dlp -U
		touch ${_YTS_UPD_MARKER}
		UPD_VER=$(yt-dlp --version)
	} >/dev/null 2>&1
	if [[ ${CUR_VER} == ${UPD_VER} ]];then
		MSG="yt-dlp is <g>CURRENT<N> at version:<r>${CUR_VER}<N>"
		msg_box -c -t2 ${MSG}
	else
		MSG="yt-dlp was <w>Updated<N> from: <r>${CUR_VER}<N> to <g>${UPD_VER}<N>"
		msg_box -c -t2 ${MSG}
	fi
fi

# Set callbacks
log_update # Update the log
clear

# Load favorites
if ! fav_load;then
	exit_leave "Unable to load favorites"
fi

# Load acromyns
if ! acronym_load;then
	exit_leave "Unable to load acronyms"
fi

# Run Query
do_smcup
if [[ ${#} -eq 0 ]];then # NO args passed - select from menu
	while true;do
		if fav_get;then
			set_query_opts
			if [[ -n ${_QUERY_OPTS[QKEY]} ]];then
				msg_box "Querying ${_QUERY_OPTS[ENGINE]} for <B><I>${_QUERY_OPTS[DKEY]}<N>..."
				query_${_QUERY_OPTS[ENGINE]} # Call the extractor
				if [[ ${?} -eq 0 ]];then
					download_select ${_QUERY_OPTS[QKEY]}
				fi
			else
				msg_box -p -PK "Failed to set query options|$(msg_list_data $(for K in ${(k)_QUERY_OPTS};do echo "${K}:${(qqq)_QUERY_OPTS[${K}]}";done))"
			fi
		fi
	done
else # Args passed
	g_CMDLINE_ARGS=true
	_QUERY_OPTS[QKEY]="${@}"
	_QUERY_OPTS[DKEY]="${(C)@:gs/_/ /}"
	_QUERY_OPTS[TYPE]=standard # Menu type is either Y or R; not C
	if [[ ${_QUERY_OPTS[ENGINE]} == 'rumble' ]];then
		_QUERY_OPTS[ECODE]="R"
		_QUERY_OPTS[RQT]=${RUMBLE_QTYPE}
	else
		_QUERY_OPTS[ECODE]="Y"
	fi

	query_${_QUERY_OPTS[ENGINE]} # Call query

	if [[ ${?} -eq 0 ]];then # Inspect query status
		download_select ${_QUERY_OPTS[QKEY]}
		[[ ${g_CMDLINE_ARGS} == 'true' ]] && fav_add
	else
		exit_leave "Query failed for:${_QUERY_OPTS[QKEY]}"
	fi
fi

log_clear "normal exit"

exit_leave
