#!/usr/bin/zsh
 
# Inline ansi
BOLD="\033[1m"
ITALIC="\033[3m"
RESET="\033[m"
REVERSE="\033[7m"
STRIKE="\033[9m"
UNDER="\033[4m"
BLACK_BG="\033[40m"
BLUE_FG="\033[34m"
CYAN_FG="\033[36m"
GREEN_FG="\033[32m"
MAGENTA_FG="\033[35m"
RED_FG="\033[31m"
WHITE_FG="\033[37m"
YELLOW_FG="\033[33m"
WHITE_ON_GREY="\033[0m\033[0;1;37;100m"

# Imports
[[ -z ${ZSH_LIB_DIR} ]] && _LIB_DIR=/usr/local/lib || _LIB_DIR=${ZSH_LIB_DIR}
source ${_LIB_DIR}/LIB_INIT.zsh
source ${_LIB_DIR}/PATH.zsh
source ${_LIB_DIR}/DATE.zsh
source ${_LIB_DIR}/UTILS.zsh
source ${_LIB_DIR}/SELECT.zsh
source ${_LIB_DIR}/LIST.zsh
source ${_LIB_DIR}/LIB_DEPS.zsh

# Declarations
typeset -A _CONT_COORDS=()
typeset -A _ALERT_COORDS=()
typeset -A _BREAK_COORDS=()
typeset -A _DISPLAY_KEYS=()
typeset -A _DOWNLOADS=()
typeset -A _FAILED=()
typeset -A _FAVORITE_ENGINE=()
typeset -A _FAVORITE_OPTS=()
typeset -A _FIELD_LEN=()
typeset -A _FUTURE=()
typeset -A _PARTIALS=()
typeset -A _REJECTS=()
typeset -A _SEEN=()
typeset -A _SORT_TABLE=()
typeset -A _STATUS_MSGS=()
typeset -a _ACRONYMS=()
typeset -a _LOCAL_LIST=()

# Display Constants
_CONT_COORDS=(X 10 Y 33 H 10 W 86) # Continuous box coords
_ALERT_COORDS=(X $(( _CONT_COORDS[X] + 5 )) Y $(( _CONT_COORDS[Y] + _CONT_COORDS[W] - 25 ))) # Alerts display coords
_BREAK_COORDS=(X $((_CONT_COORDS[X] + 3 )) Y $((_CONT_COORDS[Y] + 3 )) W $((_CONT_COORDS[W] - 6 ))) # Break display coords

# Constants
_ACRONYMS_FN=/usr/local/etc/acronyms.txt
_YTS_DIR=~/.yts
_SRC_DIR=/usr/local/src
_ACTION=download
_ALERT_TM=.2
_CMD_LINE_ARGS=false
_DOWNLOAD_DIR=~/Downloads/Torrents/Library/web
_DOWNLOAD_LOG=${_YTS_DIR}/yts.downloads
_ERROR_LIMIT=5
_ERROR_LOG=/tmp/yts.err
_FIELD_LEN[age]=30
_FIELD_LEN[agetime]=40
_FIELD_LEN[author]=26
_FIELD_LEN[title]=80
_JS_SCRIPT=/usr/local/etc/yts.js
_MAX_ERRORS=10
_MAX_FLEN=85
_MAX_HDR=65
_MAX_TITLE=75
_OBJECT=video
_PAUSE_TM=2
_SORT_DEFAULT=(youtube 1:a rumble 1:a)
_UPD_MARKER=${_YTS_DIR}/yts-upd.lastrun
_YTS_DBG_LOG=/tmp/yt.dbg.log
_YTS_FAVORITES=${_YTS_DIR}/yts_favorites
_YTS_URL_LOG=/tmp/yts.url.log

# Globals
g_CUSTOM_LIST=false
g_DISPLAY_KEY=''
g_ENGINE_KEY=''
g_GOT_URL=false
g_LAST_CODE_UPD=?
g_LAST_MASK_Y=0
g_LIVE=''
g_LIVE_OPT=''
g_PID=?
g_PROXY_CMD=''
g_QRY_ENGINE=''
g_QUERY_KEY=''
g_SEARCH_TYPE=''
g_STRICT=false
g_STRICT_MSG=''
g_YTS_LOG=''
g_WHEN=''

# Functions
action_do () {
	local -a MSGS
	local AUTHOR=''
	local DEST=''
	local DEST_1=''
	local DEST_2=''
	local DL_CNT=0
	local EMSG=''
	local ERR=''
	local ERROR_CNT=0
	local ETA=''
	local ETA_COMPLETE=false
	local FRAME_PAD=4
	local HAD_ERROR=false
	local HDR1_TXT=0
	local HDR2_TXT=0
	local HDRS_OUT=false
	local HDR_LEN=0
	local HRZ_CTR=0
	local H_CTR=0
	local INFO_TAG=''
	local JOB_STALL=10
	local KEY=''
	local LAST_LOG_SIZE=0
	local LINE_COLOR=''
	local LOG_ACTIVE=false
	local LOG_LINE=''
	local LOG_SIZE=0
	local LOG_STALLS=0
	local MSG=''
	local NDX=0
	local OPENING=0
	local OTH=''
	local PID=0
	local RETRIES=0
	local RC1=0
	local RC2=0
	local SCAN_LIMIT=0
	local TITLE=''
	local URL=''
	local WAIT=0
	local L M S 

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	# Why this?
	for M in ${_MARKED};do
		list_set_selected ${M} ${_AVAIL_ROW}
	done

	for M in ${_MARKED};do
		((DL_CNT++))
		_DOWNLOADS[${DL_CNT}]=false
		_FAILED[${DL_CNT}]=false
		_FUTURE[${DL_CNT}]=false

		AUTHOR=$(get_field author ${M})
		TITLE=$(get_field title ${M})
		URL=$(get_field url ${M})

		logit ${_YTS_URL_LOG} ${AUTHOR}:${TITLE}:${URL}

		HDRS_OUT=false

		unsetopt localtraps # Initialize CTRL-C trap
		trap job_kill INT

		ERROR_CNT=0
		RETRIES=0
		job_start ${URL}
		msg_box -x${_CONT_COORDS[X]} -y${_CONT_COORDS[Y]} -h${_CONT_COORDS[H]} -w${_CONT_COORDS[W]} "Download requested..."
		sleep 3

		# Detect missing log
		if [[ ! -e ${g_YTS_LOG} ]];then
			[[ ${NDX} -gt 10 ]] && exit_leave "${g_YTS_LOG} not detected" # No activity
		fi

		ETA_COMPLETE=false
		while true;do
			((NDX++))
			
			# Handle job reset
			KEY=''
			read -s -t0.1 -k1 KEY
			if [[ ${KEY} == 'r' ]];then # Process job reset
				job_reset
				job_start ${URL}
				HAD_ERROR=false
				ERROR_CNT=0
			fi

			# Ensure log activity
			LOG_SIZE=$(wc -c < ${g_YTS_LOG})
			if [[ ${LOG_SIZE} -ne ${LAST_LOG_SIZE} ]];then
				LOG_STALLS=0 # Log is growing
			else
				((LOG_STALLS++))
				[[ ${LOG_STALLS} -ge ${JOB_STALL} ]] && msg_box -z -t${_ALERT_TM} -x${_ALERT_COORDS[X]} -y${_ALERT_COORDS[Y]} "<r>Job Stalled<N>"
				LAST_LOG_SIZE=${LOG_SIZE}
				sleep 1 # Extra sleep 
				continue
			fi

			# Scan for 'already been downloaded'
			LOG_LINE=$(grep -m1 -i "already been downloaded" ${g_YTS_LOG} 2>/dev/null)
			if [[ ${?} -eq 0 ]];then
				logit ${_YTS_DBG_LOG} "${0}: LOG_LINE:${LOG_LINE}"
				EMSG="<w>${TITLE[1,65]}<N>|<g>Has already been downloaded<N>" 
				msg_box -z -x ${_BREAK_COORDS[X]} -y ${_BREAK_COORDS[Y]} -w ${_BREAK_COORDS[W]} -t${_PAUSE_TM} "${EMSG}"
				_DOWNLOADS[${M}]=true
				break # Scan cycle
			fi

			# Scan for 'not yet available'
			LOG_LINE=$(grep -m1 -i "will begin\|premieres\|upcoming" ${g_YTS_LOG} 2>/dev/null)
			if [[ ${?} -eq 0 ]];then
				logit ${_YTS_DBG_LOG} "${0}: LOG_LINE:${LOG_LINE}"
				EMSG="<w>${TITLE[1,65]}<N>|<r>Not yet available<N>|<g>${LOG_LINE}<N>"
				[[ ! ${LOG_LINE} =~ 'minute*|hour*|day*' ]] && g_WHEN='soon' || g_WHEN=$(perl -pe 's/^(.*) in (\d+\s+\w+)(.*)$/\2/g' <<<${LOG_LINE})
				msg_box -z -x ${_BREAK_COORDS[X]} -y ${_BREAK_COORDS[Y]} -w ${_BREAK_COORDS[W]} -t${_PAUSE_TM} "${EMSG}"
				_FUTURE[${M}]=true
				_DOWNLOADS[${M}]=false
				break # Scan cycle
			fi

			# Scan for 'unable to download'
			LOG_LINE=$(grep -m1 -i "unable to download video" ${g_YTS_LOG} 2>/dev/null)
			if [[ ${?} -eq 0 ]];then
				logit ${_YTS_DBG_LOG} "${0}: LOG_LINE:${LOG_LINE}"
				EMSG="<w>${TITLE[1,65]}<N>|<r>Hard Error - Unable to download<N>"
				msg_box -z -x ${_BREAK_COORDS[X]} -y ${_BREAK_COORDS[Y]} -w ${_BREAK_COORDS[W]} -t${_PAUSE_TM} "${EMSG}"
				_FAILED[${M}]=true
				_DOWNLOADS[${M}]=false
				_EXIT_SCRUB=false # Trigger log retention
				break # Scan cycle
			fi

			# Scan for 'resumed'
			INFO_TAG=''
			LOG_LINE=$(grep -m1 -i "resuming download" ${g_YTS_LOG} 2>/dev/null)
			if [[ ${?} -eq 0 ]];then
				logit ${_YTS_DBG_LOG} "${0}: LOG_LINE:${LOG_LINE}"
				INFO_TAG=' (<w>resumed<N>)'
			fi

			# Audio fix mode
			INFO_TAG=''
			if [[ ${g_FIX_AUDIO} == 'true' ]];then
				INFO_TAG=' (<w>Audio Fix Mode<N>)'
			fi

			# Process headers
			LOG_LINE=$(grep -m1 -i "destination" ${g_YTS_LOG} 2>/dev/null)
			if [[ ${?} -eq 0 && ${HDRS_OUT} == 'false' ]];then
				DEST=("${(f)$(sed -e "s#${_DOWNLOAD_DIR}/#${_DOWNLOAD_DIR}|#g" -e 's/ \[.*//g' <<<${LOG_LINE})}") # Strip path
				DEST_1=$(cut -d'|' -f1 <<<${DEST})
				DEST_1=$(cut -d']' -f2- <<<${DEST_1} | sed -e "s/^[[:space:]]/<w>/" -e "s/:/<N>:<m>/")
				HDR1_TXT=$(cut -d'|' -f2 <<<${DEST:r} | sed 's/_/ /g') # Clear space fillers and file extension
				HDR1_TXT="<w>Downloading<N>:<m> <c>$(clean_title "text" ${HDR1_TXT[1,${_MAX_HDR}]})<N>"
				HDR2_TXT="$(str_trim ${DEST_1})<N> - <w>${DL_CNT} <N>of <w>${#_MARKED}<N>${INFO_TAG}"
				HDR_LEN=$(( ${#$(msg_nomarkup ${HDR2_TXT})} ))
				HDR_LEN=$((HDR_LEN + FRAME_PAD + 4))
				HRZ_CTR=$(coord_center $((_MAX_COLS-3)) ${HDR_LEN}) # Horiz center
				[[ ${HDR_LEN} -gt ${_CONT_COORDS[W]} ]] && _CONT_COORDS[W]=${HDR_LEN} && _CONT_COORDS[Y]=${HRZ_CTR} # Adjust frame width/center
				msg_box -c -C -I -H3 -jl -x${_CONT_COORDS[X]} -y${_CONT_COORDS[Y]} -h${_CONT_COORDS[H]} -w${_CONT_COORDS[W]} ${HDR1_TXT}
				msg_box -C -jl ${HDR2_TXT}
				msg_box -C -jl "<c>$(str_unicode_line $((_CONT_COORDS[W]-4)))<N>" # Divider line
				HDRS_OUT=true
			fi

			LOG_LINE=$(sed -e 's//\n/g' -e '/./!d' ${g_YTS_LOG} | tail -1 | str_trim) 

			if grep -qi 'chunklist' <<<${LOG_LINE} 2>/dev/null;then # Block live braodcasts
				msg_box -p -PK "<r>Warning<N>This is an ongoing live broadcast|Not suitable for download"
				job_kill
				break # Scan cycle
			fi
			
			ETA='' && ERR='' && OTH=''
			if grep -qi 'eta.*error' <<<${LOG_LINE} 2>/dev/null;then # Contains both - split
				ETA=$(sed -E 's/([0-9])(\[.*)/\1\n\2/g' <<<${LOG_LINE} | head -1 | str_trim)
				ERR=$(sed -E 's/([0-9])(\[.*)/\1\n\2/g' <<<${LOG_LINE} | tail -1 | str_trim)
			elif grep -qi 'opening' <<<${LOG_LINE} 2>/dev/null;then # Contains both - split
				((OPENING++))
				[[ ${OPENING} -gt 4 ]] && ERR="hung connection" && OPENING=0
			elif grep -qi 'eta.*unknown' <<<${LOG_LINE} 2>/dev/null;then # Contains both - split
				logit ${_YTS_DBG_LOG} "${0}: LOG_LINE:${LOG_LINE}"
				continue # Skip
			elif grep -q 'ETA' <<<${LOG_LINE} 2>/dev/null;then # Uppercase ETA
				logit ${_YTS_DBG_LOG} "${0}: GOT ETA:${LOG_LINE}"
				ETA=${LOG_LINE}
			elif grep -qi 'error' <<<${LOG_LINE} 2>/dev/null;then
				logit ${_YTS_DBG_LOG} "${0}: GOT ERROR:${LOG_LINE}"
				ERR=${LOG_LINE}
			elif grep -qi 'Fixing MPEG-TS' <<<${LOG_LINE} 2>/dev/null;then
				logit ${_YTS_DBG_LOG} "${0}: GOT Fragmented completion:${LOG_LINE}"
				ETA="100% of download completed"
			else
				logit ${_YTS_DBG_LOG} "${0}: GOT OTHER:${LOG_LINE}"
				OTH=${LOG_LINE}
			fi

			HAD_ERROR=false
			if [[ -n ${ERR} ]];then
				((ERROR_CNT++))
				msg_box -z -T ALERT -t${_ALERT_TM} -x${_ALERT_COORDS[X]} -y${_ALERT_COORDS[Y]} "<r>Network Errors<N>:<w>${ERROR_CNT}<N>"
				HAD_ERROR=true
				sleep 2
				if [[ ${ERROR_CNT} -ge ${_MAX_ERRORS} ]];then
					EMSG="<w>${TITLE[1,65]}<N>|<r>Hard error - Unable to download<N>"
					msg_box -z -x ${_BREAK_COORDS[X]} -y ${_BREAK_COORDS[Y]} -w ${_BREAK_COORDS[W]} -t${_PAUSE_TM} "${EMSG}"
					job_reset
					_FAILED[${M}]=true && break # Scan cycle
				fi
			fi

			if [[ -n ${OTH} ]];then
				case ${OTH:l} in
					*rumbleembed*) continue;;
					*merging*) continue;; # Audio fix
					*'deleting original'*) ETA='Audio/Video combined 100%'; LINE_COLOR='<B><g>';; # Audio fix
					*100%*) ETA=${OTH};;
				esac
			fi

			LINE_COLOR=''
			if [[ -n ${ETA} && ${ETA_COMPLETE} == 'false' ]];then
				ERROR_CNT=0 
				download_indicator ${ETA}
				case ${ETA:l} in
					*100*%*) LINE_COLOR='<B><g>';ETA_COMPLETE=true;;; # Stop parsing ETA
					*mib/s*) LINE_COLOR='<w>';;
					*kib/s*) LINE_COLOR='<B><y>';;
					*) continue;; # Skip other
				esac
			else
				continue # Uncaptured line
			fi

			[[ ${HAD_ERROR} == 'true' ]] && LINE_COLOR='<r>'

			logit ${_YTS_DBG_LOG} "${0}: ${LINE_COLOR}${ETA}"
			msg_box -C -jl "${LINE_COLOR}${ETA[1,59]}<N>" # Show progress

			if [[ ${ETA} =~ '100% of' || ${ETA_COMPLETE} == 'true'  ]];then
				if [[ ${#_MARKED} -gt 1 ]];then
					msg_box -C -jc "<m>$(str_unicode_line 10)<N>"
					if [[ $((${#_MARKED}-DL_CNT)) -gt 0 ]];then
						MSG="Download ${DL_CNT} completed - $(( ${#_MARKED} - DL_CNT )) remaining"
						msg_box -z -t${_PAUSE_TM} -x$(( _CONT_COORDS[X] + 4 )) -y$(box_center ${MSG}) ${MSG}
					fi
				fi
				_DOWNLOADS[${M}]=true
				post_process
				log_add ${M}
				break # Scan cycle
			fi # Monitor progress
			sleep 1 # Log fetch delay
		done # Log scan complete
		NDX=0
		log_clear "action_do"
		sleep 1 # Job request delay
	done # List complete

	for M in ${_MARKED};do
		[[ ${_DOWNLOADS[${M}]} == 'true' ]] && list_set_selected ${M} ${_STALE_ROW} || list_set_selected ${M} ${_AVAIL_ROW}
	done

	_MARKED=()
	
	trap - INT # Downloads are finished; cancel trap
	return 0
}

action_warn () {
	local M
	
	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	msg_box -H1 -x${_CONT_COORDS[X]} -p -PG "<w><I>Please respond<N>|<Z>|${#_MARKED} $(str_pluralize ${_OBJECT} ${#_MARKED}) selected"

	if [[ ${_MSG_KEY} == 'n' ]];then
		for M in ${_MARKED};do
			_MARKED[${M}]=0
			list_set_selected ${M} ${_AVAIL_ROW}
		done
	fi
}

box_center () {
	local TXT=${@} # Text to center
	local BOX=4 # Compensate for box border
	local BOX_CTR=0
	local BOX_LEFT=${_CONT_COORDS[Y]} # Left coord
	local BOX_WIDTH=${_CONT_COORDS[W]} # Width coord
	local CTR=0
	local REM=0
	local TXT_CTR=0
	local TXT_LEN=$(( ${#TXT} + BOX )) # Text length

	CTR=$(( TXT_LEN / 2 )) && REM=$((CTR % 2))
	[[ ${REM} -ne 0 ]] && TXT_CTR=$((CTR+1)) || TXT_CTR=${CTR}

	CTR=$(( BOX_WIDTH / 2 )) && REM=$((CTR % 2))
	[[ ${REM} -ne 0 ]] && BOX_CTR=$((CTR+1)) || BOX_CTR=${CTR}

	echo $(( BOX_LEFT + BOX_CTR - TXT_CTR ))
}

clean_title () {
	local TYPE=${1}
	local TITLE=${2}
	local STR=''
	local -A SEEN=()
	local -a UCASE_WORDS=()
	local UCASE_LIMIT=4
	local W U

	logit ${_YTS_DBG_LOG} "${0}: TITLE:${TITLE}"

	STR=$(html2text -width ${_MAX_COLS} -ascii <<<${TITLE}) # Convert any HTML 
	[[ ${TITLE} != ${STR} ]] && logit ${_YTS_DBG_LOG} "${0}: HTML -> ascii:${STR}"

	TITLE=${STR}
	STR=$(tr '\n' ' ' <<<${STR}) # html2text can insert a newline if STR exceeds --width
	[[ ${TITLE} != ${STR} ]] && logit ${_YTS_DBG_LOG} "${0}: Strip newline:${STR}"

	TITLE=${STR}
	STR=$(sed 's/[ _]\(d\|l\|s\|t\|re\|ve\)[ _]/\o047\1 /Ig' <<<${STR}) # Fix any yt-dlp contraction gaps
	[[ ${TITLE} != ${STR} ]] && logit ${_YTS_DBG_LOG} "${0}: Contraction gap:${STR}"
	 
	TITLE=${STR}
	STR=$(sed 's/[ _][Ww][ _]/ with /g' <<<${STR}) # Fix any yt-dlp W/ gaps
	[[ ${TITLE} != ${STR} ]] && logit ${_YTS_DBG_LOG} "${0}: w/ (with):${STR}"
	 
	UCASE_WORDS=("${(f)$(tr -dc '[:alnum:][ \-]' <<<${STR} | grep -E -o -- '\b([[:upper:]]|[0-9])+\b')}") # Allow alpha,digits, and hyphen
	for U in ${UCASE_WORDS};do
		[[ ${U%%[!0-9]*} ]] && UCASE_WORDS=("${(@)UCASE_WORDS:#${U}}") # Dump numbers
	done
	[[ -n ${UCASE_WORDS} ]] && logit ${_YTS_DBG_LOG} "${0}: UCASE_WORDS:${UCASE_WORDS}"

	TITLE=${STR}
	STR=$(perl -pe  's/\o{47}(?![rstv].?\b)//g' <<<${STR}) # Remove any sentence quotes, leave contractions
	[[ ${TITLE} != ${STR} ]] && logit ${_YTS_DBG_LOG} "${0}: Sentence quotes:${STR}"

	TITLE=${STR}
	STR=$(sed -E -e 's/^[[:blank:]]*//' -e 's/[[:blank:]]*$//' -e 's/(\S)([-])(\S)/\1 \3/g' <<<${STR}) # Trim
	[[ ${TITLE} != ${STR} ]] && logit ${_YTS_DBG_LOG} "${0}: Trim and separate hyphenated words:${STR}"
	 
	TITLE=${STR}
	STR=${(C)STR} # Proper case
	[[ ${TITLE} != ${STR} ]] && logit ${_YTS_DBG_LOG} "${0}: Proper case:${STR}"

	TITLE=${STR}
	STR=$(sed 's/\(\o047\)\([A-Z]\)/\1\L\2/g' <<<${STR}) # Fix proper case anonmaly: UC letter following apostrophe
	[[ ${TITLE} != ${STR} ]] && logit ${_YTS_DBG_LOG} "${0}: UC letter following apostrophe:${STR}"

	for W in ${=STR};do
		W=$(tr -dc '[:alnum:][\047]' <<<${W}) # Strip other than alpha,digits,single quotes, and hyphen
		[[ ${SEEN[${W}]} -eq 1 ]] && continue # Skip seen
		if [[ ${_ACRONYMS[(i)${W:u}]} -le ${#_ACRONYMS} ]];then
			logit ${_YTS_DBG_LOG} "${0}: Found acronym:${W:u}"
			STR=$(sed "s/\b${W}\b/${W:u}/Ig" <<<${STR}) # Preserve acromyns
			SEEN[${W}]=1
		elif [[ -n ${#UCASE_WORDS} && ${#UCASE_WORDS} -le ${UCASE_LIMIT} ]];then # Retain orginal uppercased if not excessive
			if [[ ${UCASE_WORDS[(i)${W:u}]} -le ${#UCASE_WORDS} ]];then
				logit ${_YTS_DBG_LOG} "${0}: Found uppercase:${W:u}"
				STR=$(sed "s/\b${W}\b/${W:u}/Ig" <<<${STR}) 
				SEEN[${W}]=1
			fi
		fi
	done

	TITLE=${STR}
	case ${TYPE} in
		file) STR=${STR[1,${_MAX_FLEN}]};; # Filename
		text) STR=${STR[1,${_MAX_TITLE}]};; # Title
	esac
	[[ ${TITLE} != ${STR} ]] && logit ${_YTS_DBG_LOG} "${0}: TYPE:${TYPE} STR:${STR}"

	logit ${_YTS_DBG_LOG} "${0}: Final:${STR}"
	echo ${STR}
}

clear_tmp () {
	[[ -e /tmp/*$$*state ]] && rm -rf /tmp/*$$*state
}

download_indicator () {
	local LINE=${@}
	local MASK="\\u2B24"
	local L_A="🡄 "
	local R_A="🡆"
	local LINE_COLOR=''
	local X=$((_ALERT_COORDS[X]-3))
	local MASK_Y=5
	local DELAY=1

	X=$((X+3))
	if [[ ${g_LAST_MASK_Y} -eq 2 ]];then
		MASK_Y=6
		MASK=${R_A}
	else
		MASK_Y=2
		MASK=${L_A}
	fi

	case ${ETA:l} in
		*mib*) LINE_COLOR="${BOLD}${GREEN_FG}";;
		*kib*) LINE_COLOR="${BOLD}${YELLOW_FG}";;
	esac

 	tcup ${X} $((_ALERT_COORDS[Y] + g_LAST_MASK_Y + 6));echo -n "${LINE_COLOR} ${RESET}"
 	tcup ${X} $((_ALERT_COORDS[Y] + MASK_Y + 6));echo -n "${LINE_COLOR}${MASK}${RESET}";sleep ${DELAY}

	g_LAST_MASK_Y=${MASK_Y}
}

download_select () {
	local SEARCHTERM=${1}
	local SEARCHTYPE=''
	local L F
	local TITLE
	local FLST
	local STR

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"
	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} ${GREEN_FG}LOCAL_LIST COUNT${RESET}:${#_LOCAL_LIST}"

	SEARCHTYPE=Videos

	_SORT_TABLE=(1 1 2 2 3 3) # Age, author, title

	if [[ ${g_QRY_ENGINE:l} == 'rumble' ]];then
		[[ ${g_LIVE} == 'true' ]] && SEARCHTYPE=Live
	elif [[ ${g_QRY_ENGINE:l} == 'youtube' ]];then
		[[ ${g_STRICT} == 'true' ]] && SEARCHTYPE="Strict (${g_STRICT_MSG})"
	fi

 # Set headings
	list_set_header_init
	list_set_header 'printf "Found:${WHITE_FG}%-d${RESET} $(str_pluralize video ${#_LIST})\tPlatform:${WHITE_FG}%s${RESET}\tQuery Key:${WHITE_FG}%s${RESET}\tQuery Type:${WHITE_FG}%s${RESET}\tSelected:${WHITE_FG}%s${RESET}\t${_PG}" ${#_LIST} ${(C)g_QRY_ENGINE} ${(C)SEARCHTERM} ${(C)SEARCHTYPE} $(list_get_selected_count)'
	list_set_header 'printf " "'
	list_set_header 'printf "%*s %-*s %-*s %-*s" 5 "" ${_FIELD_LEN[age]} "Age" ${_FIELD_LEN[author]} "Author" ${_FIELD_LEN[title]} "Title"'
	list_set_header 'printf "%*s ${SCOL1_CLR}%-*s${RESET} ${SCOL2_CLR}%*s${RESET} ${SCOL3_CLR}%*s${RESET}" 5 "" ${_FIELD_LEN[age]} "$(str_unicode_line ${_FIELD_LEN[age]})" ${_FIELD_LEN[author]} "$(str_unicode_line ${_FIELD_LEN[author]})" ${_FIELD_LEN[title]} "$(str_unicode_line ${_FIELD_LEN[title]})"'

 # Set line item
	list_set_line_item ' 
	local ITEM_COLOR=$(set_item_color $(item_decorate ${_LIST_NDX}));
	printf "${BOLD}${WHITE_FG}%4s${RESET}${_MARKER} ${SHADE}${BAR}${ITEM_COLOR}%-${_FIELD_LEN[age]}s${RESET}${SHADE}${BAR} %-${_FIELD_LEN[author]}s %-${_FIELD_LEN[title]}s${RESET}\n" ${_LIST_NDX} "$(item_decorate ${_LIST_NDX})"  "$(get_field author ${_LIST_NDX})"  "$(get_field title ${_LIST_NDX})" 
	'

	list_set_select_action ${_ACTION}
	list_set_action_msgs video download
	list_set_sortable true
	list_set_searchable false
	list_set_barlines true
	list_set_page_callback log_find 
	list_set_sort_defaults ARRAY "_LIST" COL 1 ORDER "a" DELIM ${_LIST_DELIM} TYPE "flat" TABLE "${(kv)_SORT_TABLE}" MAXCOL 3
	list_set_restore_pos true

	while true;do
		# Generate list for selected title
		list_select ${_LOCAL_LIST}
		[[ ${?} -eq 0 ]] && break

		_MARKED=($(list_get_selected))
		
		if [[ $(list_get_selected_count) -ne 0 ]];then
			action_warn
			if [[ ${_MSG_KEY} == "y" ]];then
				action_do
			fi
			_LIST_SELECTED=()
		fi
	done

	_DOWNLOADS=()
	_FAILED=()
	_FUTURE=()
}

fav_delete () {
	local FAV=${1:gs/ /_/:l}
	local ENG=''
	local LINE
	local F1 F2 F3

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	cp ${_YTS_FAVORITES} ${_YTS_FAVORITES}.bak
	logit ${_YTS_DBG_LOG} "${0}: log ${_YTS_FAVORITES} was copied"

	[[ ${g_QRY_ENGINE} == 'rumble' ]] && ENG="R" || ENG="Y"
	logit ${_YTS_DBG_LOG} "${0}: engine:${g_QRY_ENGINE}"

	msg_box -p -PD "Deleting: ${FAV} for ${(C)g_QRY_ENGINE}?"
	logit ${_YTS_DBG_LOG} "${0}: deleting ${FAV} decoded to ${FAV}"

	if [[ ${_MSG_KEY} == 'y' ]];then
		if [[ -s ${_YTS_FAVORITES} ]];then
			[[ -e /tmp/favlist.new ]] && /bin/rm -f /tmp/favlist.new
			while read LINE;do
				F1=$(cut -d '|' -f1 <<<${LINE})
				F2=$(cut -d '|' -f2 <<<${LINE})
				F3=$(cut -d '|' -f3 <<<${LINE})
				[[ ${F1:l} == ${FAV} && ${F3:l} =~ ${ENG:l} ]] && continue
				echo ${LINE} >> /tmp/favlist.new
			done < ${_YTS_FAVORITES}
			diff -q /tmp/favlist.new ${_YTS_FAVORITES} >/dev/null 2>&1
			if [[ ${?} -eq 0 ]];then
				logit ${_YTS_DBG_LOG} "${0}: log ${_YTS_FAVORITES} was NOT updated - ${FAV} not found"
			else
				mv -f /tmp/favlist.new ${_YTS_FAVORITES}
				logit ${_YTS_DBG_LOG} "${0}: log ${_YTS_FAVORITES} updated"
				fav_load
			fi
		else
			exit_leave "No favorites have been saved"
		fi
	fi
}

fav_get () {
	local -a _DISPLAY_LIST=()
	local DKEY # Display key
	local EKEY # Engine key
	local HDR # List Header
	local FTR # List footer
	local MAP # List map
	local TAG=''
	local MSG=''
	local QKEY='' # Query key
	local O_COLOR=''
	local C_LIST=' '
	local F

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	while true;do
		_DISPLAY_LIST=()
		for F in ${(k)_DISPLAY_KEYS};do
			EKEY=${$(cut -d: -f1 <<<${_DISPLAY_KEYS[${F}]}):l}
			if [[ ${g_QRY_ENGINE} == 'rumble' ]];then
				if [[ ${EKEY} =~ 'r' ]];then
					_DISPLAY_LIST+=${F:gs/_/ /}
					_FAVORITE_ENGINE[${F}]=${EKEY}
					O_COLOR=${BLUE_FG}
					C_LIST=' '
				fi
			else
				if [[ ${EKEY} =~ 'y' ]];then
						if [[ ${g_CUSTOM_LIST} == 'true' ]];then
							if [[ ${EKEY} =~ 'p' ]];then
								_DISPLAY_LIST+=${F:gs/_/ /}
								_FAVORITE_ENGINE[${F}]=${EKEY:s/p//} # Strip custom marker
								O_COLOR=${RED_FG}
								C_LIST=" <I>(Custom List)<N> "
							fi
						else
							if [[ ! ${EKEY} =~ 'p' ]];then
								_DISPLAY_LIST+=${F:gs/_/ /}
								_FAVORITE_ENGINE[${F}]=${EKEY}
								O_COLOR=${MAGENTA_FG}
								C_LIST=' '
							fi
						fi
				fi
			fi
		done

		sel_set_list ${(o)_DISPLAY_LIST}
		sel_set_app_keys d l r y c

		clear

		[[ ${g_QRY_ENGINE} == 'rumble' && ${g_LIVE_OPT} == 'true' ]] && MSG=' (<c>livestreams toggled<w>)' || MSG=''

		HDR="${(C)g_QRY_ENGINE}${C_LIST}Query"
		MAP="(<w>r<N>)umble list, (<w>y<N>)outube list, (<w>c<N>)ustom list, (<w>d<N>)elete favorite"
		FTR="<w>Run ${(C)g_QRY_ENGINE} query${MSG} from history or <h>(q)uit<N>"
		TAG=$(tr -d '[:space:]' <<<${HDR})

		# Choose high level list item
		list_set_restore_pos_reset # Fresh list - position at top
		sel_list -S -T${TAG} -O${O_COLOR} -H"${HDR}" -M${MAP} -F${FTR}

		case ${_SEL_KEY} in
			d) fav_delete ${_SEL_VAL} && continue;;
			l) if [[ ${g_QRY_ENGINE} == 'rumble' ]];then
					[[ ${g_LIVE_OPT} == 'true' ]] && g_LIVE_OPT=false || g_LIVE_OPT=true
				else
					g_LIVE_OPT=true  # Livestream toggle only applies to Rumble
				fi
				continue
				;;
			r) g_QRY_ENGINE='rumble' && g_CUSTOM_LIST=false && continue;;
			y) g_QRY_ENGINE='youtube' && g_CUSTOM_LIST=false && continue;;
			c) g_QRY_ENGINE='youtube' && g_CUSTOM_LIST=true && continue;;
		esac
		[[ ${_SEL_VAL} != '?' ]] && break
	done

	g_QUERY_KEY=$(cut -d: -f2 <<<${_DISPLAY_KEYS[${_SEL_VAL:gs/ /_}]})
	g_ENGINE_KEY=$(cut -d: -f1 <<<${_DISPLAY_KEYS[${_SEL_VAL:gs/ /_}]})
	g_DISPLAY_KEY=${_SEL_VAL}
}

fav_load () {
	local LINE
	local DKEY
	local QKEY
	local QCODE

	_DISPLAY_KEYS=()

	while read LINE;do
		DKEY=$(cut -d'|' -f1 <<<${LINE})
		QKEY=$(cut -d'|' -f2 <<<${LINE})
		QCODE=$(cut -d'|' -f3 <<<${LINE})
		_DISPLAY_KEYS[${DKEY}]="${QCODE}:${QKEY}"
	done < ${_YTS_FAVORITES}
}

fav_set () {
	local FAV=$(str_trim ${1:gs/ /_/})
	local -aU HISTORY
	local LINE
	local H

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"
	[[ ${_DEBUG} -ge 1 ]] && dbg "${0}:${LINENO} ARG: FAV:${FAV} g_QRY_ENGINE:${g_QRY_ENGINE} g_LIVE:${g_LIVE}"

	msg_box -H1 -p -PC "<w><I>Please respond<N>|<Z>|Add ${FAV} to favorites?"
	[[ ${_MSG_KEY} != 'y' ]] && return

	# R    - Rumble  - general query
	# RL   - Rumble  - livestream query
	# Y    - YouTube - ID query
	# YNS  - YouTube - ID no strict
	# PYNS - YouTube - general query
	
	if [[ ${g_QRY_ENGINE:l} == 'rumble' ]];then
		[[ ${g_LIVE} == 'true' ]] && FAV="${(C)FAV}|${FAV}|RL" || FAV="${(C)FAV}|${FAV}|R"
	else
		if [[ ${FAV} =~ ' ' ]];then
			FAV="${(C)FAV}|${FAV}|PYNS" # Contains spaces
		else
			[[ ${g_STRICT} == 'false' ]] && FAV="${(C)FAV}|${FAV}|YNS" || FAV="${(C)FAV}|${FAV}|Y"
		fi
	fi

	HISTORY+=${FAV}

	if [[ -e ${_YTS_FAVORITES} ]];then
		while read LINE;do
			HISTORY+=${LINE}
		done < ${_YTS_FAVORITES}

		/bin/rm -f ${_YTS_FAVORITES}
	fi

	for H in ${(o)HISTORY};do
		echo ${H} >> ${_YTS_FAVORITES}
	done

	sort -o ${_YTS_FAVORITES} -t'|' -k3 ${_YTS_FAVORITES} 
}

get_av_codes () {
	URL=${1}

	local -a LIST
	local -a AUDIO
	local -a VIDEO
	local AUDIO_CODE
	local VIDEO_CODE
	local L V A

	LIST=("${(f)$(yt -F ${URL} | grep 'm4a\|mp4' 2>/dev/null | grep 'https' 2>/dev/null)}")

	for L in ${LIST};do
		[[ ${L:l} =~ 'audio' ]] && AUDIO+=$(tr -s '[:space:]' <<<${L} | sed 's/ /|/g' | tr -s '|' | sed 's/,//g')
		[[ ${L:l} =~ 'video' ]] && VIDEO+=$(tr -s '[:space:]' <<<${L} | sed 's/ /|/g' | tr -s '|' | sed 's/,//g')
	done

	AUDIO_CODE=$(
	for A in ${AUDIO};do
		[[ ${A} =~ 'drc' ]] && continue
		echo "$(cut -d'|' -f12 <<<${A})|$(cut -d'|' -f1 <<<${A})"
	done | sort -nr | head -1 | cut -d'|' -f2
	)

	VIDEO_CODE=$(
	for V in ${VIDEO};do
		echo "$(cut -d'|' -f12 <<<${V})|$(cut -d'|' -f1 <<<${V})"
	done | sort -nr | head -1 | cut -d'|' -f2
	)

	echo "${VIDEO_CODE}+${AUDIO_CODE}"
}

get_box_center () {
	local OBJ=$(( ${#1} + 4 ))
	local AREA=$(( _CONT_COORDS[Y] + _CONT_COORDS[W] ))
	local CTR
	local REM
	local AC
	local OC

	CTR=$((AREA / 2))
	REM=$((CTR % 2))
	[[ ${REM} -ne 0 ]] && AC=$((CTR+1)) || AC=${CTR}

	CTR=$((OBJ / 2))
	REM=$((CTR % 2))
	[[ ${REM} -ne 0 ]] && OC=$((CTR+1)) || OC=${CTR}

	echo $((AC-OC+1))
}

get_field () {
	local FIELD=${1}
	local NDX=${2}
	local -A FIELD_MAP=("age" 1 "author" 2 "title" 3 "url" 4 "time" 5 "agetime" 6)
	local STR=''
	local TSTR=''

	[[ ${_DEBUG} -ge ${_LOW_DETAIL_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@} ARGS:FIELD:${FIELD}, NDX:${NDX}"
	[[ ${_DEBUG} -ge ${_LOW_DETAIL_DBG} ]] && dbg "${0}:${LINENO} _LIST[NDX]:${_LIST[${NDX}]}"

	case ${FIELD} in
		age) STR=$(cut -d'|' -f${FIELD_MAP[age]} <<<${_LIST[${NDX}]});;
		agetime) STR=$(cut -d'|' -f${FIELD_MAP[agetime]} <<<${_LIST[${NDX}]});;
		author) STR=$(cut -d'|' -f${FIELD_MAP[author]} <<<${_LIST[${NDX}]});;
		time) STR=$(cut -d'|' -f${FIELD_MAP[time]} <<<${_LIST[${NDX}]});;
		title) STR=$(cut -d'|' -f${FIELD_MAP[title]} <<<${_LIST[${NDX}]});;
		url) STR=$(cut -d'|' -f${FIELD_MAP[url]} <<<${_LIST[${NDX}]});;
	esac

	[[ ${_DEBUG} -ge ${_LOW_DETAIL_DBG} ]] && dbg "${0}: Parsed FIELD:${FIELD} STR:${STR}"

	if [[ ${FIELD} == 'agetime' ]];then
		[[ ${STR:l} =~ 'upcoming' ]] && STR='(UPCOMING EPISODE)'
		[[ ${STR:l} =~ 'views' ]] && STR=$(sed -E 's/^(.*views )(.*ago)(.*)/(\2)/' <<<${STR})
		[[ ${STR:l} =~ 'live' ]] && STR=$(sed -E 's/(.*ago)( live)(.*)/\1)/I' <<<${STR})
	fi

	if [[ ${FIELD} == 'author' ]];then
		[[ ${g_SEARCH_TYPE} == 'general' ]] && TSTR=${(C)STR} || TSTR=${g_DISPLAY_KEY:gs/_/ /}
		STR=${TSTR:=${STR}}
	fi

	if [[ -n ${_FIELD_LEN[${FIELD}]} ]];then
		echo -n ${STR[1,${_FIELD_LEN[${FIELD}]}]}
	else
		echo -n ${STR}
	fi
}

item_decorate () {
	local NDX=${1}
	local STR

	[[ ${_DEBUG} -ge ${_LOW_DETAIL_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	if [[ ${_DOWNLOADS[${NDX}]} == 'true' ]];then
		STR="Downloaded..."
	elif [[ ${_FAILED[${NDX}]} == 'true' ]];then
		STR="Failed..."
	elif [[ ${_FUTURE[${NDX}]} == 'true' ]];then
		STR="Future: ${g_WHEN:s/minutes/mins/}"
	elif [[ ${_PARTIALS[${NDX}]} == 'true' ]];then
		STR="Partial..."
	else
		STR=${$(get_field agetime ${NDX})[1,${_FIELD_LEN[agetime]}]}
	fi

	echo -n ${STR}
}

job_kill () {
	local -a PIDS=()
	local PID
	local P

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	PIDS=("${(f)$(pgrep -n "yt-dlp")}")
	if [[ ${?} -eq 0 ]];then
		for P in ${PIDS};do
			kill -9 ${P} >/dev/null 2>&1
			find ${_DOWNLOAD_DIR} -maxdepth 1 -name '*part' -exec rm -rf {} \;
			logit ${_YTS_DBG_LOG} "${0}: Killed ${P}"
		done
	else
		echo "${0}: No processes found" >> ${g_YTS_LOG}
	fi

	if [[ ! ${functrace[1]} =~ "job_reset" ]];then
		trap - INT # Disable trap
		log_clear "job_kill"
		exit_leave "${_SCRIPT}:${WHITE_FG}Download Job:${RED_FG}killed${RESET}"
	fi
}

job_reset () {
	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	job_kill
	msg_box -t${_ALERT_TM} -x${_ALERT_COORDS[X]} -y${_ALERT_COORDS[Y]} "<m>Job Restarted<N>"
}

job_start () {
	local URL=${@}
	local CMD=''

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	g_YTS_LOG=$(mktemp /tmp/yt.log.XXXXXX)

	if [[ ${g_FIX_AUDIO} == 'true' ]];then
		msg_box -H1 -x${_CONT_COORDS[X]} -h${_CONT_COORDS[H]} "<w><I>Audio Fix Mode<N>|<Z>|Getting a/v codes|<Z>|<I>Please wait...<N>"
		CMD="nohup yt -N2 -Rinfinite -f $(get_av_codes ${URL}) -i -o '%(channel)s - %(title)s.%(ext)s' ${(qqq)URL}" # Manual a/v blend
	else
		CMD="nohup yt -N2 -Rinfinite -i -o '%(channel)s - %(title)s.%(ext)s' ${(qqq)URL}" # Routine download
	fi

	echo "${0} CMD:${CMD}" >> ${g_YTS_LOG} # Log command
	logit ${_YTS_DBG_LOG} "${0}: QUERY:${g_QUERY_KEY}"
	logit ${_YTS_DBG_LOG} "${0}: CMD:${CMD}"

	eval "${CMD} >> ${g_YTS_LOG} 2>&1" & # Start background job
	g_PID=$!

	echo "${0}: PID:${g_PID}" >> ${g_YTS_LOG} # Log pid

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: CMD:${CMD}"
}

last_code_update () {
	local MARKER_ARG=${1}
	local LAST_UPD=0
	local LAST_TIME=0

	[[ -z ${MARKER_ARG} ]] && exit_leave "${_SCRIPT_TAG}} ${RED_FG}Missing argument${RESET}:<MARKER>"

	if [[ -e ${MARKER_ARG} ]];then
		LAST_UPD=$(stat -c "%y" ${MARKER_ARG} | cut -d' ' -f1)
		[[ -e ${MARKER_ARG} ]] && LAST_TIME=$(stat -c"%x" ${MARKER_ARG} | cut -d. -f1 | cut -d' ' -f2 | cut -d: -f1,2) 
		echo "$(date_since_today ${_TODAY} ${LAST_UPD}) at ${LAST_TIME}"
	fi
}

last_file () {
	local ST=''
	local FN=''
	local IN=''

	ST=$(stat -c"%W|%i|%n" ${_DOWNLOAD_DIR}/* | sort -t'|' -k1 -r | head -1) # Sort by birth date; grab most recent
	FN=$(cut -d'|' -f3 <<<${ST}) # Filename
	IN=$(cut -d'|' -f2 <<<${ST}) # Inode

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: FN:${FN} INODE:${IN}"

	if [[ -e ${FN} ]];then
		echo "${FN}|${IN}"
		return 0
	else
		return 1
	fi
}

list_reset () {
	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	_LIST_SELECTED=()
	_MARKED=()
	_SELECTION_LIST=()
}

log_add () {
	local NDX=${1}
	local LF=$(last_file) # Filename|Inode
	local FN=$(cut -d'|' -f1 <<<${LF}) # Filename
	local IN=$(cut -d'|' -f2 <<<${LF}) # Inode
	local TL=$(get_field title ${NDX}) # Title
	local AT=$(get_field agetime ${NDX}) # Age
	local AU=$(get_field author ${NDX}) # Author
	local TM=$(sed -E 's/^.*ago\s+(.*)\)/\1/' <<<${AT}) # Video length

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: FN:${FN} INODE:${IN}"

	[[ ${FN:e} == 'part' || ${FN:e} == 'temp' ]] && return # No partials in log

	echo "${IN}|${TL}|${FN:t}|${TM}|${AU}" >> ${_DOWNLOAD_LOG}
}

log_clear () {
	local FROM=${1}

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	if [[ ${_DEBUG} -eq 0 && ${_EXIT_SCRUB} == 'true' && -e ${g_YTS_LOG} ]];then
		rm -f ${g_YTS_LOG}
		logit ${_YTS_DBG_LOG} "log ${g_YTS_LOG} was cleared for:${g_QUERY_KEY} from:${FROM}"
	else
		logit ${_YTS_DBG_LOG} "DEBUG ${_DEBUG} active - log ${g_YTS_LOG} was retained for:${g_QUERY_KEY}"
	fi
}

log_find () { 
	local TOP=${1} # Page top row supplied by LIST.zsh line 108
	local BOT=${2} # Page bot row supplied by LIST.zsh line 108
	local LINE_NUM=''
	local LIST_AU=''
	local LIST_TITLE=''
	local LIST_TM=''
	local LOG_AU=''
	local LOG_FN=''
	local LOG_LINE=''
	local LOG_TITLE=''
	local LOG_TM=''
	local R=0
	local DBG=false

	[[ ${_DEBUG} -ge ${_LOW_DETAIL_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	# Page callback - scan list to find downloaded items
	 
	_DOWNLOADS=()
	_PARTIALS=()

	[[ ${DBG} == 'true' ]] && /bin/rm -f ${0}.dbg

	for ((R=${TOP}; R <= ${BOT}; R++));do
		LINE_NUM=''

		LIST_TITLE=$(get_field title ${R}) # Title from list
		LIST_AU=$(get_field author ${R}) # Author from list
		LIST_TM=$(sed -E 's/^.*ago\s+(.*)\)/\1/' <<<$(get_field agetime ${R}) | tr -d '[()]' | sed 's/undefined//') # Video length from list

		[[ ${DBG} == 'true' ]] && echo "\nLIST_NDX:${R}" >>${0}.dbg
		[[ ${DBG} == 'true' ]] && echo "LIST_TITLE:${LIST_TITLE}" >>${0}.dbg
		[[ ${DBG} == 'true' ]] && echo "LIST_AU:${LIST_AU}" >>${0}.dbg
		[[ ${DBG} == 'true' ]] && echo "LIST_TM:${LIST_TM}" >>${0}.dbg
		[[ ${DBG} == 'true' ]] && echo "\nAttempting TITLE match on:${LIST_TITLE[1,50]}" >>${0}.dbg 

		LOG_TITLE=$(grep -F -n -m1 -i -- ${LIST_TITLE[1,50]} ${_DOWNLOAD_LOG}) # grep -F option needed to ignore any special chars
		if [[ ${?} -eq 0 ]];then
			LINE_NUM=$(cut -d: -f1 <<<${LOG_TITLE}) # Fetch line number
			LOG_LINE=$(sed -n "${LINE_NUM}p" ${_DOWNLOAD_LOG}) # Fetch log line
			LOG_AU=$(grep -i -o -m1 "${LIST_AU}$" <<<${LOG_LINE}) # Match author in log line
			LOG_TM=$(grep -o ${LIST_TM} <<<${LOG_LINE}) # Match time in log line

			[[ ${DBG} == 'true' ]] && echo "Matched:TITLE:${LOG_TITLE}" >>${0}.dbg
			[[ ${DBG} == 'true' ]] && echo "Log line:${LOG_LINE}" >>${0}.dbg
			[[ ${DBG} == 'true' ]] && echo "Need author:${LIST_AU} and time:${LIST_TM}" >>${0}.dbg

			if [[ -n ${LOG_TM} && -n ${LOG_AU} ]];then
				LOG_FN=$(cut -d '|' -f3 <<<${LOG_LINE}) # Fetch filename
				_DOWNLOADS[${R}]=true

				[[ ${DBG} == 'true' ]] && echo "Confirmed match: Marking NDX:${R} as downloaded for file:${LOG_FN}\n" >>${0}.dbg
				[[ ${DBG} == 'true' ]] && echo "LOG_AU:${LOG_AU}" >>${0}.dbg
				[[ ${DBG} == 'true' ]] && echo "LOG_TM:${LOG_TM}" >>${0}.dbg
			else
				[[ ${DBG} == 'true' ]] && echo "Failed to confirm download" >>${0}.dbg
			fi
		fi
	done
}

log_to_file () { 
	local TOP=${1} # Page top row
	local BOT=${2} # Page bot row
	local FN=''
	local LINE=''
	local LIST_AU=''
	local LIST_TM=''
	local R=0

	# Page callback - pre-process list to populate download status
	 
	_DOWNLOADS=()
	_PARTIALS=()

	for ((R=${TOP}; R <= ${BOT}; R++));do
		LIST_AU=$(get_field author ${R}) # Author from list
		LIST_TM=$(sed -E 's/^.*ago\s+(.*)\)/\1/' <<<$(get_field agetime ${R}) | tr -d '[()]' | sed 's/undefined//') # Video length from list
		LINE=$(grep -i ${LIST_AU} ${_DOWNLOAD_LOG} 2>/dev/null | grep ${LIST_TM} 2>/dev/null) # Match on author/time
		if [[ -n ${LINE} ]];then 
			FN=$(cut -d '|' -f3 <<<${LINE})
			if [[ -e ${_DOWNLOAD_DIR}/${FN} ]];then
				break
			fi
		fi
	done

	echo ${FN}
}

log_update () {
	local -A SEEN=()
	local FN_HIT=''
	local HAS_NEW_LOG=false
	local INODE=''
	local LINE=''
	local LOG_LINE=''
	local NEW_LOG=/tmp/log.new
	local L

	{
		[[ -e /tmp/log.new ]] && /bin/rm -f ${NEW_LOG}
		logit ${_YTS_DBG_LOG} "${0}: LOG lines BEFORE update:$(wc -l ${_DOWNLOAD_LOG})"

		HAS_NEW_LOG=false
		while read -u3 LINE;do
			INODE=$(cut -d'|' -f1 <<<${LINE})
			if [[ ${SEEN[${INODE}]} -eq 1 ]];then
				logit ${_YTS_DBG_LOG} "${0}: ERROR Got duplicate inode:${INODE} - skipping duplicates"
				continue
			fi
			SEEN[${INODE}]=1
			FN_HIT=$(find ${_DOWNLOAD_DIR} -maxdepth 1 -inum ${INODE})
			if [[ -n ${FN_HIT} ]];then
				HAS_NEW_LOG=true
				LOG_LINE=$(grep -m1 ${INODE} ${_DOWNLOAD_LOG} 2>/dev/null)
				[[ ${?} -eq 0 ]] && echo ${LOG_LINE} >> ${NEW_LOG} || logit ${_YTS_DBG_LOG} "${0}: ERROR Log line for:${INODE} not found"
			else
				logit ${_YTS_DBG_LOG} "${0}: Skipping expired inode:${INODE}"
				SEEN[${INODE}]=1
				continue
			fi
		done 3< ${_DOWNLOAD_LOG}

		if [[ ${HAS_NEW_LOG} == 'true' ]];then
			cp ${_DOWNLOAD_LOG} ${_DOWNLOAD_LOG}.bak
			mv -f ${NEW_LOG} ${_DOWNLOAD_LOG}
			logit ${_YTS_DBG_LOG} "${0}: LOG lines AFTER update:$(wc -l ${_DOWNLOAD_LOG})"
		else
			/bin/rm -f ${_DOWNLOAD_LOG} && touch ${_DOWNLOAD_LOG} # No files present - initialize new log
			logit ${_YTS_DBG_LOG} "${0}: Empty log - initializing new log"
		fi
	} 2>/dev/null
}

post_process () {
	local -a KEYWORDS=("judge napolitano - " "official" "^the " " show" "have it out with galloway \- " "youtube channel")
	local -a LIST=()
	local -a PIDS=()
	local -a TEMP_FILES=()
	local FN=''
	local LF=''
	local MSG="Post Processing"
	local NEW_FN=''
	local NDX=0
	local F K

	msg_box -x$(( _CONT_COORDS[X]+4 )) -y$(box_center ${MSG}) ${MSG}

	NDX=0
	while true;do
		((NDX++))
		PIDS=("${(f)$(pgrep -n "yt-dlp")}")
		if [[ ${?} -ne 0 ]];then
			sleep 2 && break
		fi
		msg_box -x14 "(<w>${NDX}<N>) Waiting for <c>yt-dlp<N> to finish..."
		sleep 1
	done

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: Removing any temp.mp4 files"

	TEMP_FILES=("${(f)$(find ${_DOWNLOAD_DIR} -name '*temp.mp4')}")
	for F in ${TEMP_FILES};do
		/bin/rm -f ${F} >/dev/null 2>&1
		[[ ${?} -eq 0 ]] && logit ${_YTS_DBG_LOG} "${0}: deleted ${F}"
	done

	LF=$(last_file) # Filename and Inode
	FN=$(cut -d'|' -f1 <<<${LF}) # Filename
	logit ${_YTS_DBG_LOG} "${0}: Last FN:${FN}"

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: FN:${FN:t}"

	NEW_FN=$(clean_title "file" ${FN:t:r:gs/_/ /}) # Clean tail, no extension, no underscores

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: Scrubbing keywords"
	for K in ${KEYWORDS};do # Scrub keywords
		NEW_FN=$(sed "s/${K}//I" <<<${NEW_FN})
	done
	logit ${_YTS_DBG_LOG} "${0}: Scrubbed:${NEW_FN}"

	NEW_FN="$(str_trim ${FN:h}/${NEW_FN}).${FN:e}" # Add path and extension
	logit ${_YTS_DBG_LOG} "${0}: Formatted:${NEW_FN}"

	if [[ ${FN} != ${NEW_FN} ]];then
		[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: Saving changes:${FN:t} -> ${NEW_FN:t}"
		logit ${_YTS_DBG_LOG} "${0}: Overwriting:${FN}"
		mv -f "${FN}" "${NEW_FN}" 2>> ${_ERROR_LOG} # Write any changes
		[[ ${?} -ne 0 ]] && echo "${0}: Move failed ${FN} to ${NEW_FN}" >> ${_ERROR_LOG}
	fi

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: Cleaned:${FN:t}"
}

query_rumble () {
	local SEARCHTERM=${1}
	local -A LAST_MSG=($(box_coords_get ${_LAST_MSG_TAG}))
	local -A MSG_BOX=($(box_coords_get "MSG_BOX"))
	local -A FIELD_MAP=("author" 2 "title" 3 "age" 4 "url" 5 "time" 6 "agetime" "4,6")
	local -a AGES=()
	local -a CHANNELS=()
	local -a DURATIONS=()
	local -a LINKS=()
	local -a TITLES=()
	local -a WORK=()
	local -aU VID_LIST=()
	local AGE AUTHOR TITLE URL TIME AGETIME
	local CHANNEL=''
	local DO_GENERAL=false
	local GEN_SEARCH=''
	local LIVE=''
	local MSG=''
	local NDX=''
	local PG=''
	local REL_W=$(( ${LAST_MSG[W]} +4 ))
	local REL_Y=$(coord_center $(( _MAX_COLS + 3 )) ${REL_W})
	local STR=''
	local F X

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	[[ -n ${SEARCHTERM} ]] && g_QUERY_KEY=${SEARCHTERM}

	if [[ ${g_GOT_URL} == 'true' ]];then
		[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} QUERY based on URL arg:${URL}"
		PG=("${(f)$(wget -q -O - ${URL})}")
		TITLES=$(pup --charset utf8 'head' 'title' text{} <<<${PG} | sed 's/|//g')
		LINKS="/$(cut -d'/' -f4 <<<${URL})"
		AGES="URL - "
		DURATIONS=$(pup 'div' .media-description-info-stream-time '[title]' text{} <<<${PG} | tr -d '\n' | tr -s '[:space:]' | str_trim)
		[[ -z ${DURATIONS} ]] && DURATIONS="Unavailable"
		g_SEARCH_TYPE="URL"
		g_QUERY_KEY=$(pup 'div' ."media-heading-name" text{} <<<${PG} | tr -d '\n' | tr -s '[:space:]'  | str_trim)
		VID_LIST+="${g_QUERY_KEY}|${TITLES}|${AGES}|${LINKS}|${DURATIONS}" # Unique rows
	else
		PG=$(wget -q -O - "http://rumble.com/c/${g_QUERY_KEY}?page=1")
		[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} QUERY based on QUERY_KEY::http://rumble.com/c/${g_QUERY_KEY}?page=1"
	fi

	if [[ ${g_GOT_URL} == 'false' ]];then
		if [[ -n ${PG} ]];then # Channel search
			[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} CHANNEL SEARCH"
			[[ ${g_ENGINE_KEY:l} == 'r' ]] && g_LIVE=false
			[[ ${g_ENGINE_KEY:l} == 'rl' ]] && g_LIVE=true
			[[ ${g_LIVE_OPT} == 'true' ]] && { [[ ${g_LIVE} == 'true' ]] && g_LIVE=false || g_LIVE=true }
			[[ ${g_LIVE} == 'true' ]] && MSG="Searching livestreams..." || MSG="Searching videos..."

			if [[ -n ${INNER_BOX} ]];then
				_REL_COORDS=($(box_coords_relative INNER_BOX X +6 Y ${REL_Y} H 3 W ${LAST_MSG[W]}))
				msg_box -T SEARCH -R -c ${MSG}
			else
				msg_box -x $((MSG_BOX[X]+1)) -y ${MSG_BOX[Y]} -w $((MSG_BOX[W]+1)) ${MSG}
			fi

			LIVE=$(pup '.channel-subheader--menu-item attr{href}' <<<${PG} | grep "livestreams" 2>/dev/null)
			[[ ${g_LIVE} == 'true' && -n ${LIVE} ]] && PG=$(wget -q -O - "http://rumble.com${LIVE}")
			[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} QUERY based on livestream arg:http://rumble.com${LIVE}"

			if [[ ${PG:l} =~ "no videos found" ]];then
				if [[ -n ${INNER_BOX} ]];then
					_REL_COORDS=($(box_coords_relative INNER_BOX X +6 W ${REL_W} Y ${REL_Y} H 4))
					msg_box -T SEARCH -R -c "<r>Livestream search failed<N> for ${g_QUERY_KEY}|Falling back to defaults..." 
				else
					msg_box -T SEARCH "<r>Livestream search failed<N> for ${g_QUERY_KEY}|Falling back to defaults..." 
				fi
				PG=$(wget -q -O - "http://rumble.com/c/${g_QUERY_KEY}?page=1")
				[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} QUERY fallback on QUERY_KEY::http://rumble.com/c/${g_QUERY_KEY}?page=1"
			fi

			g_SEARCH_TYPE=channel
			TITLES=("${(f)$(pup --charset utf8 '.title__link text{}' <<<${PG} | tut blank_lines | iconv -f utf-8 -t ascii//TRANSLIT | sed 's/|//g')}")
			AGES=("${(f)$(pup --charset utf8 '.videostream__data text{}' <<<${PG} | tut blank_lines | tr '[\012|\015]' '[ ]' | sed -e 's/\(comments\?\) /\1 \n/g')}") # Either plural or singular
			LINKS=("${(f)$(pup --charset utf8 'a.videostream__link attr{href}' <<<${PG})}")
			DURATIONS=("${(f)$(pup --charset utf8 '.videostream__badge text{}' <<<${PG} | tut blank_lines)}")

			for ((X=1; X<=${#TITLES}; X++));do
				AGE=$(sed 's/ago .*/ago/' <<<${AGES[${X}]})
				[[ -z ${AGE} ]] && continue
				[[ ! ${AGE} =~ 'ago' ]] && continue # Dump junk listings without age
				[[ ${AGE} =~ 'views' ]] && continue # Dump junk listings without age
				VID_LIST+="${g_QUERY_KEY}|${TITLES[${X}]}|${AGE}|${LINKS[${X}]}|${DURATIONS[${X}]}" # Unique rows
			done
		else # User search
			[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} GENERAL SEARCH"
			msg_box "Channel search failed.  Performing user livestream search..."
			g_SEARCH_TYPE=user
			GEN_SEARCH=$(sed 's/ /%20/g' <<<${g_QUERY_KEY})
			PG=$(wget -q -O - "https://rumble.com/user/${g_QUERY_KEY}/livestreams'")
			[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} QUERY based on user livestream search:https://rumble.com/user/${g_QUERY_KEY}/livestreams"

			[[ -z ${PG} || ${PG:l} =~ "no videos found" ]] && DO_GENERAL=true || DO_GENERAL=false

			if [[ ${DO_GENERAL} == 'false' ]];then
				TITLES=("${(f)$(pup --charset utf8 '.title__link text{}' <<<${PG} | tut blank_lines | iconv -f utf-8 -t ascii//TRANSLIT | sed 's/|//g')}")
				AGES=("${(f)$(pup --charset utf8 '.videostream__data text{}' <<<${PG} | tut blank_lines | tr '[\012|\015]' '[ ]' | sed -e 's/\(comments\?\) /\1 \n/g')}") # Either plural or singular
				LINKS=("${(f)$(pup --charset utf8 'a.videostream__link attr{href}' <<<${PG})}")
				DURATIONS=("${(f)$(pup --charset utf8 '.videostream__badge text{}' <<<${PG} | tut blank_lines)}")

				for ((X=1; X<=${#TITLES}; X++));do
					AGE=$(sed 's/ago .*/ago/' <<<${AGES[${X}]})
					[[ -z ${AGE} ]] && continue
					[[ ! ${AGE} =~ 'ago' ]] && continue # Dump junk listings without age
					[[ ${AGE} =~ 'views' ]] && continue # Dump junk listings without age
					VID_LIST+="${g_QUERY_KEY}|${TITLES[${X}]}|${AGE}|${LINKS[${X}]}|${DURATIONS[${X}]}" # Unique rows
				done
			else # General search
				[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} GENERAL SEARCH"
				msg_box "Other searches failed.  Performing general search..."
				g_SEARCH_TYPE=general
				GEN_SEARCH=$(sed 's/ /%20/g' <<<${g_QUERY_KEY})
				PG=$(wget -q -O - "https://rumble.com/search/all?q=${GEN_SEARCH}")
				[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} QUERY based on general search:https://rumble.com/search/all?q=${GEN_SEARCH}"

				TITLES=("${(f)$(pup --charset utf8 '.video-item--title text{}' <<<${PG} | iconv -f utf-8 -t ascii//TRANSLIT | sed 's/|//g')}")
				AGES=("${(f)$(pup --charset utf8 '.video-item--meta attr{datetime}' <<<${PG})}")
				DURATIONS=("${(f)$(pup --charset utf8 '.video-item--duration attr{data-value}' <<<${PG})}")
				LINKS=("${(f)$(pup --charset utf8 '.video-item--a attr{href}' <<<${PG})}")
				CHANNELS=("${(f)$(pup --charset utf8 '.video-item--by-a attr{href}' <<<${PG})}")

				for ((X=1; X<=${#TITLES}; X++));do
					[[ ${CHANNELS[${X}]} =~ 'user' ]] && echo "Query:${g_QUERY_KEY} Skipped ${TITLES[${X}]} ${CHANNELS[${X}]}" >> /tmp/gen_filter.dbg && continue # Filter
					AGE=$(sed 's/T.*//' <<<${AGES[${X}]})
					CHANNEL=$(sed 's#^.*/##' <<<${CHANNELS[${X}]})
					VID_LIST+="${CHANNEL}|${TITLES[${X}]}|${AGE}|${LINKS[${X}]}|${DURATIONS[${X}]}" # Unique rows
				done
			fi
		fi
	fi
	 
	NDX=0
	for X in ${VID_LIST};do
		((NDX++))
		VID_LIST[${NDX}]="${NDX}|${X}"
	done

	if [[ ${g_SEARCH_TYPE} == 'general' ]];then
		_LOCAL_LIST=("${(f)$(for L in ${VID_LIST};do echo ${L};done | sort -t'|' -k4.1,4.10 -r)}")
	else
		_LOCAL_LIST=(${VID_LIST})
	fi

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} g_QUERY_KEY:${g_QUERY_KEY} _LOCAL_LIST count: ${#_LOCAL_LIST}, TITLES: ${#TITLES}"
	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} \n$(for L in ${VID_LIST};do echo "VID_LIST:${L}";done)"

	# Return failed search status
	if ! arr_is_populated "${_LOCAL_LIST}";then
		return 1
	fi

	for F in ${_LOCAL_LIST};do
		AGE=$(cut -d'|' -f${FIELD_MAP[age]} <<<${F})
		AUTHOR=$(cut -d'|' -f${FIELD_MAP[author]} <<<${F})
		TITLE=$(cut -d'|' -f${FIELD_MAP[title]} <<<${F}); TITLE=$(clean_title "text" ${TITLE})
		URL=$(cut -d'|' -f${FIELD_MAP[url]} <<<${F}); URL="http://rumble.com${URL}"
		TIME=$(cut -d'|' -f${FIELD_MAP[time]} <<<${F})
		AGETIME=$(cut -d'|' -f${FIELD_MAP[agetime]} <<<${F});	AGETIME="(${AGETIME:s/|/ /})"

		WORK+="${AGE}|${AUTHOR}|${TITLE}|${URL}|${TIME}|${AGETIME}"
	done

	_LOCAL_LIST=(${WORK})

	return 0
}

query_youtube () { 
	local -a WORK=()
	local -A FIELD_MAP=("age" 1 "author" 2 "title" 3 "url" 4 "time" 5 "agetime" "1,5")
	local AGE AUTHOR TITLE URL TIME AGETIME
	local CUSTOM_KEY=false
	local DATA=false
	local HIT=false
	local LINE=''
	local NDX=0
	local PROXY_CMD=''
	local STR=''
	local F

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@} ARGV:${@}"

	if [[ -n ${g_QUERY_KEY} ]];then
		[[ ${g_ENGINE_KEY:l} == 'yns' ]] && g_PROXY_CMD=${g_PROXY_CMD:s/-s//} && g_STRICT=false # No strict requested
		PROXY_CMD="${g_PROXY_CMD} ${g_QUERY_KEY:q}"
	else
		PROXY_CMD="${g_PROXY_CMD}"
	fi

	if [[ ${_DEBUG} -ge ${_LOW_DBG} ]];then
		dbg "${0}: g_QUERY_KEY:${g_QUERY_KEY}"
		dbg "${0}: g_ENGINE_KEY:${g_ENGINE_KEY}"
		dbg "${0}: ${WHITE_FG}STRICT${RESET}:${g_STRICT}"
		dbg "${0}: ${WHITE_FG}PROXY COMMAND${RESET}:${PROXY_CMD}"
	fi

	_LOCAL_LIST=()

	NDX=0
	while read LINE;do
		[[ ${LINE:l} =~ 'matched' ]] && DATA=true && continue

		[[ ${LINE:l} =~ 'usage' && ${DATA} != 'true' ]] && exit_leave
		[[ ${LINE:l} =~ 'error' && ${DATA} != 'true' ]] && exit_leave $(msg_exit E "${PROXY_CMD} returned an error")

		((NDX++))
		[[ ${LINE:l} =~ 'rejected' ]] && _REJECTS[${NDX}]=true || _REJECTS[${NDX}]=false

		STR=$(iconv -f utf-8 -t ascii//translit <<<${LINE}) # Scrub non ascii
		STR=${STR:s/Streamed //}

		[[ ${g_ENGINE_KEY:l} =~ 'p' ]] && CUSTOM_KEY=true

		# --- BEGIN Experimental filtering
		if [[ ${CUSTOM_KEY} == 'false' ]];then
			g_SEARCH_TYPE='channel'
			HIT=false
			AUTHOR=$(cut -d'|' -f2 <<<${LINE})
			[[ ${AUTHOR:l} =~ ${g_DISPLAY_KEY:l} ]] && HIT=true
			[[ ${AUTHOR:l} =~ ${g_QUERY_KEY:l} ]] && HIT=true
			[[ ${AUTHOR:gs/ //:l} =~ ${g_QUERY_KEY:l} ]] && HIT=true
			[[ ${_DEBUG} -ge ${_LOW_DETAIL_DBG} ]] && dbg "${0}:${LINENO} EXPERIMENTAL FILTERING AUTHOR:${AUTHOR} HIT:${HIT}"
			[[ ${HIT} == 'false' ]] && continue
			# --- END Experimental filtering
		else
			g_SEARCH_TYPE='general'
		fi
		 
		[[ ${_REJECTS[${NDX}]} == 'false' && ${DATA} == 'true' ]] && _LOCAL_LIST+=${STR}
	done< <(eval ${PROXY_CMD})

	[[ ${g_STRICT} == 'true' ]] && g_STRICT_MSG="$(total_rejects ${NDX})" || g_STRICT_MSG=''

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} _LOCAL_LIST count: ${#_LOCAL_LIST}"
	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} _LOCAL_LIST content:\n $(for L in ${_LOCAL_LIST};do echo ${L};done)"

	[[ ${_SMCUP} == 'false' ]] && do_smcup

	# Return failed search status
	if ! arr_is_populated "${_LOCAL_LIST}";then
		g_PROXY_CMD=$(str_trim ${(Q)g_PROXY_CMD})
		msg_box -H2 -p -PK "<r>No data for query<N>:${g_PROXY_CMD}|${g_STRICT_MSG}|Strict filter option '<w>-S<N>' limits results"
		return 1
	fi

	for F in ${_LOCAL_LIST};do
		AGE=$(cut -d'|' -f${FIELD_MAP[age]} <<<${F})
		AUTHOR=$(cut -d'|' -f${FIELD_MAP[author]} <<<${F})
		TITLE=$(cut -d'|' -f${FIELD_MAP[title]} <<<${F}); TITLE=$(clean_title "text" ${TITLE})
		URL=$(cut -d'|' -f${FIELD_MAP[url]} <<<${F})
		TIME=$(cut -d'|' -f${FIELD_MAP[time]} <<<${F})
		AGETIME=$(cut -d'|' -f${FIELD_MAP[agetime]} <<<${F});	AGETIME="(${AGETIME:s/|/ /})"
		WORK+="${AGE}|${AUTHOR}|${TITLE}|${URL}|${TIME}|${AGETIME}"
	done

	_LOCAL_LIST=(${WORK})

	return 0
}

set_item_color () {
	local ITEM=${1}

	[[ ${_DEBUG} -ge ${_LOW_DETAIL_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	case ${ITEM:l} in
		downloaded*) echo ${GREEN_FG};;
		failed*) echo ${RED_FG};;
		future*) echo ${CYAN_FG};;
		partial*) echo ${WHITE_ON_GREY};;
		*) echo '';;
	esac
}

total_rejects () {
	local TL_VIDS=${1}
	local TL_RJ=0
	local -F1 RJ_PCT=0
	local K

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	for K in ${(k)_REJECTS};do
		[[ ${_REJECTS[${K}]} == 'true' ]] && ((TL_RJ++))
	done

	TL_VIDS=${TL_VIDS}.00
	TL_RJ=${TL_RJ}.00

	[[ ${TL_RJ} -ne 0 ]] && RJ_PCT=$(( (TL_RJ/TL_VIDS) * 100 ))

	echo "${RJ_PCT}%"
}

#--Begin GetOpts--
read -r -d '' DESC<<EOF
Query either Youtube or Rumble for videos.
\tQueries provide a selection list of matching videos. 
\tFollowing selection, items are downloaded via yt-dlp. 
\tBy default, Rumble queries are for livestreams and general search
\tif no livestreams are found. The -L option will override this behavior. 
\tWhen saving favorites, query, platform, and search type are cached.
\tHidden keys: 'l' during menu selection will toggle livestream search.
\t             'r' during download will reset the connection.
EOF

opt_type () {
	local OPT=${1}
	case ${OPT} in
		a) echo "<AGE_FILTER> [all,min,hour,day,week,month,year]";;
		s) echo "<SEARCHTERM>";;
		u) echo "<URL>";;
	esac
}

parse_opts () {
	local OPTS=${@}
	local -a OPTSTR
	local O

	for O in {1..${#OPTS}};do
		[[ ${O} -eq 1 && ${OPTS[${O}]} == ":" ]] && continue
		[[ ${O} -gt 1 && ${OPTS[${O}]} == ":" ]] && OPTSTR+="<PARAM>" && continue
		OPTSTR+="-${OPTS[${O}]}"
	done
	echo ${OPTSTR}
}

usage () {
	local OPTS=$(parse_opts ${OPTSTR})
	local -a PENDING_MSGS=(${@})

	tabs 5
	[[ ${_SMCUP} == 'true' ]] && do_rmcup

	(
	echo -e "\n${WHITE_FG}Usage${RESET}: ${_SCRIPT} ${OPTS} [$(opt_type s)] [$(opt_type u)]\n"
	echo -e "${WHITE_FG}-H${RESET} help"
	echo -e "${WHITE_FG}-D${RESET} debug"
	echo -e "${WHITE_FG}-A${RESET} fix audio (YouTube only)"
	echo -e "${WHITE_FG}-L${RESET} toggle cached livestream option (${MAGENTA_FG}Rumble only${RESET})"
	echo -e "${WHITE_FG}-R${RESET} Rumble query [default is YouTube]"
	echo -e "${WHITE_FG}-S${RESET} disable strict filtering (${MAGENTA_FG}YouTube only${RESET})"
	echo -e "${WHITE_FG}-V${RESET} yt-search version (${MAGENTA_FG}YouTube only${RESET})"
	echo -e "${WHITE_FG}-l${RESET} search for livestreams (${MAGENTA_FG}Rumble only${RESET})"
	echo -e "${WHITE_FG}-a${RESET} $(opt_type a) (${MAGENTA_FG}YouTube only${RESET})"
	echo -e "${WHITE_FG}-s${RESET} enable strict filter [author must match query] (${MAGENTA_FG}YouTube only${RESET})"
	echo -e "${WHITE_FG}-u${RESET} export the video URL"
	echo -e "\n${WHITE_FG}DESC${RESET}:${DESC}"
	) >&2

	exit_leave ${PENDING_MSGS}
}

OPTSTR=":HDARSVLla:s"
OPTIND=0

HELP_OPT=false
VERSION_OPT=false
g_STRICT=false
g_QRY_ENGINE=youtube
g_LIVE_OPT=false
g_LIVE=false
g_FIX_AUDIO=false

while getopts ${OPTSTR} OPTION;do
	case $OPTION in
     A) g_FIX_AUDIO=true;;
     H) HELP_OPT=true;;
     D) dbg_set_level;;
     V) VERSION_OPT=true;;
     R) g_QRY_ENGINE=rumble;;
     S) g_STRICT=true;;
     a) AGE=${OPTARG};;
     l) g_LIVE=true;;
     s) g_STRICT=true;;
    \?) exit_leave "${RED_FG}Error${RESET}: ${BOLD}${RED_FG}Unknown option${RESET} -${OPTARG}";;
	  :) exit_leave "${RED_FG}Error${RESET}: option -${OPTARG} requires an argument${RESET}";;
	esac
	[[ ${OPTION} != 'D' ]] && OPTIONS+=${OPTION}
done
shift $((OPTIND -1))
#--End GetOpts--

# Execution
[[ ${g_FIX_AUDIO} == 'true' && ${g_QRY_ENGINE} == 'rumble' ]] && g_FIX_AUDIO=false && msg_box -p -PK "FIX AUDIO not supported for Rumble| FIX AUDIO ignored"

g_GOT_URL=false
for A in ${@};do
	if [[ ${A} =~ 'http' ]];then
		g_GOT_URL=true
		URL=${A} 
		shift
		[[ ${A} =~ 'youtube' ]] && g_QRY_ENGINE='youtube'
		[[ ${A} =~ 'rumble' ]] && g_QRY_ENGINE='rumble'
	fi
done

RAWPATH=$(path_get_raw)
FPATH=$(cut -d'|' -f1 <<<${RAWPATH})
FGLOB=$(cut -d'|' -f2 <<<${RAWPATH})
PATHLBL=$(path_get_label 40)

g_LAST_CODE_UPD=$(last_code_update ${_UPD_MARKER})
if [[ (! -f ${_UPD_MARKER}) || (-f ${_UPD_MARKER} && (! ${g_LAST_CODE_UPD:l} =~ 'today')) ]];then
	clear
	msg_box "Checking for yt-dlp updates..."

	{
		CUR_VER=$(yt-dlp --version)
		yt-dlp -U
		touch ${_UPD_MARKER}
		UPD_VER=$(yt-dlp --version)
	} >/dev/null 2>&1
	[[ ${CUR_VER} == ${UPD_VER} ]] && MSG="yt-dlp is <g>current<N> at version:<r>${CUR_VER}<N>" || MSG="yt-dlp was <w>updated<N> from: <r>${CUR_VER}<N> to <g>${UPD_VER}<N>"

	msg_box -c -t2 ${MSG}
fi

set_exit_callback clear_tmp # Clear temp files on exit
log_update # Update the log
clear

fav_load ${_FAV_TAB}

while read LINE;do
	_ACRONYMS+=${LINE}
done < ${_ACRONYMS_FN}

# Arg handling for yts.js
if [[ ${g_QRY_ENGINE} == 'youtube' ]];then
	g_QUERY_KEY="${@}"

   if [[ ${HELP_OPT} == 'true' ]];then
		usage
		echo "\nYouTube backend:${WHITE_ON_GREY}${_JS_SCRIPT}${RESET} help\n"
		eval "node ${_JS_SCRIPT} -h" >&2
		exit_leave
	fi

	RCL=$(path_get_raw_cmdline | sed "s/${_SCRIPT}//")
	RCL=$(sed 's/\-h//' <<<${RCL}) # Front end option only
	RCL=$(sed 's/\-A//' <<<${RCL}) # Front end option only
	RCL=$(sed 's/\-D*//' <<<${RCL}) # Front end option only
	RCL=$(sed 's/\-S//' <<<${RCL}) # Front end option only
	RCL=$(sed 's/\-L//' <<<${RCL}) # Rumble only option
	RCL=$(sed 's/\-l//' <<<${RCL}) # Rumble only option

	[[ ${g_QUERY_KEY} =~ ' ' ]] && g_STRICT=false # Multiword arg
	[[ ${g_STRICT} == 'true' ]] && RCL="${RCL} -s"
	
	[[ ${_DEBUG} -ne 0 ]] && RCL=$(sed 's/\-D* //' <<<${RCL}) # Front end option only

	if [[ ${VERSION_OPT} == 'true'  ]];then
		echo -n "yt-search version:${WHITE_FG}"
		node ${_JS_SCRIPT} --version
		echo ${RESET}
		exit_leave
		[[ ${?} -ne 0 ]] && exit_leave "${RED_FG}Invalid argument${RESET} - valid age arguments: ${WHITE_FG}all,min,day,week,month,year${RESET}"
	fi

	if [[ -n ${g_QUERY_KEY} ]];then
		RCL="${RCL:Q}" # Remove any quotes
		RCL=$(sed "s/${g_QUERY_KEY}//" <<<${RCL}) # Remove arg as passed
		RCL="${RCL} ${ARG:q}" # Quote arg for any multi-word searches
	fi

	g_PROXY_CMD="node ${_JS_SCRIPT} ${RCL}"
fi

# Run Query
if [[ ${#} -eq 0 && ${g_GOT_URL} == 'false' ]];then # NO args passed
	while true;do
		do_smcup
		fav_get
		if [[ -n ${g_QUERY_KEY} ]];then
			msg_box "Requesting videos for <B><I>${g_DISPLAY_KEY}<N>..."
			query_${g_QRY_ENGINE} ${g_QUERY_KEY} # Call the extractor
			 
			if [[ ${?} -eq 0 ]];then
				download_select ${g_QUERY_KEY}
			fi
		fi
	done
else # Args passed
	_CMD_LINE_ARGS=true
	if [[ ${g_GOT_URL} == 'true' ]];then
		g_QUERY_KEY="URL"
		query_${g_QRY_ENGINE} ${URL}
	else
		g_QUERY_KEY="${@}"
		query_${g_QRY_ENGINE} ${g_QUERY_KEY}
	fi
	if [[ ${?} -eq 0 ]];then
		[[ ${g_GOT_URL} == 'false' ]] && fav_set ${g_QUERY_KEY}
		download_select ${g_QUERY_KEY}
	fi
fi

log_clear "normal exit"

exit_leave
