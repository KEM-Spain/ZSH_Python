#!/usr/bin/zsh
 
# Imports
[[ -z ${ZSH_LIB_DIR} ]] && _LIB_DIR=/usr/local/lib || _LIB_DIR=${ZSH_LIB_DIR}
source ${_LIB_DIR}/LIB_INIT.zsh # Must be first
source ${_LIB_DIR}/UTILS.zsh
source ${_LIB_DIR}/LIST.zsh
source ${_LIB_DIR}/SELECT.zsh
source ${_LIB_DIR}/LIB_DEPS.zsh # Must be last

typeset -A _FAV_LIST=()

_CFG_DIR=~/.local/share/yts
_YTS_FAVORITES=${_CFG_DIR}/yts.favorites
_YTS_DBG_LOG=/tmp/yt.dbg.log
g_QRY_ENGINE=''
g_QUERY_KEY=''
g_STRICT=''
g_PREFER_LIVE=''

fav_delete () {
	local FAV=${1:gs/ /_/:l}
	local ENG=''
	local LINE
	local F1 F2 F3

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"

	cp ${_YTS_FAVORITES} ${_YTS_FAVORITES}.bak
	logit ${_YTS_DBG_LOG} "${0}: log ${_YTS_FAVORITES} was copied"

	[[ ${g_QRY_ENGINE} == 'rumble' ]] && ENG="R" || ENG="Y"
	logit ${_YTS_DBG_LOG} "${0}: engine:${g_QRY_ENGINE}"

	msg_box -p -PD "Deleting: ${FAV} for ${(C)g_QRY_ENGINE}?"
	logit ${_YTS_DBG_LOG} "${0}: deleting ${FAV} decoded to ${FAV}"

	if [[ ${_MSG_KEY} == 'y' ]];then
		if [[ -s ${_YTS_FAVORITES} ]];then
			[[ -e /tmp/favlist.new ]] && /bin/rm -f /tmp/favlist.new
			while read LINE;do
				F1=$(cut -d '|' -f1 <<<${LINE})
				F2=$(cut -d '|' -f2 <<<${LINE})
				F3=$(cut -d '|' -f3 <<<${LINE})
				[[ ${F1:l} == ${FAV} && ${F3:l} =~ ${ENG:l} ]] && continue
				echo ${LINE} >> /tmp/favlist.new
			done < ${_YTS_FAVORITES}
			diff -q /tmp/favlist.new ${_YTS_FAVORITES} >/dev/null 2>&1
			if [[ ${?} -eq 0 ]];then
				logit ${_YTS_DBG_LOG} "${0}: log ${_YTS_FAVORITES} was NOT updated - ${FAV} not found"
			else
				mv -f /tmp/favlist.new ${_YTS_FAVORITES}
				logit ${_YTS_DBG_LOG} "${0}: log ${_YTS_FAVORITES} updated"
				fav_load
			fi
		else
			exit_leave "No favorites have been saved"
		fi
	fi
}

fav_get () {
	local -A QUERY_KEYS=()
	local -A QUERY_OPTS=()
	local -a LIST=()
	local C_MSG=''
	local D_KEY=''
	local ENGINE=''
	local FTR=''
	local HDR=''
	local LTYPE=y
	local MAP=''
	local OPTS=''
	local O_COLOR=''
	local Q_KEY=''
	local Q_OPT=''
	local Q_OPT_EXT=''
	local TAG=''
	local L

	while true;do
		LIST=()
		QUERY_KEYS=()
		QUERY_OPTS=()
		g_PREFER_LIVE=false
		g_QRY_ENGINE=''
		g_STRICT=false

		for L in ${(k)_FAV_LIST};do
			D_KEY=${L:gs/_/ /}
			Q_KEY=$(cut -d: -f1 <<<${_FAV_LIST[${L}]})
			Q_OPT=$(cut -d: -f2 <<<${_FAV_LIST[${L}]:l})
			if [[ ${LTYPE} == 'c' && ${Q_OPT[1]} == 'p' ]];then # (Future: change favorite code to 'c')
				#set -xv
				LIST+=${D_KEY}
				QUERY_KEYS[${D_KEY}]=${Q_KEY}
				QUERY_OPTS[${D_KEY}]=${Q_OPT}
				O_COLOR=${RED_FG}
				C_MSG=" <I>(Custom List)<N> "
				#set +xv;read
			elif [[ ${LTYPE} == 'y' && ${Q_OPT[1]} == 'y' ]];then
				LIST+=${D_KEY}
				QUERY_KEYS[${D_KEY}]=${Q_KEY}
				QUERY_OPTS[${D_KEY}]=${Q_OPT}
				ENGINE=youtube
				O_COLOR=${CYAN_FG}
				C_MSG=''
			elif [[ ${LTYPE} == 'r' && ${Q_OPT[1]} == 'r' ]];then
				LIST+=${D_KEY}
				QUERY_KEYS[${D_KEY}]=${Q_KEY}
				QUERY_OPTS[${D_KEY}]=${Q_OPT}
				ENGINE=rumble
				O_COLOR=${MAGENTA_FG}
				C_MSG=''
			fi
		done

		sel_set_list ${(o)LIST}
		sel_set_app_keys d r y c

		clear

		HDR="${BOLD}${(C)ENGINE}${C_MSG} Query"
		MAP="(<w>r<N>)umble list, (<w>y<N>)outube list, (<w>c<N>)ustom list, (<w>d<N>)elete favorite"
		FTR="<w>Run ${(C)ENGINE} query from history or <h>(q)uit<N>"
		TAG=$(tr -d '[:space:]' <<<${HDR})

		msg_line_weight heavy
		list_set_restore_pos_reset # Fresh list - position at top
		sel_list -R -S -T${TAG} -O${O_COLOR} -H${HDR} -M${MAP} -F${FTR}
		msg_line_weight light

		[[ ${_SEL_KEY} == 'd' ]] && fav_delete ${_SEL_VAL}
		[[ ${_SEL_KEY} =~ 'y|r|c' ]] && LTYPE=${_SEL_KEY}

		if [[ ${_SEL_KEY} == '?' ]];then
			g_QRY_ENGINE=${ENGINE}
			g_QUERY_KEY=${QUERY_KEYS[${_SEL_VAL}]}
			OPTS=${QUERY_OPTS[${_SEL_VAL}]}
			if [[ ${OPTS[1]} == 'p' ]];then
				[[ ${OPTS[2]} == 'y' ]] && g_QRY_ENGINE=youtube || g_QRY_ENGINE=rumble
				OPTS=${OPTS[3,-1]}
			else
				OPTS=${OPTS[2,-1]}
			fi
			[[ ${OPTS} == 's' ]] && g_STRICT=true
			[[ ${OPTS} == 'l' ]] && g_PREFER_LIVE=true
			break
		fi
	done
}

fav_load () {
	local LINE
	local D_KEY
	local Q_KEY
	local Q_OPT

	_FAV_LIST=()

	while read LINE;do
		D_KEY=$(cut -d'|' -f1 <<<${LINE})
		Q_KEY=$(cut -d'|' -f2 <<<${LINE})
		Q_OPT=$(cut -d'|' -f3 <<<${LINE})
		_FAV_LIST[${D_KEY}]="${Q_KEY}:${Q_OPT}"
	done < ${_YTS_FAVORITES}
}

fav_add () {
	local FAV=$(str_trim ${1:gs/ /_/})
	local -aU HISTORY
	local LINE
	local H

	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${functrace[1]} called ${0}:${LINENO}: ARGC:${#@}"
	[[ ${_DEBUG} -ge ${_LOW_DBG} ]] && dbg "${0}:${LINENO} ARG: FAV:${FAV} g_QRY_ENGINE:${g_QRY_ENGINE}"

#	msg_box -H1 -p -PC "<w><I>Please respond<N>|<Z>|Add ${(C)${FAV:gs/_/ /}} to favorites?"
#	msg_box_clear
#	tput rc
#	case ${_MSG_KEY} in
#		1) YouTube;;
#		2) Rumble;;
#		3) Custom;;
#		*) echo; exit_leave $(msg_warn "Operation Cancelled");;
#	esac

	msg_box -H1 -p -PC "<w><I>Please respond<N>|<Z>|Add ${(C)${FAV:gs/_/ /}} to favorites?"
	[[ ${_MSG_KEY} != 'y' ]] && return

	# R   - Rumble list  - channel/user query
	# RL  - Rumble list  - livestream
	# Y   - YouTube list - no strict
	# YS  - YouTube list - strict
	# PY  - Custom list  - no strict
	# PYS - Custom list  - YouTube No Strict
	# PR  - Custom list  - Rumble
	# PRL - Custom list  - Rumble livestream
	
	if [[ ${g_QRY_ENGINE:l} == 'rumble' ]];then
		[[ ${g_PREFER_LIVE} == 'true' ]] && FAV="${(C)FAV}|${FAV}|RL" || FAV="${(C)FAV}|${FAV}|R" 
	else
		if [[ ${FAV} =~ ' ' ]];then
			FAV="${(C)FAV}|${FAV}|PYNS" # Quoted string
		else
			[[ ${g_STRICT} == 'true' ]] && FAV="${(C)FAV}|${FAV}|YS" || FAV="${(C)FAV}|${FAV}|YNS"
		fi
	fi

	HISTORY+=${FAV}

	if [[ -e ${_YTS_FAVORITES} ]];then
		while read LINE;do
			HISTORY+=${LINE}
		done < ${_YTS_FAVORITES}

		/bin/rm -f ${_YTS_FAVORITES}
	fi

	for H in ${(o)HISTORY};do
		echo ${H} >> ${_YTS_FAVORITES}
	done

	sort -o ${_YTS_FAVORITES} -t'|' -k3 ${_YTS_FAVORITES} 
}

g_QRY_ENGINE=rumble
fav_load
fav_get
