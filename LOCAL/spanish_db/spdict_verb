#!/usr/bin/zsh
# Inline ansi
BOLD="\033[1m"
ITALIC="\033[3m"
RESET="\033[m"
REVERSE="\033[7m"
STRIKE="\033[9m"
UNDER="\033[4m"
BLACK_BG="\033[40m"
BLUE_FG="\033[34m"
CYAN_FG="\033[36m"
GREEN_FG="\033[32m"
MAGENTA_FG="\033[35m"
RED_FG="\033[31m"
WHITE_FG="\033[37m"
YELLOW_FG="\033[33m"
CSR_OFF="\033[?25l"
CSR_ON="\033[?25h"

# Imports
[[ -z ${ZSH_LIB_DIR} ]] && _LIB_DIR=/usr/local/lib || _LIB_DIR=${ZSH_LIB_DIR}
source ${_LIB_DIR}/LIB_INIT.zsh # Must be first
source ${_LIB_DIR}/UTILS.zsh
source ${_LIB_DIR}/LIB_DEPS.zsh # Must be last

# Declarations
typeset -a _LINE_MAP=(2 5 5 5 5 5 5 4 4 4 4 4 4 2 2 2 2 2 5 5 5 5 5 5 5 5 5 5 5 5 4 4 4 4 4 4 6)
typeset -a _BLOCKS=()
typeset -A _BLOCK_HDRS=(GP "Gerund & Participle" IND "Indicative" SUBJ "Subjunctive" IMP "Imperative" PROG "Progressive" PERF "Perfect" PSUBJ "Perfect Subjunctive" INFFUT "Informal Future")
typeset -A _COL_HDRS=(GP HDR1 IND HDR2 SUBJ HDR3 IMP HDR4 PROG HDR2 PERF HDR2 PSUBJ HDR5 INFFUT HDR6)
typeset -A _HDR_DEFS=(HDR1 "Gerund|Participle" HDR2 "Present|Preterite|Imperfect|Conditional|Future" HDR3 "Present|Imperfect|Imperfect2|Future" HDR4 "Affirmative|Negative" HDR5 "Present|Past|Past2|Future" HDR6 "Yo|Tú|El|Nosotros|Vosotros|Ellos")
typeset -A _SECTION_LONGEST=()
typeset -A _HEADER_LONGEST=()
typeset -a _LIST

# Vars
_VERB_ARG=''
_V_TYPE=''
_V_TYPE_LBL=''
_EXIT_MSG=''
_EXIT_CODE=0

# Functions
export_block () {
	local SECTION=${1}
	local B 

	for (( B=1; B<=${SECTION_ROWS[${SECTION}]}; B++ ));do # Output blocks
		[[ ${SECTION} == 'GP' ]] && continue
		[[ ${SECTION} == 'INFFUT' ]] && continue
		case ${B} in
			1) [[ -n ${COL1} ]] && export_col_out ${SECTION} ${B} ${COL1};;
			2) [[ -n ${COL2} ]] && export_col_out ${SECTION} ${B} ${COL2};;
			3) [[ -n ${COL3} ]] && export_col_out ${SECTION} ${B} ${COL3};;
			4) [[ -n ${COL4} ]] && export_col_out ${SECTION} ${B} ${COL4};;
			5) [[ -n ${COL5} ]] && export_col_out ${SECTION} ${B} ${COL5};;
			6) [[ -n ${COL6} ]] && export_col_out ${SECTION} ${B} ${COL6};;
		esac
	done
}

export_col_out () {
	local SECTION=${1} && shift
	local ROW=${1} && shift
	local -a COL_DATA=(${@})
	local -a IMP_ELEM=()
	local NDX=0
	local KEY=''
	local EXP_LBL=''
	local X
	local -A SECTION_LBLS=(	IND1 Present IND2 Preterite IND3 Imperfect IND4 Conditional IND5 Future
									SUBJ1 Present SUBJ2 Imperfect SUBJ3 Imperfect2 SUBJ4 Future
									IMP1 Affirmative IMP2 Negative 
									PROG1 Present PROG2 Preterite PROG3 Imperfect PROG4 Conditional PROG5 Future
									PERF1 Present PERF2 Preterite PERF3 Imperfect PERF4 Conditional PERF5 Future
									PSUBJ1 Present PSUBJ2 Past PSUBJ3 Past2 PSUBJ4 Future)

	EXP_LBL=${${_BLOCK_HDRS[${SECTION}]}:l} # Label default
	[[ ${${_BLOCK_HDRS[${SECTION}]}:l} == 'perfect subjunctive' ]] && EXP_LBL='perfect_subj' # Patch label

	if [[ ${EXP_LBL} == 'imperative' ]];then
		COL_DATA=('---' ${COL_DATA[1]} ${COL_DATA[2]} ${COL_DATA[3]} ${COL_DATA[4]} ${COL_DATA[5]}) # Patch imperative
	fi

	printf "%s,%s,%s," ${_VERB_ARG} ${EXP_LBL} ${${SECTION_LBLS[${SECTION}${ROW}]}:l}
	if [[ -n ${COL_DATA} ]];then
		for X in ${COL_DATA};do 
			(( NDX++ )) 
			printf "%s," "${X:s/ /_/}"
		done
		printf "%s\n" "${_V_TYPE}"
	fi
}

format_export () {
	local LINE_NO=1
	local -a COL1=()
	local -a COL2=()
	local -a COL3=()
	local -a COL4=()
	local -a COL5=()
	local -a COL6=()
	local -A SECTION_COLS=(GP 2 IND 5 SUBJ 4 IMP 2 PROG 5 PERF 5 PSUBJ 4 INFFUT 6)
	local -A SECTION_ROWS=(GP 2 IND 6 SUBJ 6 IMP 5 PROG 6 PERF 6 PSUBJ 6 INFFUT 6)
	local LAST_NDX=1
	local LAST_SECTION=?
	local LOOP=0
	local LNDX=0
	local NDX=0
	local PRE_SCAN=true
	local SECTION=''
	local C L R X B
	local COL_ARR=''
	local TRANS=$(pup --charset utf8 'div[id="quickdef1-es"] text{}' < ${_VERB_ARG}.html)

	_BLOCKS=()
	LINE_NO=1
	LAST_NDX=1
	LAST_SECTION=?
	NDX=0
	R=1

	for L in ${_LINE_MAP};do
		case ${LINE_NO} in
			1) SECTION=GP;;
			<2-7>) SECTION=IND;;
			<8-13>) SECTION=SUBJ;;
			<14-18>) SECTION=IMP;;
			<19-24>) SECTION=PROG;;
			<25-30>) SECTION=PERF;;
			<31-36>) SECTION=PSUBJ;;
			37) SECTION=INFFUT;;
		esac

		(( R++ ))
		for (( LNDX=LAST_NDX; LNDX<=L; LNDX++ ));do
			(( NDX++ ))
			_BLOCKS+="${_LIST[${NDX}]}"
		done

		if [[ ${LAST_SECTION} != ${SECTION} ]];then
			LAST_SECTION=${SECTION}
			COL1=()
			COL2=()
			COL3=()
			COL4=()
			COL5=()
			COL6=()
		fi

		for (( C=1; C<=${SECTION_COLS[${SECTION}]}; C++ ));do # Marshall columns
			case ${C} in
				1) COL1+=${_BLOCKS[${C}]};;
				2) COL2+=${_BLOCKS[${C}]};;
				3) COL3+=${_BLOCKS[${C}]};;
				4) COL4+=${_BLOCKS[${C}]};;
				5) COL5+=${_BLOCKS[${C}]};;
				6) COL6+=${_BLOCKS[${C}]};;
			esac
		done

		if [[ ${SECTION} == 'GP' ]];then # Create ${_VERB_ARG}_verb.dat
			echo "${_VERB_ARG},${COL1},${COL2},${_V_TYPE},${(qqq)TRANS}" > ${_VERB_ARG}_verb.dat
		fi

		if [[ ${R} -eq ${SECTION_ROWS[${SECTION}]} ]];then
			export_block ${SECTION}
			R=0
		fi

		(( LINE_NO++ ))
		_BLOCKS=()
	done
	export_block ${SECTION} # Last section
}

format_markdown () {
	local BLOCK=1
	local LAST_NDX=1
	local LAST_SECTION=?
	local LOOP=0
	local LNDX=0
	local NDX=0
	local SECTION=''
	local TRANS=$(pup --charset utf8 'div[id="quickdef1-es"] text{}' < ${_VERB_ARG}.html)
	local L

	set_section_longest # Find longest text per section

	echo "#### Verb: ${(C)_VERB_ARG}"
	echo "**Translation**: ${(C)TRANS}"
	echo "**Conjugation**: ${(C)_V_TYPE_LBL}"

	_BLOCKS=()
	_BLOCKS+="|"
	BLOCK=1
	LAST_NDX=1
	LAST_SECTION=?
	NDX=0

	for L in ${_LINE_MAP};do
		case ${BLOCK} in
			1) SECTION=GP;;
			<2-7>) SECTION=IND;;
			<8-13>) SECTION=SUBJ;;
			<14-18>) SECTION=IMP;;
			<19-24>) SECTION=PROG;;
			<25-30>) SECTION=PERF;;
			<31-36>) SECTION=PSUBJ;;
			37) SECTION=INFFUT;;
		esac

		for (( LNDX=LAST_NDX; LNDX<=L; LNDX++ ));do
			(( NDX++ ))
			_BLOCKS+="${_LIST[${NDX}]}|"
		done

		if [[ ${LAST_SECTION} != ${SECTION} ]];then
			[[ -z ${_SECTION_LONGEST[${SECTION}]} ]] && exit_leave $(err_msg_exit "Invalid verb:${_VERB_ARG}")
			echo "\n#### ${_BLOCK_HDRS[${SECTION}]}"
			echo "|${_HDR_DEFS[${_COL_HDRS[${SECTION}]}]}|"
			markdown_header $(( ${#_BLOCKS} - 1 )) ${_SECTION_LONGEST[${SECTION}]}
			LAST_SECTION=${SECTION}
		fi

		echo "${_BLOCKS}" | sed 's/| /|/g'

		(( BLOCK++ ))
		_BLOCKS=()
		_BLOCKS+="|"
	done
}

format_pretty () {
	local -A ROW_LBLS=(1 Yo 2 Tú 3 El 4 Nosotros 5 Vosotros 6 Ellos)
	local -a HDR_SEP=()
	local CNT=1
	local COL_NDX=0
	local HDR_PARSE=''
	local HPF=''
	local LAST_NDX=1
	local LAST_SECTION=?
	local LINE_NO=1
	local LOOP=0
	local NDX=0
	local PF=''
	local ROW_NDX=0
	local SECTION=''
	local TRANS=$(pup --charset utf8 'div[id="quickdef1-es"] text{}' < ${_VERB_ARG}.html)
	local IMP_OFF=false
	local L

	set_section_longest # Find longest text per section

	echo "${WHITE_FG}Verb${RESET}:${(C)_VERB_ARG}"
	echo "${WHITE_FG}Translation${RESET}:${(C)TRANS}"
	echo "${WHITE_FG}Conjugation${RESET}:${(C)_V_TYPE_LBL}"

	_BLOCKS=()
	LINE_NO=1
	LAST_NDX=1
	LAST_SECTION=?
	NDX=0
	ROW_NDX=0

	for L in ${_LINE_MAP};do
		case ${LINE_NO} in
			1) SECTION=GP;;
			<2-7>) SECTION=IND;;
			<8-13>) SECTION=SUBJ;;
			<14-18>) SECTION=IMP;;
			<19-24>) SECTION=PROG;;
			<25-30>) SECTION=PERF;;
			<31-36>) SECTION=PSUBJ;;
			37) SECTION=INFFUT;;
		esac

		[[ ${LAST_SECTION} != ${SECTION} ]] && ROW_NDX=1 || (( ROW_NDX++ ))
		PF="printf \"${WHITE_FG}%-10s${RESET} " # Retain label
		HPF="printf \"${WHITE_FG}%-10s " # Retain label
		HDR_SEP='" " '

		case ${SECTION} in
				 GP) PF='printf "'
					  HPF='printf "${WHITE_FG}'
					  HDR_SEP=''
					  HDR_PARSE="$(sed -e 's/|/\" \"/g' -e 's/^/\"/' -e 's/$/\"/' <<<${_HDR_DEFS[${_COL_HDRS[${SECTION}]}]})"
					  ;; # Remove label 

			INFFUT) PF='printf "'
					  HPF='printf "${WHITE_FG}'
					  HDR_SEP=''
					  HDR_PARSE="$(sed -e 's/|/\" \"/g' -e 's/^/\"/' -e 's/$/\"/' <<<${_HDR_DEFS[${_COL_HDRS[${SECTION}]}]})"
					  ;; # Remove label 

				  *) [[ ${SECTION} == 'IMP' && ${IMP_OFF} == 'false' ]] && (( ROW_NDX++ )) && IMP_OFF=true
					  _BLOCKS="\"${ROW_LBLS[${ROW_NDX}]}\" "
					  HDR_PARSE="$(sed -e 's/|/\" \"/g' -e 's/^/\" \" \"/' -e 's/$/\"/' <<<${_HDR_DEFS[${_COL_HDRS[${SECTION}]}]})"
					  ;;
		esac

		for (( COL_NDX=LAST_NDX; COL_NDX<=L; COL_NDX++ ));do
			(( NDX++ ))
			_BLOCKS+="\"${_LIST[${NDX}]}\" "
			HDR_SEP+="\$(str_unicode_line $(( ${_SECTION_LONGEST[${SECTION}]} + 1 ))) "
			PF+="%$(( ${_SECTION_LONGEST[${SECTION}]} + 1 ))s " # Add PF slots
			HPF+="%$(( ${_SECTION_LONGEST[${SECTION}]} + 1 ))s " # Add HPF slots
		done

		PF+="\\\n\"" # Terminate PF
		HPF+="${RESET}\\\n\"" # Terminate HPF

		if [[ ${LAST_SECTION} != ${SECTION} ]];then
			[[ -z ${_SECTION_LONGEST[${SECTION}]} ]] && exit_leave $(err_msg_exit "Invalid verb:${_VERB_ARG}")
			printf "%s\n" "<SEP>"
			echo "\n${BOLD}${CYAN_FG}${_BLOCK_HDRS[${SECTION}]}${RESET}"
			eval "${HPF} ${HDR_PARSE}"
			eval "${HPF} ${HDR_SEP}"
			LAST_SECTION=${SECTION}
		fi

		eval "${PF} ${_BLOCKS}"

		(( LINE_NO++ ))
		_BLOCKS=()
		PF='printf "${WHITE_FG}%-10s${RESET} ' # Initialize PF
		HPF='printf "%-10s ' # Initialize HPF
		HDR_SEP='" " '
	done

}

format_vertical () {
	local LINE_NO=1
	local -a COL1=()
	local -a COL2=()
	local -a COL3=()
	local -a COL4=()
	local -a COL5=()
	local -a COL6=()
	local -A SECTION_COLS=(GP 2 IND 5 SUBJ 4 IMP 2 PROG 5 PERF 5 PSUBJ 4 INFFUT 6)
	local -A SECTION_ROWS=(GP 2 IND 6 SUBJ 6 IMP 5 PROG 6 PERF 6 PSUBJ 6 INFFUT 6)
	local LAST_NDX=1
	local LAST_SECTION=?
	local LOOP=0
	local LNDX=0
	local NDX=0
	local PRE_SCAN=true
	local SECTION=''
	local TRANS=$(pup --charset utf8 'div[id="quickdef1-es"] text{}' < ${_VERB_ARG}.html)
	local C L R X B
	local COL_ARR=''


	echo "${WHITE_FG}Verb${RESET}:${(C)_VERB_ARG}"
	echo "${WHITE_FG}Translation${RESET}:${(C)TRANS}"
	echo "${WHITE_FG}Conjugation${RESET}:${(C)_V_TYPE_LBL}\n"

	_BLOCKS=()
	LINE_NO=1
	LAST_NDX=1
	LAST_SECTION=?
	NDX=0
	R=1

	for L in ${_LINE_MAP};do
		case ${LINE_NO} in
			1) SECTION=GP;;
			<2-7>) SECTION=IND;;
			<8-13>) SECTION=SUBJ;;
			<14-18>) SECTION=IMP;;
			<19-24>) SECTION=PROG;;
			<25-30>) SECTION=PERF;;
			<31-36>) SECTION=PSUBJ;;
			37) SECTION=INFFUT;;
		esac
		#echo "LINE_NO:${LINE_NO} L:${L} R:${R} SECTION:${SECTION}"

		(( R++ ))
		for (( LNDX=LAST_NDX; LNDX<=L; LNDX++ ));do
			(( NDX++ ))
			_BLOCKS+="${_LIST[${NDX}]}"
		done

		if [[ ${LAST_SECTION} != ${SECTION} ]];then
			LAST_SECTION=${SECTION}
			COL1=()
			COL2=()
			COL3=()
			COL4=()
			COL5=()
			COL6=()
		fi

		for (( C=1; C<=${SECTION_COLS[${SECTION}]}; C++ ));do # Marshall columns
			case ${C} in
				1) COL1+=${_BLOCKS[${C}]};;
				2) COL2+=${_BLOCKS[${C}]};;
				3) COL3+=${_BLOCKS[${C}]};;
				4) COL4+=${_BLOCKS[${C}]};;
				5) COL5+=${_BLOCKS[${C}]};;
				6) COL6+=${_BLOCKS[${C}]};;
			esac
		done

		if [[ ${R} -eq ${SECTION_ROWS[${SECTION}]} ]];then
			vertical_block ${SECTION} ${R}
			echo "<SEP>"
			R=0
		fi

		(( LINE_NO++ ))
		_BLOCKS=()
	done
	vertical_block ${SECTION} # Last section
	echo "<SEP>"
}

markdown_header () {
	local COLS=${1}
	local WIDTH=${2}
	local COL
	local -a MARKDOWN=('|')

	for (( COL=1; COL<=${COLS}; COL++ ));do
		MARKDOWN+="$(str_rep_char "-" ${WIDTH})|"
	done

	tr -d '[:space:]' <<<${MARKDOWN};echo
}

output_vector () {
	local STYLE=${1}
	local CLIPBOARD=${2}
	local -a OUTPUT=()
	local TXT=''
	local L

	case ${STYLE} in
		vertical) OUTPUT=("${(f)$(format_vertical)}");;
		markdown) OUTPUT=("${(f)$(format_markdown)}");;
		pretty) OUTPUT=("${(f)$(format_pretty)}");;
	esac

	if [[ ${CLIPBOARD} == 'true' ]];then
		for L in ${OUTPUT};do
			TXT=$(str_no_ansi ${L})
			[[ ${L} == '<SEP>' ]] && echo && continue
			echo ${TXT}
		done | gpaste-client
		_EXIT_MSG="Output was sent to clipboard"
	else
		for L in ${OUTPUT};do
			[[ ${L} == '<SEP>' ]] && echo && continue
			echo ${L}
		done | mypager
	fi
}

section_break () {
	local SECTION=${1}

	[[ ${SECTION} == 'GP' || ${SECTION} == 'INFFUT' ]] && return || echo "<SEP>"
}

set_section_longest () {
	local COL_NDX=0
	local LONGEST_HDR=0
	local LAST_NDX=1
	local LAST_SECTION=?
	local LINE_NO=1
	local NDX=0
	local SECTION=''
	local -a SECTION_HDRS=()
	local L

	for L in ${_LINE_MAP};do
		case ${LINE_NO} in
			1) SECTION=GP;;
			<2-7>) SECTION=IND;;
			<8-13>) SECTION=SUBJ;;
			<14-18>) SECTION=IMP;;
			<19-24>) SECTION=PROG;;
			<25-30>) SECTION=PERF;;
			<31-36>) SECTION=PSUBJ;;
			37) SECTION=INFFUT;;
		esac

		SECTION_HDRS=($(sed -e 's/|/ /g' <<<${_HDR_DEFS[${_COL_HDRS[${SECTION}]}]}))
		LONGEST_HDR=$(arr_long_elem_len ${SECTION_HDRS})

		for (( COL_NDX=LAST_NDX; COL_NDX<=L; COL_NDX++ ));do
			(( NDX++ ))
			[[ ${#_LIST[${NDX}]} -gt ${_SECTION_LONGEST[${SECTION}]} ]] && _SECTION_LONGEST[${SECTION}]=${#_LIST[${NDX}]}
			[[ ${LONGEST_HDR} -gt ${_SECTION_LONGEST[${SECTION}]} ]] &&  _SECTION_LONGEST[${SECTION}]=${LONGEST_HDR}
		done

		if [[ ${LAST_SECTION} != ${SECTION} ]];then
			LAST_SECTION=${SECTION}
		fi

		(( LINE_NO++ ))
	done
}

vertical_block () {
	local SECTION=${1}
	local B 

	echo "${BOLD}${UNDER}${_BLOCK_HDRS[${SECTION}]}${RESET}"
	for (( B=1; B<=${SECTION_ROWS[${SECTION}]}; B++ ));do # Output blocks
		case ${B} in
			1) [[ -n ${COL1} ]] && vertical_col_out ${SECTION} ${B} ${COL1};;
			2) [[ -n ${COL2} ]] && vertical_col_out ${SECTION} ${B} ${COL2};;
			3) [[ -n ${COL3} ]] && vertical_col_out ${SECTION} ${B} ${COL3};;
			4) [[ -n ${COL4} ]] && vertical_col_out ${SECTION} ${B} ${COL4};;
			5) [[ -n ${COL5} ]] && vertical_col_out ${SECTION} ${B} ${COL5};;
			6) [[ -n ${COL6} ]] && vertical_col_out ${SECTION} ${B} ${COL6};;
		esac
	done
}

vertical_col_out () {
	local SECTION=${1} && shift
	local ROW=${1} && shift
	local -a COL_DATA=(${@})
	local -A ROW_LBLS=(1 Yo 2 Tú 3 El 4 Nosotros 5 Vosotros 6 Ellos)
	local -A INF_LBLS=(voy Yo vas Tú va El vamos Nosotros vais Vosotros van Ellos)
	local -A GP_LBLS=(1 Gerund 2 Participle)
	local NDX=0
	local KEY=''
	local IMP_OFF=false
	local X
	local -A SECTION_LBLS=(	IND1 Present IND2 Preterite IND3 Imperfect IND4 Conditional IND5 Future
									SUBJ1 Present SUBJ2 Imperfect SUBJ3 Imperfect2 SUBJ4 Future
									IMP1 Affirmative IMP2 Negative 
									PROG1 Present PROG2 Preterite PROG3 Imperfect PROG4 Conditional PROG5 Future
									PERF1 Present PERF2 Preterite PERF3 Imperfect PERF4 Conditional PERF5 Future
									PSUBJ1 Present PSUBJ2 Past PSUBJ3 Past2 PSUBJ4 Future)

	if [[ ${SECTION} == 'GP' ]];then # Special handler
		printf "%-10s: %s\n"  "${GP_LBLS[${ROW}]}" "${COL_DATA}"
		return
	fi

	if [[ ${SECTION} == 'INFFUT' ]];then # Special handler
		KEY=$(cut -d' ' -f1 <<<${COL_DATA})
		for X in ${COL_DATA};do
			printf "%-10s: %s\n"  "${INF_LBLS[${KEY}]}" "${COL_DATA}"
		done
		return
	fi

	echo "${ITALIC}${SECTION_LBLS[${SECTION}${ROW}]}${RESET}"
	if [[ -n ${COL_DATA} ]];then
		for X in ${COL_DATA};do 
			(( NDX++ )) 
			[[ ${SECTION} == 'IMP' && ${IMP_OFF} == 'false' ]] && (( NDX++ )) && IMP_OFF=true
			printf "%-10s: %s\n" ${ROW_LBLS[${NDX}]} "${X}"
		done
		section_break ${SECTION}
	fi
}

#--Begin GetOpts--
local -a OPTIONS
local OPTION
local DESC

read -r -d '' DESC<<EOF
Extract data from spanishdict.com
\tOutput formats vary per option selected
EOF

parse_opts () {
	local OPTS=${@}
	local -a OPTSTR
	local LETTER_OPT
	local O

	for O in {1..${#OPTS}};do
		[[ ${OPTS[${O}]} =~ '[A-Za-z]' ]] && LETTER_OPT=${OPTS[${O}]}
		[[ ${O} -eq 1 && ${OPTS[${O}]} == ":" ]] && continue
		[[ ${O} -gt 1 && ${OPTS[${O}]} == ":" ]] && OPTSTR+=$(opt_type ${LETTER_OPT}) && continue
		OPTSTR+="-${OPTS[${O}]}"
	done
	echo ${OPTSTR}
}

opt_exists () {
	local OPT=${1}
	[[ $(( $OPTIONS[(Ie)${OPT}] )) -ne 0 ]] && return 0 || return 1
}

opt_type () {
	local OPT=${1}
	case ${OPT} in
		d) echo "<DIR>";;
		f) echo "<FILE>";;
		t) echo "<FILE_TYPE>";;
	esac
}

usage () {
	local -a PENDING_MSGS=(${@})
	local OPTS=$(parse_opts ${OPTSTR})

	[[ ${_SMCUP} == 'true' ]] && do_rmcup

	tabs 5
	(
	echo -e "\n${WHITE_FG}\nUsage${RESET}: ${_SCRIPT} ${WHITE_FG}[${RESET}${OPTS}${WHITE_FG}]${RESET} <VERB>\n"
	echo -e "${WHITE_FG}-H${RESET} help"
	echo -e "${WHITE_FG}-D${RESET} debug (repeats increase level)"
	echo -e "${WHITE_FG}-c${RESET} send output to clipboard"
	echo -e "${WHITE_FG}-e${RESET} data export output"
	echo -e "${WHITE_FG}-m${RESET} markdown output"
	echo -e "${WHITE_FG}-p${RESET} prettified output"
	echo -e "${WHITE_FG}-v${RESET} vertical output"
	echo -e "\n${WHITE_FG}DESC${RESET}:${DESC}"
	) >&2

	exit_leave ${PENDING_MSGS}
}

OPTSTR=":HDcempv"
OPTIND=0

CLIPBOARD=false
EXPORT=false
STYLE=vertical

while getopts ${OPTSTR} OPTION;do
	case $OPTION in
     H) usage;;
     D) dbg_set_level;;
     c) CLIPBOARD=true;;
     e) EXPORT=true;;
     m) STYLE=markdown;;
     p) STYLE=pretty;;
     v) STYLE=vertical;;
     :) print -u2 "${_SCRIPT_TAG} ${BOLD}${RED_FG}Option error${RESET}: -${OPTARG} requires an argument"; usage;;
    \?) print -u2 "${_SCRIPT_TAG} ${BOLD}${RED_FG}Unknown option${RESET} - ${OPTARG}"; usage;;
	esac
	[[ ${OPTION} != 'D' ]] && OPTIONS+=${OPTION}
done
shift $((OPTIND -1))
#--End GetOpts--

# Execution
[[ ${#} -ne 0 ]] && _VERB_ARG=${1} || usage "${_SCRIPT_TAG}${RED_FG}Missing argument${RESET}:<VERB>"
[[ -z ${OPTIONS} ]] && VERTICAL=true # Default format

curl -sA "Chrome" -L  "https://www.spanishdict.com/conjugate/${_VERB_ARG}" > ${_VERB_ARG}.html
grep -q 'data-is_found="0"\|mismatch-spelling-suggestion' ${_VERB_ARG}.html
[[ ${?} -eq 0 ]] && exit_leave $(err_msg_exit "Unable to find verb:${_VERB_ARG}")
 
_LIST=("${(f)$(pup --charset utf8 'a attr{aria-label}' < ${_VERB_ARG}.html | grep '^[a-z]' | head -n -1 )}")

if grep -q -m1 '"isIrregular":true' ${_VERB_ARG}.html;then
	_V_TYPE=1
	_V_TYPE_LBL="Irregular" 
else
	_V_TYPE=0
	_V_TYPE_LBL="Regular"
fi

if [[ ${EXPORT} == 'true' ]];then
	if [[ -s ${_VERB_ARG}_tense.dat && -s ${_VERB_ARG}_verb.dat ]];then
		format_export > ${_VERB_ARG}_tense.dat
		# TODO: This failed when last tested on verb fingir
		echo "Exported data for:${WHITE_FG}${_VERB_ARG}${RESET}"
		echo "Verb data:${WHITE_FG}${_VERB_ARG}_verb.dat${RESET} $(cut -d' ' -f1 <<<$(wc -l ${_VERB_ARG}_verb.dat)) line(s)"
		echo "Verb tenses:${WHITE_FG}${_VERB_ARG}_tense.dat${RESET} $(cut -d' ' -f1 <<<$(wc -l ${_VERB_ARG}_tense.dat)) line(s)"
		DATA=$(make_spanish_db -s ${_VERB_ARG})
		if [[ -n ${DATA} ]];then
			echo "Verb:${WHITE_FG}${_VERB_ARG}${RESET} exists"
			OPT='-u'
			OP='Update'
		else
			OPT='-a'
			OP='Append'
		fi
		respond "${OP} database"
		[[ ${?} -eq 0 ]] && make_spanish_db ${OPT} ${_VERB_ARG}
		_EXIT_CODE=0
	else
		_EXIT_CODE=1
	fi
else
	output_vector ${STYLE} ${CLIPBOARD}
fi

[[ -e ${_VERB_ARG}.html ]] && /bin/rm ${_VERB_ARG}.html

exit_leave ${_EXIT_CODE} ${_EXIT_MSG}

