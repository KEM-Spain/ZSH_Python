#!/usr/bin/zsh
# Inline ansi
BOLD="\033[1m"
ITALIC="\033[3m"
RESET="\033[m"
REVERSE="\033[7m"
STRIKE="\033[9m"
UNDER="\033[4m"
BLACK_BG="\033[40m"
BLUE_FG="\033[34m"
CYAN_FG="\033[36m"
GREEN_FG="\033[32m"
MAGENTA_FG="\033[35m"
RED_FG="\033[31m"
WHITE_FG="\033[37m"
YELLOW_FG="\033[33m"
CSR_OFF="\033[?25l"
CSR_ON="\033[?25h"

# Imports
[[ -z ${ZSH_LIB_DIR} ]] && _LIB_DIR=/usr/local/lib || _LIB_DIR=${ZSH_LIB_DIR}
source ${_LIB_DIR}/LIB_INIT.zsh # Must be first
source ${_LIB_DIR}/UTILS.zsh
source ${_LIB_DIR}/SELECT.zsh
source ${_LIB_DIR}/LIB_DEPS.zsh # Must be last

# Declarations
typeset -a _VERB_DATA=()
typeset -A _V_MAP=(VB 1 TY 2 CX 3 YO 4 YF 5 EL 6 WE 7 YP 8 TH 9 IR 10)
typeset -a _V_TYPES=(indicative perfect progressive imperative subjunctive perfect_subj all)
typeset -A _IND_CONTEXT_SORT=(present 1 preterite 2 imperfect 3 future 4 conditional 5 all 6)
typeset -A _IMP_CONTEXT_SORT=(affirmative 1 negative 2 all 3)
typeset -A _SUB_CONTEXT_SORT=(present 1 future 2 imperfect 3 imperfect2 4 all 5)
typeset -A _PSUB_CONTEXT_SORT=(future 1 past 2 present 3 all 4)
typeset -A _HDR_DATA=(GR 2 PR 3 IR 4 DF 5)
typeset -A _SP_TERMS=(
"indicative present" "presente"
"indicative preterite" "pret indefinido"
"indicative imperfect" "pret imperf"
"indicative future" "futuro simp"
"indicative conditional" "cond simp"
"perfect present" "pret perf"
"perfect preterite" "pret anterior"
"perfect imperfect" "pret pcp"
"perfect future" "futuro perf"
"perfect conditional" "cond perf"
"progressive present" "presente prog"
"progressive preterite" "pret perf simp"
"progressive imperfect" "pasado prog"
"progressive future" "futuro prog"
"progressive conditional" "cond prog"
"imperative affirmative" "imper afirmativo"
"imperative negative" "imper negativo"
"subjunctive present" "presente de subj"
"subjunctive future" "futuro simp de subj"
"subjunctive imperfect" "pret imperf de subj"
"subjunctive imperfect2" "pret imperf2 de subj"
"perfect_subj future" "futuro perf de subj"
"perfect_subj past" "pret pcp de subj"
"perfect_subj present" "pret perf subj"
)

# Functions
get_longest () {
	local LONGEST=0
	local -a FIELDS=(${=@})
	local F

	for F in ${FIELDS};do
		[[ ${#F} -gt ${LONGEST} ]] && LONGEST=${#F}
	done

	echo  ${LONGEST}
}

stack_tab () {
	local V_TYPE=${1}
	local V_CONTEXT=${2}
	local	VB TY CX YO YF EL WE YP TH IR GR
	local DEFN GRND PART IRRG
	local EN_HDR SP_HDR VB_HDR
	local OUT=false
	local T_NDX=0
	local L

	for L in ${_VERB_DATA};do
		VB=$(cut -d'|' -f${_V_MAP[VB]} <<<${L})
		TY=$(cut -d'|' -f${_V_MAP[TY]} <<<${L})
		CX=$(cut -d'|' -f${_V_MAP[CX]} <<<${L})
		YO=$(cut -d'|' -f${_V_MAP[YO]} <<<${L})
		YF=$(cut -d'|' -f${_V_MAP[YF]} <<<${L})
		EL=$(cut -d'|' -f${_V_MAP[EL]} <<<${L})
		WE=$(cut -d'|' -f${_V_MAP[WE]} <<<${L})
		YP=$(cut -d'|' -f${_V_MAP[YP]} <<<${L})
		TH=$(cut -d'|' -f${_V_MAP[TH]} <<<${L})
		IR=$(cut -d'|' -f10 <<<${L})
		GR=$(cut -d'|' -f6 <<<${L})

		if [[ ${OUT} == 'false' && -z ${EL} ]];then
			GRND=$(cut -d'|' -f${_HDR_DATA[GR]} <<<${L})
			PART=$(cut -d'|' -f${_HDR_DATA[PR]} <<<${L})
			IRRG=$(cut -d'|' -f${_HDR_DATA[IR]} <<<${L})
			DEFN=$(cut -d'|' -f${_HDR_DATA[DF]} <<<${L})
			DEFN=$(html2text <<<${DEFN})
			continue
		fi

		if [[ ${OUT} == 'false' ]];then
			[[ ${IRRG} == '1' ]] && IRRG='(irregular)' || IRRG='(regular)'
			echo "1    Verb:${VB} ${IRRG}"
			echo "2    Gerund:${GRND}"
			echo "3    Past Participle:${PART}"
			echo "4    Definition:${DEFN}"
			OUT=true
		fi

		[[ (-n ${V_TYPE} && ${V_TYPE:l} != 'all') && ${TY:l} != ${V_TYPE:l} ]] && continue
		[[ (-n ${V_CONTEXT} && ${V_CONTEXT:l} != 'all') && ${CX:l} != ${V_CONTEXT:l} ]] && continue

		EN_HDR="${TY} ${CX}"
		SP_HDR="${_SP_TERMS[${EN_HDR}]}"

		case ${TY} in
			indicative) T_NDX=1;;
			perfect) T_NDX=2;;
			progressive) T_NDX=3;;
			*) T_NDX=0;;
		esac

		if [[ ${TY:l} == 'indicative' || ${TY} == 'perfect' || ${TY} == 'progressive' ]];then
			echo "${T_NDX}${_IND_CONTEXT_SORT[${CX}]}00 LF ${(C)SP_HDR}"
			printf "%d%d10    Yo %s\n" ${T_NDX} ${_IND_CONTEXT_SORT[${CX}]} ${YO}
			printf "%d%d20    Tú %s\n" ${T_NDX} ${_IND_CONTEXT_SORT[${CX}]} ${YF}
			printf "%d%d30    Él %s\n" ${T_NDX} ${_IND_CONTEXT_SORT[${CX}]} ${EL}
			printf "%d%d40   Nos %s\n" ${T_NDX} ${_IND_CONTEXT_SORT[${CX}]} ${WE}
			printf "%d%d50   Vos %s\n" ${T_NDX} ${_IND_CONTEXT_SORT[${CX}]} ${YP}
			printf "%d%d60 Ellos %s\n" ${T_NDX} ${_IND_CONTEXT_SORT[${CX}]} ${TH}
		elif [[ ${TY:l} == 'imperative' ]];then
			echo "44${_IMP_CONTEXT_SORT[${CX}]}0 LF ${(C)SP_HDR}"
			printf "44%d1    Yo %s\n" ${_IMP_CONTEXT_SORT[${CX}]} ${YO}
			printf "44%d2    Tú %s\n" ${_IMP_CONTEXT_SORT[${CX}]} ${YF}
			printf "44%d3    Él %s\n" ${_IMP_CONTEXT_SORT[${CX}]} ${EL}
			printf "44%d4   Nos %s\n" ${_IMP_CONTEXT_SORT[${CX}]} ${WE}
			printf "44%d5   Vos %s\n" ${_IMP_CONTEXT_SORT[${CX}]} ${YP}
			printf "44%d6 Ellos %s\n" ${_IMP_CONTEXT_SORT[${CX}]} ${TH}
		elif [[ ${TY:l} == 'subjunctive' ]];then
			echo "55${_SUB_CONTEXT_SORT[${CX}]}0 LF ${(C)SP_HDR}"
			printf "55%d1    Yo %s\n" ${_SUB_CONTEXT_SORT[${CX}]} ${YO}
			printf "55%d2    Tú %s\n" ${_SUB_CONTEXT_SORT[${CX}]} ${YF}
			printf "55%d3    Él %s\n" ${_SUB_CONTEXT_SORT[${CX}]} ${EL}
			printf "55%d4   Nos %s\n" ${_SUB_CONTEXT_SORT[${CX}]} ${WE}
			printf "55%d5   Vos %s\n" ${_SUB_CONTEXT_SORT[${CX}]} ${YP}
			printf "55%d6 Ellos %s\n" ${_SUB_CONTEXT_SORT[${CX}]} ${TH}
		elif [[ ${TY:l} == 'perfect_subj' ]];then
			echo "65${_PSUB_CONTEXT_SORT[${CX}]}0 LF ${(C)SP_HDR}"
			printf "65%d1    Yo %s\n" ${_PSUB_CONTEXT_SORT[${CX}]} ${YO}
			printf "65%d2    Tú %s\n" ${_PSUB_CONTEXT_SORT[${CX}]} ${YF}
			printf "65%d3    Él %s\n" ${_PSUB_CONTEXT_SORT[${CX}]} ${EL}
			printf "65%d4   Nos %s\n" ${_PSUB_CONTEXT_SORT[${CX}]} ${WE}
			printf "65%d5   Vos %s\n" ${_PSUB_CONTEXT_SORT[${CX}]} ${YP}
			printf "65%d6 Ellos %s\n" ${_PSUB_CONTEXT_SORT[${CX}]} ${TH}
		fi
	done | sort -n | sed -e 's/^....//' -e 's/LF/\n/' | mypager
}

wide_tab () {
	local V_TYPE=${1}
	local V_CONTEXT=${2}
	local -A SECT_LEN=()
	local -A TL_LEN=()
	local -a LIST=()
	local	CX EL TH TL TY WE YF YO YP 
	local EN_HDR SP_HDR
	local HDR
	local IRR=''
	local LAST_NDX=0
	local LEN=0
	local NDX=0
	local OUT=false
	local T_NDX=0
	local VB GR PP IR DF
	local L

	do_rmcup

	for L in ${_VERB_DATA};do
		TY=$(cut -d'|' -f${_V_MAP[TY]} <<<${L})
		CX=$(cut -d'|' -f${_V_MAP[CX]} <<<${L})
		YO=$(cut -d'|' -f${_V_MAP[YO]} <<<${L})
		YF=$(cut -d'|' -f${_V_MAP[YF]} <<<${L})
		EL=$(cut -d'|' -f${_V_MAP[EL]} <<<${L})
		WE=$(cut -d'|' -f${_V_MAP[WE]} <<<${L})
		YP=$(cut -d'|' -f${_V_MAP[YP]} <<<${L})
		TH=$(cut -d'|' -f${_V_MAP[TH]} <<<${L})

		[[ (-n ${V_TYPE} && ${V_TYPE:l} != 'all') && ${TY:l} != ${V_TYPE:l} ]] && continue
		[[ (-n ${V_CONTEXT} && ${V_CONTEXT:l} != 'all') && ${CX:l} != ${V_CONTEXT:l} ]] && continue

		EN_HDR="${TY} ${CX}"
		SP_HDR="${(C)${_SP_TERMS[${EN_HDR}]}}"

		case ${TY} in
			indicative) T_NDX=1;;
			perfect) T_NDX=2;;
			progressive) T_NDX=3;;
			imperative) T_NDX=4;;
			subjunctive) T_NDX=5;;
			perfect_subj) T_NDX=6;;
			*) T_NDX=0;;
		esac

		if [[ ${TY:l} == 'indicative' ]];then
			LIST+="${T_NDX}${_IND_CONTEXT_SORT[${CX}]}|${SP_HDR}|${YO}|${YF}|${EL}|${WE}|${YP}|${TH}"
		elif [[ ${TY:l} == 'perfect' ]];then
			LIST+="${T_NDX}${_IND_CONTEXT_SORT[${CX}]}|${SP_HDR}|${YO}|${YF}|${EL}|${WE}|${YP}|${TH}"
		elif [[ ${TY:l} == 'progressive' ]];then
			LIST+="${T_NDX}${_IND_CONTEXT_SORT[${CX}]}|${SP_HDR}|${YO}|${YF}|${EL}|${WE}|${YP}|${TH}"
		elif [[ ${TY:l} == 'imperative' ]];then
			LIST+="${T_NDX}${_IMP_CONTEXT_SORT[${CX}]}|${SP_HDR}|${YO}|${YF}|${EL}|${WE}|${YP}|${TH}"
		elif [[ ${TY:l} == 'subjunctive' ]];then
			LIST+="${T_NDX}${_SUB_CONTEXT_SORT[${CX}]}|${SP_HDR}|${YO}|${YF}|${EL}|${WE}|${YP}|${TH}"
		elif [[ ${TY:l} == 'perfect_subj' ]];then
			LIST+="${T_NDX}${_PSUB_CONTEXT_SORT[${CX}]}|${SP_HDR}|${YO}|${YF}|${EL}|${WE}|${YP}|${TH}"
		else
			LIST+="0|HEADER|${L}"
			continue
		fi
		LEN=$(get_longest "${YO} ${YF} ${EL} ${WE} ${YP} ${TH}")
		[[ ${LEN} -gt ${SECT_LEN[${T_NDX}]} ]] && SECT_LEN[${T_NDX}]=${LEN}
		[[ ${#SP_HDR} -gt ${TL_LEN[${T_NDX}]} ]] && TL_LEN[${T_NDX}]=${#SP_HDR}
	done

	LAST_NDX=?
	for L in ${(on)LIST};do
		NDX=${L[1,1]}
		if [[ ${NDX} -eq 0 ]];then
			VB=$(cut -d'|' -f3 <<<${L})
			GR=$(cut -d'|' -f4 <<<${L})
			PP=$(cut -d'|' -f5 <<<${L})
			IR=$(cut -d'|' -f6 <<<${L})
			[[ ${IR} -eq 1 ]] && IR="(irregular)" || IR="(regular)"
			DF=$(cut -d'|' -f7 <<<${L})
			DF=$(html2text <<<${DF})
			printf "Verb:%s %s\n" ${VB} ${IR}
			printf "Gerund:%s\n" ${GR}
			printf "Past Participle:%s\n" ${PP}
			printf "Definition:%s\n" ${DF}
			continue
		fi

		TL=$(cut -d'|' -f2 <<<${L})
		YO=$(cut -d'|' -f3 <<<${L})
		YF=$(cut -d'|' -f4 <<<${L})
		EL=$(cut -d'|' -f5 <<<${L})
		WE=$(cut -d'|' -f6 <<<${L})
		YP=$(cut -d'|' -f7 <<<${L})
		TH=$(cut -d'|' -f8 <<<${L})
		[[ ${NDX} -ne ${LAST_NDX} ]] && LAST_NDX=${NDX} && echo 
		printf "%-*s: %*s %*s %*s %*s %*s %*s\n" ${TL_LEN[${NDX}]} ${TL} ${SECT_LEN[${NDX}]} ${YO} ${SECT_LEN[${NDX}]} ${YF} ${SECT_LEN[${NDX}]} ${EL} ${SECT_LEN[${NDX}]} ${WE} ${SECT_LEN[${NDX}]} ${YP} ${SECT_LEN[${NDX}]} ${TH}
	done
}

#--Begin GetOpts--
local -a OPTIONS
local OPTION
local DESC

read -r -d '' DESC<<EOF
Generate conjugation table for a given verb
EOF

parse_opts () {
	local OPTS=${@}
	local -a OPTSTR
	local LETTER_OPT
	local O

	for O in {1..${#OPTS}};do
		[[ ${OPTS[${O}]} =~ '[A-Za-z]' ]] && LETTER_OPT=${OPTS[${O}]}
		[[ ${O} -eq 1 && ${OPTS[${O}]} == ":" ]] && continue
		[[ ${O} -gt 1 && ${OPTS[${O}]} == ":" ]] && OPTSTR+=$(opt_type ${LETTER_OPT}) && continue
		OPTSTR+="-${OPTS[${O}]}"
	done
	echo ${OPTSTR}
}

opt_exists () {
	local OPT=${1}
	[[ $(( $OPTIONS[(Ie)${OPT}] )) -ne 0 ]] && return 0 || return 1
}

opt_type () {
	local OPT=${1}
	case ${OPT} in
		d) echo "<DIR>";;
		f) echo "<FILE>";;
		t) echo "<TAB_TYPE>";;
	esac
}

usage () {
	local -a PENDING_MSGS=(${@})
	local OPTS=$(parse_opts ${OPTSTR})

	[[ ${_SMCUP} == 'true' ]] && do_rmcup

	tabs 5
	(
	echo -e "\n${WHITE_FG}\nUsage${RESET}: ${_SCRIPT} ${WHITE_FG}[${RESET}${OPTS}${WHITE_FG}]${RESET}\n"
	echo -e "${WHITE_FG}-H${RESET} help"
	echo -e "${WHITE_FG}-D${RESET} debug (repeats increase level)"
	echo -e "${WHITE_FG}-t${RESET} table type: s = stack, w = wide"
	echo -e "\n${WHITE_FG}DESC${RESET}:${DESC}"
	) >&2

	exit_leave ${PENDING_MSGS}
}

OPTSTR=":HDt:"
OPTIND=0

TAB_TYPE=s

while getopts ${OPTSTR} OPTION;do
	case $OPTION in
     H) usage;;
     D) dbg_set_level;;
     t) TAB_TYPE=${OPTARG};;
     :) print -u2 "${_SCRIPT_TAG} ${BOLD}${RED_FG}Option error${RESET}: -${OPTARG} requires an argument"; usage;;
    \?) print -u2 "${_SCRIPT_TAG} ${BOLD}${RED_FG}Unknown option${RESET} - ${OPTARG}"; usage;;
	esac
	[[ ${OPTION} != 'D' ]] && OPTIONS+=${OPTION}
done
shift $((OPTIND -1))
#--End GetOpts--

# Execution
[[ ${_DEBUG} -eq 0 ]] && do_smcup
[[ -n ${1} ]] && VERB_ARG=${1:l}
[[ -n ${2} ]] && V_TYPE=${2:l} || V_TYPE=''
[[ -n ${3} ]] && V_CONTEXT=${3:l} || V_CONTEXT=''
[[ -z ${VERB_ARG} ]] && do_rmcup && exit_leave $(err_msg_exit E "Missing argument:<VERB>")
[[ ! ${TAB_TYPE} =~ "s|w" ]] && do_rmcup && exit_leave $(err_msg_exit E "Invalid table type:${TAB_TYPE}")

while true;do
	_VERB_DATA=("${(f)$(verb_dump ${VERB_ARG})}")

	if ! arr_is_populated "${_VERB_DATA}";then
		msg_box -p -H1 -P"${RESET}Fetch data for verb:${WHITE_FG}${VERB_ARG}|${RESET}(Y/N)?" "Add Missing Verb|Verb <w>${VERB_ARG}<N>:<r>not found<N>"
		if [[ ${_MSG_KEY} != 'y' ]];then
			do_rmcup
			exit_leave $(err_msg_exit W "Verb ${VERB_ARG}:not found")
		fi
		msg_box -x10 "Fetching data..."
		get_verb ${VERB_ARG} >/dev/null 2>&1
		[[ ${?} -ne 0 ]] && do_rmcup && exit_leave $(err_msg_exit E "Unable to fetch verb:${VERB_ARG}")
		sleep 1
	else
		break
	fi
done

if [[ -z ${V_TYPE} ]];then
	clear
	sel_set_list ${(C)_V_TYPES}
	sel_list -O ${CYAN_FG} -F"<w>Select Verb Type or <h>(q)uit<N>" -H"Verb Types"
	V_TYPE=${_SEL_VAL:l}
fi

if [[ -z ${V_CONTEXT} ]];then
	clear
	if [[ ${V_TYPE:l} == 'indicative' ]];then
		sel_set_list ${(Ck)_IND_CONTEXT_SORT}
		sel_list -R -O ${CYAN_FG} -F"<w>Select Verb Context or <h>(q)uit<N>" -H"Verb Contexts"
	elif [[ ${V_TYPE:l} == 'perfect' ]];then
		sel_set_list ${(Ck)_IND_CONTEXT_SORT}
		sel_list -R -O ${CYAN_FG} -F"<w>Select Verb Context or <h>(q)uit<N>" -H"Verb Contexts"
	elif [[ ${V_TYPE:l} == 'progressive' ]];then
		sel_set_list ${(Ck)_IND_CONTEXT_SORT}
		sel_list -R -O ${CYAN_FG} -F"<w>Select Verb Context or <h>(q)uit<N>" -H"Verb Contexts"
	elif [[ ${V_TYPE:l} == 'subjunctive' ]];then
		sel_set_list ${(Ck)_SUB_CONTEXT_SORT}
		sel_list -R -O ${CYAN_FG} -F"<w>Select Subjunctive Context or <h>(q)uit<N>" -H"Subjunctive Contexts"
	elif [[ ${V_TYPE:l} == 'perfect_subj' ]];then
		sel_set_list ${(Ck)_PSUB_CONTEXT_SORT}
		sel_list -R -O ${CYAN_FG} -F"<w>Select Perfect Subjunctive Context or <h>(q)uit<N>" -H"Perfect Subjunctive Contexts"
	elif [[ ${V_TYPE:l} == 'imperative' ]];then
		sel_set_list ${(Ck)_IMP_CONTEXT_SORT}
		sel_list -R -O ${CYAN_FG} -F"<w>Select Imperative Context or <h>(q)uit<N>" -H"Imperative Contexts"
	fi
	V_CONTEXT=${_SEL_VAL:l}
fi

case ${TAB_TYPE} in
	s) stack_tab ${V_TYPE} ${V_CONTEXT};;
	w) wide_tab ${V_TYPE} ${V_CONTEXT};;
esac

exit_leave
