#!/usr/bin/zsh
# Inline ansi
BOLD="\033[1m"
ITALIC="\033[3m"
RESET="\033[m"
REVERSE="\033[7m"
STRIKE="\033[9m"
UNDER="\033[4m"
BLACK_BG="\033[40m"
BLUE_FG="\033[34m"
CYAN_FG="\033[36m"
GREEN_FG="\033[32m"
MAGENTA_FG="\033[35m"
RED_FG="\033[31m"
WHITE_FG="\033[37m"
YELLOW_FG="\033[33m"
CSR_OFF="\033[?25l"
CSR_ON="\033[?25h"

# Imports
[[ -z ${ZSH_LIB_DIR} ]] && _LIB_DIR=/usr/local/lib || _LIB_DIR=${ZSH_LIB_DIR}
source ${_LIB_DIR}/LIB_INIT.zsh # Must be first
source ${_LIB_DIR}/UTILS.zsh
source ${_LIB_DIR}/SELECT.zsh
source ${_LIB_DIR}/LIB_DEPS.zsh # Must be last

# Declarations
typeset -a _VERB_DATA=()
typeset -A _V_MAP=(VB 1 TY 2 CX 3 YO 4 YF 5 EL 6 WE 7 YP 8 TH 9 IR 10)
typeset -a _V_TYPES=(indicative perfect progressive imperative subjunctive perfect_subj all)
typeset -A _IND_CONTEXT_SORT=(present 1 preterite 2 imperfect 3 future 4 conditional 5 all 6)
typeset -A _IMP_CONTEXT_SORT=(affirmative 1 negative 2 all 3)
typeset -A _SUB_CONTEXT_SORT=(present 1 future 2 imperfect 3 imperfect2 4 all 5)
typeset -A _PSUB_CONTEXT_SORT=(future 1 past 2 present 3 all 4)
typeset -A _HDR_DATA=(GR 2 PR 3 IR 4 DF 5)
typeset -A _SP_TERMS=(
"indicative present" "presente"
"indicative preterite" "pretérito indefinido"
"indicative imperfect" "pretérito imperfecto"
"indicative future" "futuro simple"
"indicative conditional" "condicíonal simple"
"perfect present" "pretérito perfecto"
"perfect preterite" "pretérito anterior"
"perfect imperfect" "pretérito pluscuamperfecto"
"perfect future" "futuro perfecto"
"perfect conditional" "condicíonal perfecto"
"progressive present" "presente progressivo"
"progressive preterite" "pretérito perfecto simple"
"progressive imperfect" "pasado progressivo"
"progressive future" "futuro progressivo"
"progressive conditional" "condicíonal progressivo"
"imperative affirmative" "imperativo afirmativo"
"imperative negative" "imperativo negativo"
"subjunctive present" "presente de subjuntivo"
"subjunctive future" "futuro simple de subjuntivo"
"subjunctive imperfect" "pretérito imperfecto de subjuntivo"
"subjunctive imperfect2" "pretérito imperf2 de subjuntivo"
"perfect_subj future" "futuro perfecto de subjuntivo"
"perfect_subj past" "pretérito pluscuamperfecto de subjuntivo"
"perfect_subj present" "pretérito perfecto subjuntivo"
)

# Functions
stack_tab () {
	local V_TYPE=${1}
	local V_CONTEXT=${2}
	local	VB TY CX YO YF EL WE YP TH IR GR
	local DEFN GRND PART IRRG
	local EN_HDR SP_HDR VB_HDR
	local OUT=false
	local T_NDX=0
	local	LBL1="   yo:"
	local	LBL2="   tú:"
	local	LBL3="   él:"
	local	LBL4="  nos:"
	local	LBL5="  vos:"
	local	LBL6="ellos:"
	local HLBL1="       Verb:"
	local HLBL2="     Gerund:"
	local HLBL3=" Participle:"
	local HLBL4=" Definition:"
	local L

	do_rmcup

	[[ ${_DEBUG} -ne 0 ]] && dbg "${0}: V_TYPE:${V_TYPE}, V_CONTEXT:${V_CONTEXT}"

	for L in ${_VERB_DATA};do
		VB=$(cut -d'|' -f${_V_MAP[VB]} <<<${L}) # verb
		TY=$(cut -d'|' -f${_V_MAP[TY]} <<<${L}) # type
		CX=$(cut -d'|' -f${_V_MAP[CX]} <<<${L}) # context
		YO=$(cut -d'|' -f${_V_MAP[YO]} <<<${L}) # yo
		YF=$(cut -d'|' -f${_V_MAP[YF]} <<<${L}) # tú
		EL=$(cut -d'|' -f${_V_MAP[EL]} <<<${L}) # él
		WE=$(cut -d'|' -f${_V_MAP[WE]} <<<${L}) # nos
		YP=$(cut -d'|' -f${_V_MAP[YP]} <<<${L}) # vos
		TH=$(cut -d'|' -f${_V_MAP[TH]} <<<${L}) # ellos
		IR=$(cut -d'|' -f10 <<<${L}) # irregular
		GR=$(cut -d'|' -f6 <<<${L}) # gerund

		if [[ ${OUT} == 'false' && -z ${EL} ]];then
			GRND=$(cut -d'|' -f${_HDR_DATA[GR]} <<<${L})
			PART=$(cut -d'|' -f${_HDR_DATA[PR]} <<<${L})
			IRRG=$(cut -d'|' -f${_HDR_DATA[IR]} <<<${L})
			DEFN=$(cut -d'|' -f${_HDR_DATA[DF]} <<<${L})
			DEFN=$(html2text <<<${DEFN})
			[[ ${_DEBUG} -ne 0 ]] && dbg "${0}: GRND:${GRND}, PART:${PART}, IRRG:${IRRG}, DEFN:${DEFN}"
			continue
		fi


		if [[ ${OUT} == 'false' ]];then
			[[ ${IRRG} == '1' ]] && IRRG='(irregular)' || IRRG='(regular)'
			printf "0    %s\n" "Resumen"
			printf "1    %s %s\n" ${HLBL1:q} "${VB} ${IRRG}"
			printf "2    %s %s\n" ${HLBL2:q} ${GRND}
			printf "3    %s %s\n" ${HLBL3:q} ${PART}
			printf "4    %s %s\n" ${HLBL4:q} ${DEFN}
			OUT=true
		fi
		
		[[ (-n ${V_TYPE} && ${V_TYPE:l} != 'all') && ${TY:l} != ${V_TYPE:l} ]] && continue
		[[ (-n ${V_CONTEXT} && ${V_CONTEXT:l} != 'all') && ${CX:l} != ${V_CONTEXT:l} ]] && continue

		EN_HDR="${TY} ${CX}"
		SP_HDR="${_SP_TERMS[${EN_HDR}]}"

		case ${TY} in
			indicative) T_NDX=1;;
			perfect) T_NDX=2;;
			progressive) T_NDX=3;;
			*) T_NDX=0;;
		esac

		if [[ ${TY:l} == 'indicative' || ${TY} == 'perfect' || ${TY} == 'progressive' ]];then
			[[ ${_DEBUG} -ne 0 ]] && dbg "${0}: VERB_TYPE matches:${TY} _IND_CONTEXT_SORT:${CX} YO:${YO} YF:${YF} EL:${EL} WE:${WE} YP:${YP} TH:${TH}"
			echo "${T_NDX}${_IND_CONTEXT_SORT[${CX}]}00 LF ${(C)SP_HDR}"
			printf "%d%d10 %s %s\n" ${T_NDX} ${_IND_CONTEXT_SORT[${CX}]} ${LBL1:q} ${YO:s/_/ /}
			printf "%d%d20 %s %s\n" ${T_NDX} ${_IND_CONTEXT_SORT[${CX}]} ${LBL2:q} ${YF:s/_/ /}
			printf "%d%d30 %s %s\n" ${T_NDX} ${_IND_CONTEXT_SORT[${CX}]} ${LBL3:q} ${EL:s/_/ /}
			printf "%d%d40 %s %s\n" ${T_NDX} ${_IND_CONTEXT_SORT[${CX}]} ${LBL4:q} ${WE:s/_/ /}
			printf "%d%d50 %s %s\n" ${T_NDX} ${_IND_CONTEXT_SORT[${CX}]} ${LBL5:q} ${YP:s/_/ /}
			printf "%d%d60 %s %s\n" ${T_NDX} ${_IND_CONTEXT_SORT[${CX}]} ${LBL6:q} ${TH:s/_/ /}
		elif [[ ${TY:l} == 'imperative' ]];then
			[[ ${_DEBUG} -ne 0 ]] && dbg "${0}: VERB_TYPE matches:${TY} _IMP_CONTEXT_SORT:${CX} YO:${YO} YF:${YF} EL:${EL} WE:${WE} YP:${YP} TH:${TH}"
			echo "44${_IMP_CONTEXT_SORT[${CX}]}0 LF ${(C)SP_HDR}"
			printf "44%d1 %s %s\n" ${_IMP_CONTEXT_SORT[${CX}]} ${LBL1:q} ${YO:s/_/ /}
			printf "44%d2 %s %s\n" ${_IMP_CONTEXT_SORT[${CX}]} ${LBL2:q} ${YF:s/_/ /}
			printf "44%d3 %s %s\n" ${_IMP_CONTEXT_SORT[${CX}]} ${LBL3:q} ${EL:s/_/ /}
			printf "44%d4 %s %s\n" ${_IMP_CONTEXT_SORT[${CX}]} ${LBL4:q} ${WE:s/_/ /}
			printf "44%d5 %s %s\n" ${_IMP_CONTEXT_SORT[${CX}]} ${LBL5:q} ${YP:s/_/ /}
			printf "44%d6 %s %s\n" ${_IMP_CONTEXT_SORT[${CX}]} ${LBL6:q} ${TH:s/_/ /}
		elif [[ ${TY:l} == 'subjunctive' ]];then
			[[ ${_DEBUG} -ne 0 ]] && dbg "${0}: VERB_TYPE matches:${TY} _SUB_CONTEXT_SORT:${CX} YO:${YO} YF:${YF} EL:${EL} WE:${WE} YP:${YP} TH:${TH}"
			echo "55${_SUB_CONTEXT_SORT[${CX}]}0 LF ${(C)SP_HDR}"
			printf "55%d1 %s %s\n" ${_SUB_CONTEXT_SORT[${CX}]} ${LBL1:q} ${YO:s/_/ /}
			printf "55%d2 %s %s\n" ${_SUB_CONTEXT_SORT[${CX}]} ${LBL2:q} ${YF:s/_/ /}
			printf "55%d3 %s %s\n" ${_SUB_CONTEXT_SORT[${CX}]} ${LBL3:q} ${EL:s/_/ /}
			printf "55%d4 %s %s\n" ${_SUB_CONTEXT_SORT[${CX}]} ${LBL4:q} ${WE:s/_/ /}
			printf "55%d5 %s %s\n" ${_SUB_CONTEXT_SORT[${CX}]} ${LBL5:q} ${YP:s/_/ /}
			printf "55%d6 %s %s\n" ${_SUB_CONTEXT_SORT[${CX}]} ${LBL6:q} ${TH:s/_/ /}
		elif [[ ${TY:l} == 'perfect_subj' ]];then
			[[ ${_DEBUG} -ne 0 ]] && dbg "${0}: VERB_TYPE matches:${TY} _PSUB_CONTEXT_SORT:${CX} YO:${YO} YF:${YF} EL:${EL} WE:${WE} YP:${YP} TH:${TH}"
			echo "65${_PSUB_CONTEXT_SORT[${CX}]}0 LF ${(C)SP_HDR}"
			printf "65%d1 %s %s\n" ${_PSUB_CONTEXT_SORT[${CX}]} ${LBL1:q} ${YO:s/_/ /}
			printf "65%d2 %s %s\n" ${_PSUB_CONTEXT_SORT[${CX}]} ${LBL2:q} ${YF:s/_/ /}
			printf "65%d3 %s %s\n" ${_PSUB_CONTEXT_SORT[${CX}]} ${LBL3:q} ${EL:s/_/ /}
			printf "65%d4 %s %s\n" ${_PSUB_CONTEXT_SORT[${CX}]} ${LBL4:q} ${WE:s/_/ /}
			printf "65%d5 %s %s\n" ${_PSUB_CONTEXT_SORT[${CX}]} ${LBL5:q} ${YP:s/_/ /}
			printf "65%d6 %s %s\n" ${_PSUB_CONTEXT_SORT[${CX}]} ${LBL6:q} ${TH:s/_/ /}
		fi
	done | sort -n | sed -e 's/^....//' -e 's/LF/\n/' | do_pager ${PAGE_OPT}
}

do_pager () {
	local PAGING=${1}
	local LINE

	if [[ ${PAGING} == 'false' ]];then
		while read LINE;do
			echo ${LINE}
		done
	else
		while read LINE;do
			echo ${LINE}
		done | mypager
	fi
}

select_verb_type () {
	sel_set_list ${(C)_V_TYPES}
	sel_list -O ${CYAN_FG} -F"<w>Select Verb Type or <h>(q)uit<N>" -H"Verb Types"
}

select_verb_context () {
	local VTYPE=${1}

	if [[ ${V_TYPE:l} == 'indicative' ]];then
		sel_set_list ${(Ck)_IND_CONTEXT_SORT}
		sel_list -R -O ${CYAN_FG} -F"<w>Select Verb Context or <h>(q)uit<N>" -H"Verb Contexts"
	elif [[ ${V_TYPE:l} == 'perfect' ]];then
		sel_set_list ${(Ck)_IND_CONTEXT_SORT}
		sel_list -R -O ${CYAN_FG} -F"<w>Select Verb Context or <h>(q)uit<N>" -H"Verb Contexts"
	elif [[ ${V_TYPE:l} == 'progressive' ]];then
		sel_set_list ${(Ck)_IND_CONTEXT_SORT}
		sel_list -R -O ${CYAN_FG} -F"<w>Select Verb Context or <h>(q)uit<N>" -H"Verb Contexts"
	elif [[ ${V_TYPE:l} == 'subjunctive' ]];then
		sel_set_list ${(Ck)_SUB_CONTEXT_SORT}
		sel_list -R -O ${CYAN_FG} -F"<w>Select Subjunctive Context or <h>(q)uit<N>" -H"Subjunctive Contexts"
	elif [[ ${V_TYPE:l} == 'perfect_subj' ]];then
		sel_set_list ${(Ck)_PSUB_CONTEXT_SORT}
		sel_list -R -O ${CYAN_FG} -F"<w>Select Perfect Subjunctive Context or <h>(q)uit<N>" -H"Perfect Subjunctive Contexts"
	elif [[ ${V_TYPE:l} == 'imperative' ]];then
		sel_set_list ${(Ck)_IMP_CONTEXT_SORT}
		sel_list -R -O ${CYAN_FG} -F"<w>Select Imperative Context or <h>(q)uit<N>" -H"Imperative Contexts"
	fi
}

validate_type () {
	local ${V_TYPE}=${1}

	[[ ${_V_TYPES[(i)${V_TYPE}]} -le ${#_V_TYPES} ]] && return 0 || return 1
}

validate_context () {
	local ${V_CONTEXT}=${1}

	[[ -n ${_IND_CONTEXT_SORT[${V_CONTEXT}]} ]] && return 0
	[[ -n ${_IMP_CONTEXT_SORT[${V_CONTEXT}]} ]] && return 0
	[[ -n ${_SUB_CONTEXT_SORT[${V_CONTEXT}]} ]] && return 0
	[[ -n ${_PSUB_CONTEXT_SORT[${V_CONTEXT}]} ]] && return 0
	return 1
}

#--Begin GetOpts--
local -a OPTIONS
local OPTION
local DESC

read -r -d '' DESC<<EOF
Generate conjugation table for a given verb

VERB_TYPES\tVERB_CONTEXTS
-----------\t------------ 
imperative\taffirmative 
indicative\tconditional 
perfect\t\tfuture 
perfect_subj\timperfect 
progressive\timperfect2 
subjunctive\tnegative 
present\t\tall
preterite 
all
EOF

parse_opts () {
	local OPTS=${@}
	local -a OPTSTR
	local LETTER_OPT
	local O

	for O in {1..${#OPTS}};do
		[[ ${OPTS[${O}]} =~ '[A-Za-z]' ]] && LETTER_OPT=${OPTS[${O}]}
		[[ ${O} -eq 1 && ${OPTS[${O}]} == ":" ]] && continue
		[[ ${O} -gt 1 && ${OPTS[${O}]} == ":" ]] && OPTSTR+=$(opt_type ${LETTER_OPT}) && continue
		OPTSTR+="-${OPTS[${O}]}"
	done
	echo ${OPTSTR}
}

opt_exists () {
	local OPT=${1}
	[[ $(( $OPTIONS[(Ie)${OPT}] )) -ne 0 ]] && return 0 || return 1
}

opt_type () {
	local OPT=${1}
	case ${OPT} in
		d) echo "<DIR>";;
		f) echo "<FILE>";;
		t) echo "<VERB_TYPE>";;
		c) echo "<VERB_CONTEXT>";;
		v) echo "<VERB>";;
	esac
}

usage () {
	local -a PENDING_MSGS=(${@})
	local OPTS=$(parse_opts ${OPTSTR})

	[[ ${_SMCUP} == 'true' ]] && do_rmcup

	tabs 5
	(
	echo -e "\n${WHITE_FG}\nUsage${RESET}: ${_SCRIPT} ${WHITE_FG}[${RESET}${OPTS}${WHITE_FG}]${RESET} [$(opt_type t)] [$(opt_type c)] $(opt_type v)\n"
	echo -e "${WHITE_FG}-H${RESET} help"
	echo -e "${WHITE_FG}-D${RESET} debug (repeats increase level)"
	echo -e "${WHITE_FG}-p${RESET} paged output"
	echo -e "\n${WHITE_FG}DESC${RESET}:${DESC}"
	) >&2

	exit_leave ${PENDING_MSGS}
}

OPTSTR=":HDp"
OPTIND=0
PAGE_OPT=false

while getopts ${OPTSTR} OPTION;do
	case $OPTION in
     H) usage;;
     D) dbg_set_level;;
     p) PAGE_OPT=true;;
     :) print -u2 "${_SCRIPT_TAG} ${BOLD}${RED_FG}Option error${RESET}: -${OPTARG} requires an argument"; usage;;
    \?) print -u2 "${_SCRIPT_TAG} ${BOLD}${RED_FG}Unknown option${RESET} - ${OPTARG}"; usage;;
	esac
	[[ ${OPTION} != 'D' ]] && OPTIONS+=${OPTION}
done
shift $((OPTIND -1))
#--End GetOpts--

# Execution
[[ ${_DEBUG} -eq 0 ]] && do_smcup

V_TYPE=''
V_CONTEXT=''
VERB_ARG=''

# Handle args
[[ ${#} -eq 1 ]] && VERB_ARG=${1:l}
[[ ${#} -gt 1 ]] && V_TYPE=${1:l}
[[ ${#} -eq 2 ]] && VERB_ARG=${2:l}
[[ ${#} -gt 2 ]] && V_CONTEXT=${2:l} && VERB_ARG=${3:l}

[[ -z ${VERB_ARG} ]] && do_rmcup && usage "${RED_FG}Missing argument${RESET}:$(opt_type v)"

# Check verb exists
TEST=$(do_query "select verb from spanish_tense where verb='${VERB_ARG}'")
[[ -z ${TEST} ]] && do_rmcup && exit_leave $(err_msg_exit W "Verb:${CYAN_FG}${VERB_ARG}${RESET} not in database")

# Validate type
if [[ -n ${V_TYPE} ]];then
	validate_type ${V_TYPE}
	[[ ${?} -ne 0 ]] && do_rmcup && exit_leave $(err_msg_exit "Invalid verb type:${V_TYPE}")
else
	select_verb_type # Sets SEL_VAL
	V_TYPE=${_SEL_VAL}
fi

# Validate context
if [[ -n ${V_TYPE} && -n ${V_CONTEXT} ]];then
	validate_context ${V_CONTEXT}
	[[ ${?} -ne 0 ]] && do_rmcup && exit_leave $(err_msg_exit "Invalid verb context:${V_CONTEXT}")
elif [[ -z ${V_CONTEXT} ]];then
	select_verb_context ${V_TYPE} # Sets SEL_VAL
	V_CONTEXT=${_SEL_VAL}
fi

# TODO: Funtionalize and place after TEST
 
while true;do
	_VERB_DATA=("${(f)$(verb_dump ${VERB_ARG})}")

	if ! arr_is_populated "${_VERB_DATA}";then
		msg_box -p -H1 -P"${RESET}Fetch data for verb:${WHITE_FG}${VERB_ARG}|${RESET}(Y/N)?" "Add Missing Verb|Verb <w>${VERB_ARG}<N>:<r>not found<N>"
		if [[ ${_MSG_KEY} != 'y' ]];then
			do_rmcup
			exit_leave $(err_msg_exit W "Verb ${VERB_ARG}:not found")
		fi
		msg_box -x10 "Fetching data..."
		get_verb ${VERB_ARG} >/dev/null 2>&1
		[[ ${?} -ne 0 ]] && do_rmcup && exit_leave $(err_msg_exit "Unable to fetch verb:${VERB_ARG}")
		sleep 1
	else
		break
	fi
done

stack_tab ${V_TYPE} ${V_CONTEXT}

exit_leave
