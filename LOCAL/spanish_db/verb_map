#!/usr/bin/zsh
#Inline ansi
BOLD="\033[1m"
ITALIC="\033[3m"
RESET="\033[m"
REVERSE="\033[7m"
STRIKE="\033[9m"
UNDER="\033[4m"

BLACK_BG="\033[40m"

BLUE_FG="\033[34m"
CYAN_FG="\033[36m"
GREEN_FG="\033[32m"
MAGENTA_FG="${BOLD}${ITALIC}\033[35m"
RED_FG="\033[31m"
WHITE_FG="\033[37m"
YELLOW_FG="\033[33m"

# Imports
[[ -z ${ZSH_LIB_DIR} ]] && _LIB_DIR=/usr/local/lib || _LIB_DIR=${ZSH_LIB_DIR}
source ${_LIB_DIR}/LIB_INIT.zsh # Must be first
source ${_LIB_DIR}/UTILS.zsh
source ${_LIB_DIR}/LIB_DEPS.zsh # Must be last

#Declarations
typeset -A _FLD_WIDTH=()
typeset -A _INLINE=()
typeset -A _IMP_COL_LBLS=(1 affirmative 2 negative)
typeset -A _IND_COL_LBLS=(1 present 2 preterite 3 imperfect 4 conditional 5 future)
typeset -A _LBL_MAP=(1 _IND_COL_LBLS 2 _SUB_COL_LBLS 3 _IND_COL_LBLS 4 _PSUB_COL_LBLS 5 _IND_COL_LBLS 6 _IMP_COL_LBLS)
typeset -A _MOOD_LBLS=(1 indicative 2 subjunctive 3 perfect 4 perfect_subj 5 progressive 6 imperative)
typeset -A _PRONOUN_LBLS=(1 yo 2 tú 3 él 4 nosotros 5 vosotros 6 ellos 7 irregular)
typeset -A _PSUB_COL_LBLS=(1 present 2 past 3 future)
typeset -A _SUB_COL_LBLS=(1 present 2 future 3 imperfect 4 imperfect2)
typeset -a _HDR_DIVS=()
typeset -a _FIELD_LIST=()
typeset -a _HDRS=()
typeset -a _VERB_DATA

# Vars
_FIRST_BLOCK=1
_LAST_BLOCK=6
_FIRST_ROW=1
_LAST_ROW=6
_FIRST_COL=1
_LAST_COL=5
_FIRST_VERB_FIELD=4
_LAST_VERB_FIELD=9
_VERB_ARG=''

# Functions
translation () {
	local TRANS=$(do_query -d '|' "select translation from spanish_verb where verb = '${_VERB_ARG}'")
	echo ${TRANS}
}

participle () {
	local PART=$(do_query -d '|' "select past_participle from spanish_verb where verb = '${_VERB_ARG}'")
	echo ${PART}
}

gerund () {
	local PART=$(do_query -d '|' "select gerund from spanish_verb where verb = '${_VERB_ARG}'")
	echo ${PART}
}

irregular () {
	do_query -d '|' "select irregular from spanish_verb where verb = '${_VERB_ARG}'"
}

indicative () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'indicative' and tense = 'present'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'indicative' and tense = 'preterite'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'indicative' and tense = 'imperfect'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'indicative' and tense = 'conditional'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'indicative' and tense = 'future'")
}

subjunctive () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'subjunctive' and tense = 'present'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'subjunctive' and tense = 'future'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'subjunctive' and tense = 'imperfect'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'subjunctive' and tense = 'imperfect2'")
}

perfect () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect' and tense = 'present'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect' and tense = 'preterite'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect' and tense = 'imperfect'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect' and tense = 'conditional'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect' and tense = 'future'")
}

perfect_subj () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect_subj' and tense = 'present'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect_subj' and tense = 'past'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect_subj' and tense = 'future'")
}

progressive () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'progressive' and tense = 'present'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'progressive' and tense = 'preterite'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'progressive' and tense = 'imperfect'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'progressive' and tense = 'conditional'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'progressive' and tense = 'future'")
}

imperative () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'imperative' and tense = 'affirmative'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'imperative' and tense = 'negative'")
}

do_pager () {
	local PAGING=${1}
	local ANSI=${2}
	local LINE

	if [[ ${PAGING} == 'false' ]];then
		while read LINE;do
			[[ ${ANSI} == 'false' ]] && str_strip_ansi <<<${LINE} || echo ${LINE}
		done
	else
		while read LINE;do
			[[ ${ANSI} == 'false' ]] && str_strip_ansi <<<${LINE} || echo ${LINE}
		done | mypager
	fi
}

markdown_table () {
	local DEFN
	local HDR_DIV
	local GRND
	local HPF
	local IRRG
	local PART
	local PF
	local B R C

	[[ ${MOOD_SELECT} -ne 0 ]] && _FIRST_BLOCK=${MOOD_SELECT} && _LAST_BLOCK=${MOOD_SELECT}

	# Top header data
	IRRG=$(irregular)
	GRND=$(gerund)
	PART=$(participle)
	DEFN=$(translation)
	[[ ${IRRG} -eq 1 ]] && IRRG="irregular" || IRRG="regular"
	[[ -n ${DEFN} ]] && DEFN=$(html2text <<<${DEFN})

	(
	echo "Verb:${_VERB_ARG} (${IRRG})"
	echo "Gerund:${GRND}"
	echo "Past Participle:${PART}"
	echo "Definition:${DEFN}\n"

	# Construct printf statements and print
	for (( B=${_FIRST_BLOCK}; B<=${_LAST_BLOCK}; B++ ));do
		for (( R=${_FIRST_ROW}; R<=${_LAST_ROW}; R++ ));do # Move through rows
			_FIELD_LIST+=" ${_PRONOUN_LBLS[${R}]} "
			PF="printf \"|%s" # Initialize PF
			HPF=${PF} # Initialize Header PF
			HDR_DIV=${PF} # Initialize Header HDR_DIV
			for (( C=${_FIRST_COL}; C<=${_LAST_COL}; C++ ));do # Move through columns
				if [[ -n ${_INLINE[${B}${C}${R}]} ]];then
					PF+="|%s" # Add PF slots
					HPF+="|%s" # Add HPF slots
					HDR_DIV+="|%s" # Add HDR_DIV slots
					_FIELD_LIST+=" ${_INLINE[${B}${C}${R}]} "
				fi
			done # Cols
			PF+='|\\n"' # Finish PF
			HPF+='|\\n"' # Finish HPF
			HDR_DIV+='|\\n"' # Finish HDR_DIV
			if [[ ${R} -eq 1 ]];then
				for (( C=${_FIRST_COL}; C<=${_LAST_COL}; C++ ));do # Move through columns
					if [[ -n ${_INLINE[${B}${C}${R}]} ]];then
						_HDRS+=${${(P)_LBL_MAP[${B}]}[${C}]} # Pull indexed order
						_HDR_DIVS+="\$(str_rep_char '-' ${_FLD_WIDTH[${B}]})"
					fi
				done
				eval "${HPF} 'Context' ${(C)_HDRS}"
				eval "${HDR_DIV} '----------' ${_HDR_DIVS}"
				_HDRS=()
				_HDR_DIVS=()
			fi
			eval "${PF} ${_FIELD_LIST}"
			_FIELD_LIST=()
		done # Rows
		echo # Block separator
	done
	) 
}

pretty_table () {
	local DEFN
	local HDR_DIV
	local GRND
	local HPF
	local IRRG
	local PART
	local PF
	local B R C

	[[ ${MOOD_SELECT} -ne 0 ]] && _FIRST_BLOCK=${MOOD_SELECT} && _LAST_BLOCK=${MOOD_SELECT}

	# Top header data
	IRRG=$(irregular)
	GRND=$(gerund)
	PART=$(participle)
	DEFN=$(translation)
	[[ ${IRRG} -eq 1 ]] && IRRG="irregular" || IRRG="regular"
	[[ -n ${DEFN} ]] && DEFN=$(html2text <<<${DEFN})

	# Construct printf statements and print
	(
	tcup 0 0
	echo "Verb:${WHITE_FG}${_VERB_ARG}${RESET} (${IRRG})"
	echo "Gerund:${WHITE_FG}${GRND}${RESET}"
	echo "Past Participle:${WHITE_FG}${PART}${RESET}"
	echo "Definition:${WHITE_FG}${DEFN}${RESET}\n"

	for (( B=${_FIRST_BLOCK}; B<=${_LAST_BLOCK}; B++ ));do
		echo "${ITALIC}${UNDER}${BOLD}${WHITE_FG}${(C)_MOOD_LBLS[${B}]}${RESET}"
		for (( R=${_FIRST_ROW}; R<=${_LAST_ROW}; R++ ));do # Move through rows
			_FIELD_LIST+=" ${_PRONOUN_LBLS[${R}]} "
			PF="printf \" ${CYAN_FG}%-12s${RESET} " # Initialize PF
			HPF=${PF} # Initialize Header PF
			HDR_DIV=${PF} # Initialize Header HDR_DIV
			for (( C=${_FIRST_COL}; C<=${_LAST_COL}; C++ ));do # Move through columns
				if [[ -n ${_INLINE[${B}${C}${R}]} ]];then
					PF+=" %-${_FLD_WIDTH[${B}]}s " # Add PF slots
					HPF+=" ${CYAN_FG}%-${_FLD_WIDTH[${B}]}s${RESET} " # Add HPF slots
					HDR_DIV+=" ${MAGENTA_FG}%-${_FLD_WIDTH[${B}]}s${RESET} " # Add HDR_DIV slots
					_FIELD_LIST+=" ${_INLINE[${B}${C}${R}]} "
				fi
			done # Cols
			PF[(( ${#PF} - 1 ))]+='\\n"' # Finish PF
			HPF[(( ${#HPF} - 1 ))]+='\\n"' # Finish HPF
			HDR_DIV[(( ${#HDR_DIV} - 1 ))]+='\\n"' # Finish HDR_DIV
			if [[ ${R} -eq 1 ]];then
				for (( C=${_FIRST_COL}; C<=${_LAST_COL}; C++ ));do # Move through columns
					if [[ -n ${_INLINE[${B}${C}${R}]} ]];then
						_HDRS+=${${(P)_LBL_MAP[${B}]}[${C}]} # Pull indexed order
						_HDR_DIVS+="\$(str_unicode_line ${_FLD_WIDTH[${B}]})"
					fi
				done
				eval "${HPF} ' ' ${(C)_HDRS}"
				eval "${HDR_DIV} ' ' ${_HDR_DIVS}"
				_HDRS=()
				_HDR_DIVS=()
			fi
			eval "${PF} ${_FIELD_LIST}"
			_FIELD_LIST=()
		done # Rows
		echo # Block separator
	done
	) | sed 's/_/ /g' | do_pager ${PAGE_OPT} ${ANSI}
}

#--Begin GetOpts--
local -a OPTIONS
local OPTION
local DESC

MSG="Limit mood selection with the -m option:"
read -r -d '' DESC<<EOF
Display a verb conjugation map
\tMood selection is optional. Default
\tbehaviour is to display all moods.

${MSG}
${MAGENTA_FG}$(str_unicode_line ${#MSG})${RESET}
$(for V in ${(onk)_MOOD_LBLS};do
	printf "${WHITE_FG}%s ${CYAN_FG}%s${RESET}\n" ${V} ${(C)${_MOOD_LBLS[${V}]}}
done)
EOF

parse_opts () {
	local OPTS=${@}
	local -a OPTSTRING
	local LETTER_OPT
	local O

	for O in {1..${#OPTS}};do
		[[ ${OPTS[${O}]} =~ '[a-z]' ]] && LETTER_OPT=${OPTS[${O}]}
		[[ ${O} -eq 1 && ${OPTS[${O}]} == ":" ]] && continue
		[[ ${O} -gt 1 && ${OPTS[${O}]} == ":" ]] && OPTSTRING+=$(opt_type ${LETTER_OPT}) && continue
		OPTSTRING+="-${OPTS[${O}]}"
	done
	echo ${OPTSTRING}
}

opt_exists () {
	local OPT=${1}
	[[ $(( $OPTIONS[(Ie)${OPT}] )) -ne 0 ]] && return 0 || return 1
}

opt_type () {
	local OPT=${1}
	case ${OPT} in
		d) echo "<DIR>";;
		f) echo "<FILE>";;
		t) echo "<FILE_TYPE>";;
		v) echo "<VERB>";;
	esac
}

usage () {
	local -a PENDING_MSGS=(${@})
	local OPTS=$(parse_opts ${OPTSTR})

	[[ ${_SMCUP} == 'true' ]] && do_rmcup

	tabs 5
	echo -e "\n${WHITE_FG}\nUsage${RESET}: ${_SCRIPT} ${WHITE_FG}[${RESET}${OPTS}${WHITE_FG}]${RESET} $(opt_type v)\n"
	echo -e "${WHITE_FG}-H${RESET} help"
	echo -e "${WHITE_FG}-M${RESET} select MOOD"
	echo -e "${WHITE_FG}-D${RESET} debug (repeats increase level)"
	echo -e "${WHITE_FG}-a${RESET} output contains no ansi"
	echo -e "${WHITE_FG}-m${RESET} output markdown"
	echo -e "${WHITE_FG}-p${RESET} paged output"
	echo -e "\n${WHITE_FG}DESC${RESET}:${DESC}"

	exit_leave $(err_msg_exit "${PENDING_MSGS}")
}

OPTSTR=":HDM:amp"
OPTIND=0

MARKDOWN=false
MOOD_SELECT=0
ANSI=true
PAGE_OPT=false

while getopts ${OPTSTR} OPTION;do
	case $OPTION in
     H) usage;;
     D) dbg_set_level;;
     M) MOOD_SELECT=${OPTARG};;
     a) ANSI=false;;
     m) MARKDOWN=true;;
     p) PAGE_OPT=true;;
     :) print -u2 "${RED_FG}${_SCRIPT}${RESET}: option: -${OPTARG} requires an argument"; usage;;
    \?) print -u2 "${RED_FG}${_SCRIPT}${RESET}: unknown option -${OPTARG}"; usage;;
	esac
	[[ ${OPTION} != 'D' ]] && OPTIONS+=${OPTION}
done
shift $((OPTIND -1))
#--End GetOpts--

# Execution
if [[ ${#} -eq 0 ]];then
	usage "Missing arg:$(opt_type v)"
else
	_VERB_ARG=${1}
	clear >&2
fi

while true;do
	VERB_CHECK=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' limit 1")

	if [[ -z ${VERB_CHECK} ]];then
		clear >&2
		msg_box -p -H1 -P"${RESET}Fetch data for verb:${WHITE_FG}${_VERB_ARG}|${RESET}(Y/N)?" "Add Missing Verb|Verb <w>${_VERB_ARG}<N>:<r>not found<N>"
		if [[ ${_MSG_KEY} != 'y' ]];then
			do_rmcup
			exit_leave $(err_msg_exit W "Verb ${_VERB_ARG}:not found")
		fi
		msg_box -x10 "Fetching data..."
		get_verb ${_VERB_ARG} >/dev/null 2>&1
		[[ ${?} -ne 0 ]] && do_rmcup && exit_leave $(err_msg_exit E "Unable to fetch verb:${_VERB_ARG}")
		sleep 1
	else
		break
	fi
done

# Index verb data
COL_NDX=0
CON_NDX=0
BLOCK=0
LONGEST=0

# Index table data 
for V in ${(onk)_MOOD_LBLS};do
	[[ ${MOOD_SELECT} -ne 0 && ${V} -ne ${MOOD_SELECT} ]] && continue
	${${_MOOD_LBLS[${V}]}:l} # Call function to populate _VERB_DATA
	for L in ${_VERB_DATA};do
		(( COL_NDX++ )) # Move horizontally across row
		for (( F=${_FIRST_VERB_FIELD}; F<=${_LAST_VERB_FIELD}; F++ ));do
			(( CON_NDX++ )) # Move vertically through block
			FIELD=$(cut -d'|' -f${F} <<<${L})
			_INLINE[${V}${COL_NDX}${CON_NDX}]=${FIELD} # Add index for blocks, columns, and rows
			[[ ${#FIELD} -gt ${LONGEST} ]] && LONGEST=${#FIELD}
		done
		CON_NDX=0
	done
	COL_NDX=0
	_VERB_DATA=()
	_FLD_WIDTH[${V}]=${LONGEST}
	LONGEST=0
	[[ ${MOOD_SELECT} -ne 0 ]] && break
done

# Ensure minimum widths equal header text
for W in ${(onk)_FLD_WIDTH};do
	MAP=${_LBL_MAP[$W]}
	for M in ${(P)MAP};do
		if [[ ${#M} -gt ${_FLD_WIDTH[${W}]} ]];then
			_FLD_WIDTH[${W}]=${#M}
		fi
	done
done

[[ ${MARKDOWN} == 'true' ]] && markdown_table || pretty_table
