#!/usr/bin/zsh
#Inline ansi
BOLD="\033[1m"
ITALIC="\033[3m"
RESET="\033[m"
REVERSE="\033[7m"
STRIKE="\033[9m"
UNDER="\033[4m"

BLACK_BG="\033[40m"

BLUE_FG="\033[34m"
CYAN_FG="\033[36m"
GREEN_FG="\033[32m"
MAGENTA_FG="${BOLD}${ITALIC}\033[35m"
RED_FG="\033[31m"
WHITE_FG="\033[37m"
YELLOW_FG="\033[33m"

# Imports
[[ -z ${ZSH_LIB_DIR} ]] && _LIB_DIR=/usr/local/lib || _LIB_DIR=${ZSH_LIB_DIR}
source ${_LIB_DIR}/LIB_INIT.zsh # Must be first
source ${_LIB_DIR}/UTILS.zsh
source ${_LIB_DIR}/LIB_DEPS.zsh # Must be last

#Declarations
typeset _VERB_ARG=''
typeset -a _VERB_DATA
typeset -A _MOODS=(indicative 1 subjunctive 2 perfect 3 perfect_subj 4 progressive 5 imperative 6)
typeset -A _CONTEXT_LABELS=(1 yo 2 tu 3 el 4 nosotros 5 vosotros 6 ellos)

translation () {
	local TRANS=$(do_query -d '|' "select translation from spanish_verb where verb = '${_VERB_ARG}'")
	echo ${TRANS}
}

participle () {
	local PART=$(do_query -d '|' "select past_participle from spanish_verb where verb = '${_VERB_ARG}'")
	echo ${PART}
}

gerund () {
	local PART=$(do_query -d '|' "select gerund from spanish_verb where verb = '${_VERB_ARG}'")
	echo ${PART}
}

indicative () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'indicative' and tense = 'present'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'indicative' and tense = 'preterite'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'indicative' and tense = 'future'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'indicative' and tense = 'conditional'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'indicative' and tense = 'imperfect'")
}

subjunctive () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'subjunctive' and tense = 'present'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'subjunctive' and tense = 'imperfect'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'subjunctive' and tense = 'imperfect2'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'subjunctive' and tense = 'future'")
}

perfect () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect' and tense = 'present'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect' and tense = 'preterite'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect' and tense = 'imperfect'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect' and tense = 'conditional'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect' and tense = 'future'")
}

perfect_subj () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect_subj' and tense = 'present'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect_subj' and tense = 'past'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect_subj' and tense = 'future'")
}

progressive () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'progressive' and tense = 'present'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'progressive' and tense = 'preterite'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'progressive' and tense = 'imperfect'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'progressive' and tense = 'conditional'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'progressive' and tense = 'future'")
}

imperative () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'imperative' and tense = 'affirmative'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'imperative' and tense = 'negative'")
}

format () {
	local MOOD_NDX=${1}
	local FIELD_MAX=10
	local FIELD_NDX=4
	local IRR
	local I_MSG
	local MOOD=${(k)_MOODS[(r)${MOOD_NDX}]} 
	local NDX
	local P1 P2 P3 P4 P5
	local TENSE
	local VERB
	local L H

	local MOOD_6_HDRS=("Context" "Present" "Preterite" "Imperfect" "Conditional" "Future")
	local MOOD_5_HDRS=("Context" "Present" "Imperfect" "Imperfect2" "Future")
	local MOOD_4_HDRS=("Context" "Present" "Past" "Future")
	local MOOD_3_HDRS=("Context" "Affirmative" "Negative")
	local -A MOOD_HEADERS=(1 MOOD_6_HDRS 2 MOOD_5_HDRS 3 MOOD_6_HDRS 4 MOOD_4_HDRS 5 MOOD_6_HDRS 6 MOOD_3_HDRS)
	local -A MOOD_FIELD_NDXS=(1 6 2 5 3 6 4 4 5 6 6 3)
	local -A MOOD_WIDTH=(1 14 2 14 3 22 4 22 5 23 6 12)

	local MOOD_HDR=${MOOD_HEADERS[${_MOODS[${MOOD}]}]}

	echo "${CYAN_FG}MOOD${RESET}:${WHITE_FG}${(C)MOOD}${RESET}\n"

	# Build headers
	local PF_LINE_1='printf "${WHITE_FG}%-10s'
	local PF_LINE_2='printf "${CYAN_FG}%-10s'
	local PF_LINE_3='printf "${MAGENTA_FG}%-10s${RESET}'
	local PF_LN_VALS=''
	local PF_HD_VALS=''
	
	for (( H=1; H<=${MOOD_FIELD_NDXS[${_MOODS[${MOOD}]}]}; H++ ));do
		PF_LINE_1+=" %-${MOOD_WIDTH[${_MOODS[${MOOD}]}]}s"
		PF_LINE_2+=" %-${MOOD_WIDTH[${_MOODS[${MOOD}]}]}s"
		PF_LINE_3+=" %-${MOOD_WIDTH[${_MOODS[${MOOD}]}]}s"
		PF_LN_VALS+=' ${${(P)MOOD_HDR}['${H}']}'
		PF_HD_VALS+=' $(str_unicode_line ${#${(P)MOOD_HDR}['${H}']})'
	done
	PF_LINE_1+='${RESET}\\n"'
	PF_LINE_2+='${RESET}\\n"'
	PF_LINE_3+='${RESET}\\n"'

	# Do headers
	eval "${PF_LINE_1} ${PF_LN_VALS}"
	#eval "${PF_LINE_2} ${PF_HD_VALS}"

	${MOOD} # Extract data

	# Assign detail vars
	NDX=0
	while true;do
		((NDX++))
		for L in ${_VERB_DATA};do
			VERB=$(cut -d'|' -f1 <<<${L})
			MOOD=$(cut -d'|' -f2 <<<${L})
			TENSE=$(cut -d'|' -f3 <<<${L})
			IRR=$(cut -d'|' -f10 <<<${L})
			[[ ${IRR} -eq 0 ]] && I_MSG='(regular)' || I_MSG='(irregular)'
			case ${_MOODS[${MOOD}]} in
				1)
					[[ ${TENSE} == 'present' ]] && P1=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'preterite' ]] && P2=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'imperfect' ]] && P3=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'conditional' ]] && P4=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'future' ]] && P5=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					;;
				2)
					[[ ${TENSE} == 'present' ]] && P1=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'imperfect' ]] && P2=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'imperfect2' ]] && P3=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'future' ]] && P4=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					;;
				3)
					[[ ${TENSE} == 'present' ]] && P1=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'preterite' ]] && P2=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'imperfect' ]] && P3=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'conditional' ]] && P4=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'future' ]] && P5=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					;;
				4)
					[[ ${TENSE} == 'present' ]] && P1=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'past' ]] && P2=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'future' ]] && P3=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					;;
				5)
					[[ ${TENSE} == 'present' ]] && P1=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'preterite' ]] && P2=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'imperfect' ]] && P3=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'conditional' ]] && P4=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'future' ]] && P5=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					;;
				6)
					[[ ${TENSE} == 'affirmative' ]] && P1=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					[[ ${TENSE} == 'negative' ]] && P2=$(cut -d'|' -f${FIELD_NDX} <<<${L})
					;;
			esac
		done

		# Output detail
		case ${_MOODS[${MOOD}]} in
			1) eval ${PF_LINE_3} ${_CONTEXT_LABELS[${NDX}]} ${P1} ${P2} ${P3} ${P4} ${P5};;
			2) eval ${PF_LINE_3} ${_CONTEXT_LABELS[${NDX}]} ${P1} ${P2} ${P3} ${P4};;
			3) eval ${PF_LINE_3} ${_CONTEXT_LABELS[${NDX}]} ${P1} ${P2} ${P3} ${P4} ${P5};;
			4) eval ${PF_LINE_3} ${_CONTEXT_LABELS[${NDX}]} ${P1} ${P2} ${P3};;
			5) eval ${PF_LINE_3} ${_CONTEXT_LABELS[${NDX}]} ${P1} ${P2} ${P3} ${P4} ${P5};;
			6) eval ${PF_LINE_3} ${_CONTEXT_LABELS[${NDX}]} ${P1} ${P2};;
		esac

		((FIELD_NDX++))
		[[ ${FIELD_NDX} -eq ${FIELD_MAX} ]] && break
	done
	printf "\n%-10s\n\n" ${I_MSG}
}

finalize () {
	local ANSI_FILTER=${1}
	local LINE

	if [[ ${ANSI_FILTER} == 'true' ]];then
		while read LINE;do
			echo ${LINE}
		done | tut strip_ansi
	else
		while read LINE;do
			echo ${LINE}
		done
	fi
}

#--Begin GetOpts--
local -a OPTIONS
local OPTION
local DESC

MSG="Limit mood selection with the -m option:"
read -r -d '' DESC<<EOF
Display a verb conjugation map

${MSG}
${MAGENTA_FG}$(str_unicode_line ${#MSG})${RESET}
$(for V in ${(onv)_MOODS};do
	printf "${WHITE_FG}%s ${CYAN_FG}%s${RESET}\n" ${V} ${(C)${(k)_MOODS[(r)${V}]}}
done)
EOF

parse_opts () {
	local OPTS=${@}
	local -a OPTSTRING
	local LETTER_OPT
	local O

	for O in {1..${#OPTS}};do
		[[ ${OPTS[${O}]} =~ '[a-z]' ]] && LETTER_OPT=${OPTS[${O}]}
		[[ ${O} -eq 1 && ${OPTS[${O}]} == ":" ]] && continue
		[[ ${O} -gt 1 && ${OPTS[${O}]} == ":" ]] && OPTSTRING+=$(opt_type ${LETTER_OPT}) && continue
		OPTSTRING+="-${OPTS[${O}]}"
	done
	echo ${OPTSTRING}
}

opt_exists () {
	local OPT=${1}
	[[ $(( $OPTIONS[(Ie)${OPT}] )) -ne 0 ]] && return 0 || return 1
}

opt_type () {
	local OPT=${1}
	case ${OPT} in
		d) echo "<DIR>";;
		f) echo "<FILE>";;
		t) echo "<FILE_TYPE>";;
		m) echo "<MOOD NUMBER>";;
		v) echo "<VERB>";;
	esac
}

usage () {
	local -a PENDING_MSGS=(${@})
	local OPTS=$(parse_opts ${OPTSTR})

	[[ ${_SMCUP} == 'true' ]] && do_rmcup

	tabs 5
	echo -e "\n${WHITE_FG}\nUsage${RESET}: ${_SCRIPT} ${WHITE_FG}[${RESET}${OPTS}${WHITE_FG}]${RESET} $(opt_type v)\n"
	echo -e "${WHITE_FG}-H${RESET} help"
	echo -e "${WHITE_FG}-D${RESET} debug (repeats increase level)"
	echo -e "${WHITE_FG}-a output contains no ansi"
	echo -e "${WHITE_FG}-m $(opt_type m)${RESET} debug (repeats increase level)"
	echo -e "\n${WHITE_FG}DESC${RESET}:${DESC}"

	exit_leave $(err_msg_exit "${PENDING_MSGS}")
}

OPTSTR=":HDam:"
OPTIND=0

MOOD_SELECT=''
NO_ANSI=false

while getopts ${OPTSTR} OPTION;do
	case $OPTION in
     H) usage;;
     D) dbg_set_level;;
     a) NO_ANSI=true;;
     m) MOOD_SELECT=${OPTARG};;
     :) print -u2 "${RED_FG}${_SCRIPT}${RESET}: option: -${OPTARG} requires an argument"; usage;;
    \?) print -u2 "${RED_FG}${_SCRIPT}${RESET}: unknown option -${OPTARG}"; usage;;
	esac
	[[ ${OPTION} != 'D' ]] && OPTIONS+=${OPTION}
done
shift $((OPTIND -1))
#--End GetOpts--

# Execution
if [[ ${#} -eq 0 ]];then
	usage "Missing arg:$(opt_type v)"
else
	_VERB_ARG=${1}
fi

while true;do
	VERB_CHECK=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' limit 1")

	if [[ -z ${VERB_CHECK} ]];then
		clear
		msg_box -p -H1 -P"${RESET}Fetch data for verb:${WHITE_FG}${_VERB_ARG}|${RESET}(Y/N)?" "Add Missing Verb|Verb <w>${_VERB_ARG}<N>:<r>not found<N>"
		if [[ ${_MSG_KEY} != 'y' ]];then
			do_rmcup
			exit_leave $(err_msg_exit W "Verb ${_VERB_ARG}:not found")
		fi
		msg_box -x10 "Fetching data..."
		get_verb ${_VERB_ARG} >/dev/null 2>&1
		[[ ${?} -ne 0 ]] && do_rmcup && exit_leave $(err_msg_exit E "Unable to fetch verb:${_VERB_ARG}")
		sleep 1
	else
		break
	fi
done

clear

TRANS=$(translation)
PART=$(participle)
GER=$(gerund)

(
printf "\n${CYAN_FG}Verb${RESET}:${WHITE_FG}%s${RESET} - ${ITALIC}%s${RESET}\n" ${(C)_VERB_ARG} ${(C)TRANS}
printf "${CYAN_FG}Past Participle${RESET}:${WHITE_FG}%s${RESET}\n" ${(C)PART}
printf "${CYAN_FG}Gerund${RESET}:${WHITE_FG}%s${RESET}\n\n" ${(C)GER}

if [[ -n ${MOOD_SELECT} ]];then
	VALID_MOOD=${(k)_MOODS[(r)${MOOD_SELECT}]} 
	[[ -z ${VALID_MOOD} ]] && usage "Invalid $(opt_type m):${MOOD_SELECT}"

	format ${MOOD_SELECT}
else
	NDX=0
	for M in ${(ov)_MOODS};do
		((NDX++))
		format ${NDX}
	done
fi
) | sed 's/_/ /g' | finalize ${NO_ANSI}

exit_leave
