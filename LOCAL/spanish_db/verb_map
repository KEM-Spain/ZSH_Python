#!/usr/bin/zsh
#Inline ansi
BOLD="\033[1m"
ITALIC="\033[3m"
RESET="\033[m"
REVERSE="\033[7m"
STRIKE="\033[9m"
UNDER="\033[4m"

BLACK_BG="\033[40m"

BLUE_FG="\033[34m"
CYAN_FG="\033[36m"
GREEN_FG="\033[32m"
MAGENTA_FG="${BOLD}${ITALIC}\033[35m"
RED_FG="\033[31m"
WHITE_FG="\033[37m"
YELLOW_FG="\033[33m"

# Imports
[[ -z ${ZSH_LIB_DIR} ]] && _LIB_DIR=/usr/local/lib || _LIB_DIR=${ZSH_LIB_DIR}
source ${_LIB_DIR}/LIB_INIT.zsh # Must be first
source ${_LIB_DIR}/UTILS.zsh
source ${_LIB_DIR}/LIB_DEPS.zsh # Must be last

#Declarations
typeset _VERB_ARG=''
typeset -a _VERB_DATA
typeset -A _MOOD_LBLS=(1 indicative 2 subjunctive 3 perfect 4 perfect_subj 5 progressive 6 imperative)
typeset -A _PRONOUN_LBLS=(1 yo 2 tú 3 él 4 nosotros 5 vosotros 6 ellos 7 irregular)
typeset -A _IND_COL_LBLS=(1 present 2 preterite 3 imperfect 4 conditional 5 future)
typeset -A _SUB_COL_LBLS=(1 present 2 future 3 imperfect2 4 imperfect)
typeset -A _PSUB_COL_LBLS=(1 present 2 past 3 future)
typeset -A _IMP_COL_LBLS=(1 affirmative 2 negative)
typeset -A _LBL_MAP=(1 _IND_COL_LBLS 2 _SUB_COL_LBLS 3 _IND_COL_LBLS 4 _PSUB_COL_LBLS 5 _IND_COL_LBLS 6 _IMP_COL_LBLS)

# Vars
_FIRST_VERB_FIELD=4
_LAST_VERB_FIELD=9

# Functions
translation () {
	local TRANS=$(do_query -d '|' "select translation from spanish_verb where verb = '${_VERB_ARG}'")
	echo ${TRANS}
}

participle () {
	local PART=$(do_query -d '|' "select past_participle from spanish_verb where verb = '${_VERB_ARG}'")
	echo ${PART}
}

gerund () {
	local PART=$(do_query -d '|' "select gerund from spanish_verb where verb = '${_VERB_ARG}'")
	echo ${PART}
}

irregular () {
	do_query -d '|' "select irregular from spanish_verb where verb = '${_VERB_ARG}'"
}

indicative () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'indicative' and tense = 'present'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'indicative' and tense = 'preterite'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'indicative' and tense = 'future'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'indicative' and tense = 'conditional'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'indicative' and tense = 'imperfect'")
}

subjunctive () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'subjunctive' and tense = 'present'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'subjunctive' and tense = 'imperfect'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'subjunctive' and tense = 'imperfect2'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'subjunctive' and tense = 'future'")
}

perfect () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect' and tense = 'present'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect' and tense = 'preterite'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect' and tense = 'imperfect'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect' and tense = 'conditional'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect' and tense = 'future'")
}

perfect_subj () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect_subj' and tense = 'present'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect_subj' and tense = 'past'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'perfect_subj' and tense = 'future'")
}

progressive () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'progressive' and tense = 'present'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'progressive' and tense = 'preterite'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'progressive' and tense = 'imperfect'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'progressive' and tense = 'conditional'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'progressive' and tense = 'future'")
}

imperative () {
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'imperative' and tense = 'affirmative'")
	_VERB_DATA+=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' and mood = 'imperative' and tense = 'negative'")
}

do_pager () {
	local PAGING=${1}
	local ANSI=${2}
	local LINE

	if [[ ${PAGING} == 'false' ]];then
		while read LINE;do
			[[ ${ANSI} == 'false' ]] && str_strip_ansi <<<${LINE} || echo ${LINE}
		done
	else
		while read LINE;do
			[[ ${ANSI} == 'false' ]] && str_strip_ansi <<<${LINE} || echo ${LINE}
		done | mypager
	fi
}

#--Begin GetOpts--
local -a OPTIONS
local OPTION
local DESC

MSG="Limit mood selection with the -m option:"
read -r -d '' DESC<<EOF
Display a verb conjugation map
\tMood selection is optional. Default
\tbehaviour is to display all moods.

${MSG}
${MAGENTA_FG}$(str_unicode_line ${#MSG})${RESET}
$(for V in ${(onk)_MOOD_LBLS};do
	printf "${WHITE_FG}%s ${CYAN_FG}%s${RESET}\n" ${V} ${(C)${_MOOD_LBLS[${V}]}}
done)
EOF

parse_opts () {
	local OPTS=${@}
	local -a OPTSTRING
	local LETTER_OPT
	local O

	for O in {1..${#OPTS}};do
		[[ ${OPTS[${O}]} =~ '[a-z]' ]] && LETTER_OPT=${OPTS[${O}]}
		[[ ${O} -eq 1 && ${OPTS[${O}]} == ":" ]] && continue
		[[ ${O} -gt 1 && ${OPTS[${O}]} == ":" ]] && OPTSTRING+=$(opt_type ${LETTER_OPT}) && continue
		OPTSTRING+="-${OPTS[${O}]}"
	done
	echo ${OPTSTRING}
}

opt_exists () {
	local OPT=${1}
	[[ $(( $OPTIONS[(Ie)${OPT}] )) -ne 0 ]] && return 0 || return 1
}

opt_type () {
	local OPT=${1}
	case ${OPT} in
		d) echo "<DIR>";;
		f) echo "<FILE>";;
		t) echo "<FILE_TYPE>";;
		m) echo "<MOOD NUMBER>";;
		v) echo "<VERB>";;
	esac
}

usage () {
	local -a PENDING_MSGS=(${@})
	local OPTS=$(parse_opts ${OPTSTR})

	[[ ${_SMCUP} == 'true' ]] && do_rmcup

	tabs 5
	echo -e "\n${WHITE_FG}\nUsage${RESET}: ${_SCRIPT} ${WHITE_FG}[${RESET}${OPTS}${WHITE_FG}]${RESET} $(opt_type v)\n"
	echo -e "${WHITE_FG}-H${RESET} help"
	echo -e "${WHITE_FG}-D${RESET} debug (repeats increase level)"
	echo -e "${WHITE_FG}-a${RESET} output contains no ansi"
	echo -e "${WHITE_FG}-m${RESET} $(opt_type m)${RESET}"
	echo -e "${WHITE_FG}-p${RESET} paged output"
	echo -e "\n${WHITE_FG}DESC${RESET}:${DESC}"

	exit_leave $(err_msg_exit "${PENDING_MSGS}")
}

OPTSTR=":HDam:p"
OPTIND=0

MOOD_SELECT=''
ANSI=true
PAGE_OPT=false

while getopts ${OPTSTR} OPTION;do
	case $OPTION in
     H) usage;;
     D) dbg_set_level;;
     a) ANSI=false;;
     m) MOOD_SELECT=${OPTARG};;
     p) PAGE_OPT=true;;
     :) print -u2 "${RED_FG}${_SCRIPT}${RESET}: option: -${OPTARG} requires an argument"; usage;;
    \?) print -u2 "${RED_FG}${_SCRIPT}${RESET}: unknown option -${OPTARG}"; usage;;
	esac
	[[ ${OPTION} != 'D' ]] && OPTIONS+=${OPTION}
done
shift $((OPTIND -1))
#--End GetOpts--

# Execution
if [[ ${#} -eq 0 ]];then
	usage "Missing arg:$(opt_type v)"
else
	_VERB_ARG=${1}
	clear
fi

while true;do
	VERB_CHECK=$(do_query -d '|' "select * from spanish_tense where verb = '${_VERB_ARG}' limit 1")

	if [[ -z ${VERB_CHECK} ]];then
		clear
		msg_box -p -H1 -P"${RESET}Fetch data for verb:${WHITE_FG}${_VERB_ARG}|${RESET}(Y/N)?" "Add Missing Verb|Verb <w>${_VERB_ARG}<N>:<r>not found<N>"
		if [[ ${_MSG_KEY} != 'y' ]];then
			do_rmcup
			exit_leave $(err_msg_exit W "Verb ${_VERB_ARG}:not found")
		fi
		msg_box -x10 "Fetching data..."
		get_verb ${_VERB_ARG} >/dev/null 2>&1
		[[ ${?} -ne 0 ]] && do_rmcup && exit_leave $(err_msg_exit E "Unable to fetch verb:${_VERB_ARG}")
		sleep 1
	else
		break
	fi
done

typeset -A INLINE=()
typeset -A FLD_WIDTH=()

COL_NDX=0
CON_NDX=0
BLOCK=0
LONGEST=0
for V in ${(onk)_MOOD_LBLS};do
	(( BLOCK++ ))
	${${_MOOD_LBLS[${V}]}:l} # Call function to populate _VERB_DATA
	for L in ${_VERB_DATA};do
		(( COL_NDX++ )) # Horizontal across row
		for (( F=${_FIRST_VERB_FIELD}; F<=${_LAST_VERB_FIELD}; F++ ));do
			(( CON_NDX++ )) # Vertical through block
			FIELD=$(cut -d'|' -f${F} <<<${L})
			INLINE[${BLOCK}${COL_NDX}${CON_NDX}]=${FIELD}
			[[ ${#FIELD} -gt ${LONGEST} ]] && LONGEST=${#FIELD}
		done
		CON_NDX=0
	done
	COL_NDX=0
	_VERB_DATA=()
	FLD_WIDTH[${BLOCK}]=${LONGEST}
	LONGEST=0
done

for W in ${(onk)FLD_WIDTH};do
	MAP=${_LBL_MAP[$W]}
	for M in ${(P)MAP};do
		if [[ ${#M} -gt ${FLD_WIDTH[${W}]} ]];then
			FLD_WIDTH[${W}]=${#M}
		fi
	done
done

local IRRG=$(irregular)
[[ ${IRRG} -eq 1 ]] && IRRG="(irregular)" || IRRG="regular"
local GRND=$(gerund)
local PART=$(participle)
local DEFN=$(translation)

[[ -n ${DEFN} ]] && DEFN=$(html2text <<<${DEFN})

typeset -a FIELD_LIST=()
typeset -a HDRS=()
typeset -a DIVS=()

(
tcup 0 0
echo "Verb:${WHITE_FG}${_VERB_ARG}${RESET} (${IRRG})"
echo "Gerund:${WHITE_FG}${GRND}${RESET}"
echo "Past Participle:${WHITE_FG}${PART}${RESET}"
echo "Definition:${WHITE_FG}${DEFN}${RESET}\n"

for (( B=1; B<=6; B++ ));do
	echo "${ITALIC}${UNDER}${BOLD}${WHITE_FG}${(C)_MOOD_LBLS[${B}]}${RESET}"
	for (( R=1; R<=6; R++ ));do
		FIELD_LIST+=" ${_PRONOUN_LBLS[${R}]} "
		PF="printf \" ${CYAN_FG}%-8s${RESET} " # Initialize PF
		HPF=${PF} # Initialize Header PF
		DIV=${PF} # Initialize Header DIV
		for (( C=1; C<=5; C++ ));do
			if [[ -n ${INLINE[${B}${C}${R}]} ]];then
				PF+=" %-${FLD_WIDTH[${B}]}s " # Add PF slots
				HPF+=" ${CYAN_FG}%-${FLD_WIDTH[${B}]}s${RESET} " # Add HPF slots
				DIV+=" ${MAGENTA_FG}%-${FLD_WIDTH[${B}]}s${RESET} " # Add DIV slots
				FIELD_LIST+=" ${INLINE[${B}${C}${R}]} "
			fi
		done # Cols
		PF[(( ${#PF} - 1 ))]+='\\n"' # Finish PF
		HPF[(( ${#HPF} - 1 ))]+='\\n"' # Finish HPF
		DIV[(( ${#DIV} - 1 ))]+='\\n"' # Finish DIV
		if [[ ${R} -eq 1 ]];then
			for (( C=1; C<=5; C++ ));do
				if [[ -n ${INLINE[${B}${C}${R}]} ]];then
					HDRS+=${${(P)_LBL_MAP[${B}]}[${C}]} # Pull indexed order
					DIVS+="\$(str_unicode_line ${FLD_WIDTH[${B}]})"
				fi
			done
			eval "${HPF} ' ' ${(C)HDRS}"
			eval "${DIV} ' ' ${DIVS}"
			HDRS=()
			DIVS=()
		fi
		eval "${PF} ${FIELD_LIST}"
		FIELD_LIST=()
	done # Rows
	echo # Block separator
done
) | sed 's/_/ /g' | do_pager ${PAGE_OPT} ${ANSI}
